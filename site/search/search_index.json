{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Aktuelle Trends der IKT","text":"<p>Herzlich willkommen zur Veranstaltung Aktuelle Trends der IKT! </p>"},{"location":"#grober-inhalt","title":"Grober Inhalt","text":"<p>Wir besch\u00e4ftigen uns dieses Semester mit Progressive Web Apps (PWA). Dieser Begriff ist 2015 bei Google entstanden. Progressive Web Apps bieten installierbare nativen Apps \u00e4hnliche Nutzererfahrungen sowohl auf dem Desktop als auch auf dem Smartphone, sind aber Webanwendungen, die im Browser laufen, also zum World Wide Web geh\u00f6ren. Typische Eigenschaften von Progressive Web Apps sind die Einbindung von Kamera und Mikrofon, dem eigenen Standort sowie die F\u00e4higkeit, (zumindest teilweise) offline ausf\u00fchrbar zu sein. </p> <p>Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). </p> Woche Themen (Vorlesung) Aufgabe (Stand) Abgabe \u00dcbung bis 1. 10.-14.04.2023 Einf\u00fchrung und Organisatorisches \u00a0- - 2. 17.-21.04.2023 Grundger\u00fcst und Application Manifest \u00a0- 30.04.2023 3. 24.-28.04.2023 Service workers \u00a0- 07.05.2023 4. 01.-05.05.2023 Promises und Fetch API \u00a0- 14.05.2023 5. 08.-12.05.2023 Service workers und Caching \u00a0- 21.05.2023 6. 15.-19.05.2023 MongoDB und Backend \u00a0- 28.05.2023 7. 22.-26.05.2023 Bilder-Up- und Download (Backend) \u00a0- 04.06.2023 8. 29.-02.06.2023 IndexedDB \u00a0- 11.06.2023 9. 05.-09.06.2023 Kamera \u00a0- 18.06.2023 10. 12.-16.06.2023 Geolocation Datenbank - 11. 19.-23.06.2023 Hintergrundsynchronisation Backend - 12. 26.-30.06.2023 Push-Notifikationen Backend - 13. 03.-06.07.2023 Wiederholung Frontend - 14. 10.-14.07.2023 Wiederholung Frontend - \u00a0Gespr\u00e4che 1.PZ 26.07.2023 (Abgabe 25.07.2023) - \u00a0Gespr\u00e4che 2.PZ 27.09.2023 (Abgabe 26.09.2023) -"},{"location":"#organisatorisches","title":"Organisatorisches","text":"<p>Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen Sie am Ende des Semesters die L\u00f6sung Ihrer Semesteraufgabe abgeben. Diese Aufgabe zusammen mit einem Gespr\u00e4ch, das wir \u00fcber Ihre L\u00f6sung f\u00fchren, wird bewertet. Die Bewertung entspricht dann der Modulnote. </p> <p>Die \u00dcbungen sind daf\u00fcr vorgesehen, dass Sie im Semester sukzessive Ihre L\u00f6sung erstellen k\u00f6nnen. Wir beantworten in den \u00dcbungen Ihre Fragen und l\u00f6sen gemeinsam Probleme. Jede Woche gibt es ein Thema, das Sie selbst\u00e4ndig durcharbeiten und dann angepasst in Ihre L\u00f6sung integrieren k\u00f6nnen.  </p> <p>F\u00fcr die Kommunikation untereinander verwenden wir Slack. Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt!</p>"},{"location":"#semesteraufgabe","title":"Semesteraufgabe","text":"<p>Die als Semesteraufgabe zu entwickelnde Webanwendung sollte</p> <ol> <li>ein Frontend besitzen (muss nicht mit einem JavaScript-Framework erstellt werden),</li> <li>das Frontend soll responsive sein (mobile first!),</li> <li>ein Backend (damit Daten auf dem Server verwaltet werden k\u00f6nnen), </li> <li>eine Datenbank zur persistenten Speicherung von Daten (wir verwenden MongoDB, kann aber auch MariaDB, MySQL, PostgresQL oder auch SQLite oder \u00e4hnlich In-Apps-Datenbanken sein - aber nicht Firebase!),</li> <li>installierbar sein,</li> <li>offline nutzbar sein,</li> <li>die IndexedDB verwenden,</li> <li>Hintergrundsynchronisation verwenden,</li> <li>Push-Nachrichten verwenden,</li> <li>die Gelocation API verwenden,</li> <li>die Kamera oder eine andere technische Schnittstelle (z.B. Sensoren, Mikrofon) verwenden,</li> <li>eine aussagekr\u00e4ftige <code>README.md</code>-Datei enthalten, die sowohl die Anwendung (Screenshots) gut pr\u00e4sentiert, als auch alle Anweisungen zur Installation.</li> </ol> <p>Von den Punkten 5.-11. sollten </p> <ul> <li>5 f\u00fcr eine 2,0 implementiert sein, </li> <li>6 f\u00fcr eine 1,7 und </li> <li>7 f\u00fcr eine 1,3. </li> <li>Ist die Anwendung besonders toll und deployed, kann es auch eine 1,0 werden. </li> </ul> <p>Die Anwendung muss in einem Git-Dienst (GitHub, GitLab, ...) verf\u00fcgbar sein. Die erstellte Anwendung soll pr\u00e4sentiert werden und in einem kurzen Gespr\u00e4ch (15-20min) wird die Implementierung besprochen. </p> <p>Hier eine Idee einer Anwendung, eine Ausgabenverwaltung:</p> <ul> <li>installierbare Webanwendung, </li> <li>Formular f\u00fcr die Buchung einer Ausgabe <ul> <li>Datum, </li> <li>Titel f\u00fcr die Ausgabe, </li> <li>Betrag, </li> <li>Foto des Kassenzettels, </li> <li>evtl. Geolocation des Ausgabeortes</li> </ul> </li> <li>\u00dcbersicht \u00fcber Ausgaben,</li> <li>offline verwendbar, d.h. Ausgabe wird in der IndexedDB gespeichert und erst, wenn wieder online, dann in der Datenbank,</li> <li>Push-Benachrichtigung, wenn Ausgabe in der Datenbank gespeichert (Hintergrundsynchronisation), </li> <li>Backend ist zwingend erforderlich (f\u00fcr Speichern und Abrufen der Daten in die und aus der Datenbank),</li> <li>MongoDB zur persitenten Datenspeicherung,</li> <li>evtl. Nutzerverwaltung zur Verwaltung der eigenen Ausgaben.</li> </ul> <p>Sie k\u00f6nnen nat\u00fcrlich auch eine eigene Anwendungsidee umsetzen! Viel Spa\u00df und Erfolg!   </p>"},{"location":"backend/","title":"Backend - REST-Server","text":"<p>Ehe wir uns der IndexedDB-API zuwenden, erstellen wir zun\u00e4chst eine \"richtige\" Datenbank f\u00fcr unsere Posts. F\u00fcr diese Datenbank stellen wir die Implementierung einer Schnittstelle bereit, so dass wir die wesentlichen Datenbankanfragen dar\u00fcber ausf\u00fchren k\u00f6nnen. Diese wesentlichen Datenbankfragen werden mit CRUD abgek\u00fcrzt, f\u00fcr Create, Read, Update und Delete. Das bedeutet, wir implementieren Funktionalit\u00e4ten, mit denen wir einen neuen <code>post</code> in die Datenbank einf\u00fcgen (create), aus der Datenbank auslesen (read), in der Datenbank aktualisieren (update) und aus der Datenbank l\u00f6schen (delete) k\u00f6nnen. </p> <p>Die Schnittstelle, die wir implementieren, ist eine sogenannte REST-API. REST steht f\u00fcr Representational State Transfer und basiert auf einigen wenigen Prinzipien:</p> <ol> <li>Alles wird als eine Ressource betrachtet, z.B. <code>post</code>.</li> <li>Jede Ressource ist durch URIs (Uniform Resource Identifiers) eindeutig identifizierbar, z.B. <code>http://localhost/posts</code>.</li> <li>Es werden die Standard-HTTP-Methoden verwendet, also <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>UPDATE</code>.  </li> <li>Ressourcen k\u00f6nnen in verschiedenen Formaten vorliegen, z.B. in HTML, XML, JSON, ...</li> <li>Die Kommunikation ist zustandslos. Jede einzelne HTTP-Anfrage wird komplett isoliert bearbeitet. Es gibt keinerlei Anfragehistorie. </li> </ol> <p>Das bedeutet, wir erstellen ein Backend (einen REST-Server), an den HTTP-Anfragen mit der eindeutig identifizierbaren Ressource gestellt werden. Das Backend erstellt daraus die entsprechende SQL-Query. Das Resultat der Datenbankanfrage wird im <code>JSON</code>- oder <code>HTML</code>- oder <code>XML</code>- oder in einem anderen Format bereitsgestellt.</p> <p></p> <p>Prinzipiell gibt es also ein Mapping von HTTP-Anfragen auf SQL-Anfragen:</p> CRUD SQL MongoDB HTTP create INSERT insertOne(), insertMany() POST read SELECT findOne(), find() GET update UPDATE updateOne(), updateMany() PUT (oder PATCH) delete DELETE deleteOne(), deleteMany() DELETE <p>Zur Unterscheidung zwischen <code>PUT</code> und <code>PATCH</code> siehe z.B. hier oder hier. Wir wollen uns ein Backend erstellen, \u00fcber das wir unsere Daten verwalten. Dazu \u00fcberlegen wir uns zun\u00e4chst ein paar sogenannte Endpunkte (siehe Prinzipien von REST oben) und die Zugriffsmethoden, mit denen wir auf unsere Daten zugreifen wollen.</p> \u00a0Methode \u00a0URL \u00a0Bedeutung \u00a0GET \u00a0/posts \u00a0hole alle Datens\u00e4tze \u00a0GET \u00a0/posts/11 hole den Datensatz mit der id=11 \u00a0POST \u00a0/posts \u00a0f\u00fcge einen neuen Datensatz hinzu \u00a0PUT \u00a0/posts/11 \u00a0\u00e4ndere den Datensatz mit der id=11 \u00a0DELETE \u00a0/posts/11 \u00a0l\u00f6sche den Datensatz mit der id=11 <p>Der Wert der <code>id</code> ist nat\u00fcrlich nur ein Beispiel. Es soll f\u00fcr alle <code>id</code>-Werte funktionieren, die in unserem Datensatz enthalten sind. Korrekterweise beschreiben wir die Endpunkte mit variabler <code>id</code> besser durch <code>/posts/:id</code> oder <code>/posts/{id}</code>.</p>"},{"location":"backend/#openapi","title":"OpenAPI","text":"<p>Hier geht es zun\u00e4chst um die Dokumentation der zu erstellenden REST-API. Wenn Sie an der Dokumentation nicht interssiert sind, k\u00f6nnen Sie auch direkt zur Implementierung springen. Eine ordentliche Dokumentation Ihrer REST-API ist jedoch immer gut und richtig. Es l\u00e4sst sich daraus sogar bereits Code erzeugen. </p> <p>F\u00fcr eine Dokumentation der zu erstellenden REST-API ist OpenAPI geeignet. Unter https://app.swaggerhub.com/home steht ein Werkzeug zur Verf\u00fcgung, um eine solche API-Dokumentation zu erstellen. Sie m\u00fcssen sich dort registrieren und einloggen. Klicken Sie <code>Create New</code>, um eine neue Dokumentation zu beginnen:</p> <p> </p> Eingabemaske f\u00fcr neue REST-API <p>Es wird automatisch erstellt:</p> Simple Inventory API <pre><code>openapi: 3.0.0\nservers:\n# Added by API Auto Mocking Plugin\n- description: SwaggerHub API Auto Mocking\nurl: https://virtserver.swaggerhub.com/jfreiheit/Posts-API/1.0.0\ninfo:\ndescription: This is a simple API\nversion: \"1.0.0\"\ntitle: Simple Inventory API\ncontact:\nemail: you@your-company.com\nlicense:\nname: Apache 2.0\nurl: 'http://www.apache.org/licenses/LICENSE-2.0.html'\ntags:\n- name: admins\ndescription: Secured Admin-only calls\n- name: developers\ndescription: Operations available to regular developers\npaths:\n/inventory:\nget:\ntags:\n- developers\nsummary: searches inventory\noperationId: searchInventory\ndescription: |\nBy passing in the appropriate options, you can search for\navailable inventory in the system\nparameters:\n- in: query\nname: searchString\ndescription: pass an optional search string for looking up inventory\nrequired: false\nschema:\ntype: string\n- in: query\nname: skip\ndescription: number of records to skip for pagination\nschema:\ntype: integer\nformat: int32\nminimum: 0\n- in: query\nname: limit\ndescription: maximum number of records to return\nschema:\ntype: integer\nformat: int32\nminimum: 0\nmaximum: 50\nresponses:\n'200':\ndescription: search results matching criteria\ncontent:\napplication/json:\nschema:\ntype: array\nitems:\n$ref: '#/components/schemas/InventoryItem'\n'400':\ndescription: bad input parameter\npost:\ntags:\n- admins\nsummary: adds an inventory item\noperationId: addInventory\ndescription: Adds an item to the system\nresponses:\n'201':\ndescription: item created\n'400':\ndescription: 'invalid input, object invalid'\n'409':\ndescription: an existing item already exists\nrequestBody:\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/InventoryItem'\ndescription: Inventory item to add\ncomponents:\nschemas:\nInventoryItem:\ntype: object\nrequired:\n- id\n- name\n- manufacturer\n- releaseDate\nproperties:\nid:\ntype: string\nformat: uuid\nexample: d290f1ee-6c54-4b01-90e6-d701748f0851\nname:\ntype: string\nexample: Widget Adapter\nreleaseDate:\ntype: string\nformat: date-time\nexample: '2016-08-29T09:12:33.001Z'\nmanufacturer:\n$ref: '#/components/schemas/Manufacturer'\nManufacturer:\nrequired:\n- name\nproperties:\nname:\ntype: string\nexample: ACME Corporation\nhomePage:\ntype: string\nformat: url\nexample: 'https://www.acme-corp.com'\nphone:\ntype: string\nexample: 408-867-5309\ntype: object\n</code></pre> <p>Zur Erl\u00e4uterung:</p> <ul> <li>Unter dem Schl\u00fcssel <code>paths</code> (Zeile <code>20</code>) ist ein Pfad (eine Route) definiert, n\u00e4mlich <code>/inventory</code>. Bei diesem Pfad handelt es sich um ein sogenanntes Path Item Object</li> <li> <p>Der Pfad <code>/inventory</code> enth\u00e4lt zwei sogenannte Operation Objects, n\u00e4mlich <code>GET</code> (Zeile <code>22</code>) und <code>POST</code> (Zeile <code>63</code>). Ein Operation Object kann verschiedene Eigenschaften beinhalten:</p> <ul> <li><code>tags</code>: Schl\u00fcsselw\u00f6rter, um die API-Dokumentation zu gruppieren (siehe unten im Bild <code>Dokumentation der REST-API</code> die Gruppen <code>admins</code> und <code>developers</code>)</li> <li><code>summary</code>: dient der Erl\u00e4uterung eines Endpunktes (siehe unten im Bild <code>Dokumentation der REST-API</code> die Erl\u00e4uterungen <code>searches inventory</code> und <code>adds an inventory item</code>)</li> <li><code>description</code>: beschreibt die Funktionalit\u00e4t des Endpunktes detaillierter. Erscheint in der Dokumentation bei den Details eines Endpunktes (siehe unten im Bild <code>Get /inventroy-Endpunkt im Detail</code>)</li> <li><code>responses</code>: beschreibt die R\u00fcckgabe des Endpunktes. Es handelt sich um ein Responses Object. Diese k\u00f6nnen nach HTTP-Statuscodes unterteilt werden. Neben der <code>description</code> f\u00fcr den Statuscode kann dabei insbesondere der Typ der <code>responses</code> definiert werden. In der <code>content</code>-Eigenschaft wird zun\u00e4chst der Typ der akzeptierten Response definiert, z.B. <code>application/json</code> oder <code>image/png</code>. Dann wird spezifiziert, welcher Datentyp zur\u00fcckgeben wird. Die Zeilen <code>57-60</code> beschrieben bspw., dass ein Array von <code>InventoryItems</code> zur\u00fcckgegeben wird. Ein solches <code>InventoryItem</code> ist unter der Eigenschaft <code>schemas</code> definiert. Mithilfe von <code>$ref: '#/components/schemas/InventoryItem'</code> wird auf dieses Schema referenziert. </li> <li>Unter dem Schl\u00fcssel <code>components</code> k\u00f6nnen <code>schemas</code>, <code>responses</code>, <code>parameters</code>, <code>examples</code>, <code>requestBodies</code>, <code>headers</code> usw. spezifiziert werden. Mithilfe von <code>$ref</code> kann dann auf jede dieser Komponenten referenziert werden. In obigem Beispiel wurde das Schema <code>InventoryItem</code> und das Schema <code>Manufacturer</code> definiert. Diese Schemen entsprechen den verwendeten Datenmodellen. </li> </ul> </li> </ul> <p> </p> Dokumentation der REST-API <p> </p> GET /inventory-Endpunkt im Detail"},{"location":"backend/#yaml","title":"YAML","text":"<p>Die obige Beschreibung ist \u00fcbrigens in YAML. Urspr\u00fcnglich stand YAML f\u00fcr Yet Anaother Markup Language. Jetzt sagt die Spezifikation von YAML aber YAML Ain't Markup Language. Es hat \u00c4hnlichkeiten zu JSON, kommt allerdings ohne Klammerung aus. Daf\u00fcr spielt das Einr\u00fccken eine Rolle. OpenAPI unterst\u00fctzt sowohl JSON als auch YAML. </p>"},{"location":"backend/#die-posts-routen","title":"Die '/posts'-Routen","text":"<p>Wir spezifizieren zun\u00e4chst die <code>/posts</code>-Routen, also <code>GET /posts</code> und <code>POST /posts</code>.</p> Posts-API <pre><code>openapi: 3.0.0\nservers:\n# Added by API Auto Mocking Plugin\n- description: SwaggerHub Server\nurl: https://virtserver.swaggerhub.com/jfreiheit/Posts-API/1.0.0\ninfo:\ndescription: REST-API f\u00fcr IKT-PWA HTWInsta\nversion: \"1.0.0\"\ntitle: Posts-API\ncontact:\nemail: freiheit@htw-berlin.de\nlicense:\nname: Apache 2.0\nurl: 'http://www.apache.org/licenses/LICENSE-2.0.html'\ntags:\n- name: Posts\ndescription: CRUD f\u00fcr Posts\n- name: Images\ndescription: CRUD f\u00fcr Bilder\npaths:\n/posts:\nget:\ntags:\n- Posts\nsummary: lese alle Posts\noperationId: getAllPosts\ndescription: download Array aller verf\u00fcgbaren Posts\nresponses:\n'200':\ndescription: alle verf\u00fcgbaren Posts geladen\ncontent:\napplication/json:\nschema:\ntype: array\nitems:\n$ref: '#/components/schemas/Post'\npost:\ntags:\n- Posts\nsummary: f\u00fcge einen neuen Post hinzu\noperationId: createNewPost\ndescription: neuen Post erzeugen und speichern\nresponses:\n'201':\ndescription: Post created\n'409':\ndescription: Post existiert bereits\nrequestBody:\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/Post'\ndescription: neuer Post\ncomponents:\nschemas:\nPost:\ntype: object\nrequired:\n- title\n- location\n- image_id\nproperties:\ntitle:\ntype: string\nexample: H-Geb\u00e4ude\nlocation:\ntype: string\nexample: Campus Wilhelminenhof\nimage_id:\ntype: string\nexample: Campus Wilhelminenhof\n</code></pre>"},{"location":"backend/#die-postsid-routen","title":"Die '/posts/{id}'-Routen","text":"<p>Nun f\u00fcgen wir noch die <code>/posts/{id}</code>-Routen hinzu, also <code>GET /posts/{id}</code>, <code>PUT /posts/{id}</code> und <code>DELETE /posts/{id}</code>.</p> Posts-API <pre><code>  /posts/{id}:\nget:\ntags:\n- Posts\nsummary: lese einen Post mit der passenden id\noperationId: getOnePost\ndescription: download entsprechenden Post\nparameters:\n- name: id\nin: path\nrequired: true\ndescription: Post-ID\nschema:\ntype : string\nresponses:\n'200':\ndescription: Post mit entsprechender id geladen\ncontent:\napplication/json:\nschema:\ntype: object\nitems:\n$ref: '#/components/schemas/Post'\n'404':\ndescription: Post bzw. id nicht gefunden\nput:\ntags:\n- Posts\nsummary: \u00e4ndere einen Post mit der passenden id\noperationId: updateOnePost\ndescription: aktualisiere entsprechenden Post\nparameters:\n- name: id\nin: path\nrequired: true\ndescription: Post-ID\nschema:\ntype : string\nresponses:\n'200':\ndescription: Post mit entsprechender id aktualisiert\ncontent:\napplication/json:\nschema:\ntype: object\nitems:\n$ref: '#/components/schemas/Post'\n'404':\ndescription: Post bzw. id nicht gefunden\nrequestBody:\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/Post'\ndescription: zu aktualisierender Post\ndelete:\ntags:\n- Posts\nsummary: l\u00f6sche einen Post mit der passenden id\noperationId: deleteOnePost\ndescription: l\u00f6sche entsprechenden Post\nparameters:\n- name: id\nin: path\nrequired: true\ndescription: Post-ID\nschema:\ntype : string\nresponses:\n'200':\ndescription: Post mit entsprechender id gel\u00f6scht\ncontent:\napplication/json:\nschema:\ntype: object\nitems:\n$ref: '#/components/schemas/Post'\n'404':\ndescription: Post bzw. id nicht gefunden\n</code></pre>"},{"location":"backend/#die-vollstandige-yaml-datei","title":"Die vollst\u00e4ndige YAML-Datei","text":"<p>Hier die vollst\u00e4ndige YAML-Datei, die Sie auch in Postman importieren k\u00f6nnen.</p> openapi.yaml <pre><code>    openapi: 3.0.0\ninfo:\ntitle: Posts-API\ndescription: REST-API f\u00fcr IKT-PWA HTWInsta\ncontact:\nemail: freiheit@htw-berlin.de\nlicense:\nname: Apache 2.0\nurl: http://www.apache.org/licenses/LICENSE-2.0.html\nversion: 1.0.0\nservers:\n- url: https://virtserver.swaggerhub.com/jfreiheit/Posts-API/1.0.0\ndescription: SwaggerHub Server\ntags:\n- name: Posts\ndescription: CRUD f\u00fcr Posts\n- name: Images\ndescription: CRUD f\u00fcr Bilder\npaths:\n/posts:\nget:\ntags:\n- Posts\nsummary: lese alle Posts\ndescription: download Array aller verf\u00fcgbaren Posts\noperationId: getAllPosts\nresponses:\n\"200\":\ndescription: alle verf\u00fcgbaren Posts geladen\ncontent:\napplication/json:\nschema:\ntype: array\nitems:\n$ref: '#/components/schemas/Post'\nx-content-type: application/json\nx-swagger-router-controller: Posts\npost:\ntags:\n- Posts\nsummary: f\u00fcge einen neuen Post hinzu\ndescription: neuen Post erzeugen und speichern\noperationId: createNewPost\nrequestBody:\ndescription: neuer Post\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/Post'\nresponses:\n\"201\":\ndescription: Post created\n\"409\":\ndescription: Post existiert bereits\nx-swagger-router-controller: Posts\n/posts/{id}:\nget:\ntags:\n- Posts\nsummary: lese einen Post mit der passenden id\ndescription: download entsprechenden Post\noperationId: getOnePost\nparameters:\n- name: id\nin: path\ndescription: Post-ID\nrequired: true\nstyle: simple\nexplode: false\nschema:\ntype: string\nresponses:\n\"200\":\ndescription: Post mit entsprechender id geladen\ncontent:\napplication/json:\nschema:\ntype: array\nitems:\n$ref: '#/components/schemas/Post'\nx-content-type: application/json\n\"404\":\ndescription: Post bzw. id nicht gefunden\nx-swagger-router-controller: Posts\nput:\ntags:\n- Posts\nsummary: \u00e4ndere einen Post mit der passenden id\ndescription: aktualisiere entsprechenden Post\noperationId: updateOnePost\nparameters:\n- name: id\nin: path\ndescription: Post-ID\nrequired: true\nstyle: simple\nexplode: false\nschema:\ntype: string\nrequestBody:\ndescription: zu aktualisierender Post\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/Post'\nresponses:\n\"200\":\ndescription: Post mit entsprechender id aktualisiert\ncontent:\napplication/json:\nschema:\ntype: array\nitems:\n$ref: '#/components/schemas/Post'\nx-content-type: application/json\n\"404\":\ndescription: Post bzw. id nicht gefunden\nx-swagger-router-controller: Posts\ndelete:\ntags:\n- Posts\nsummary: l\u00f6sche einen Post mit der passenden id\ndescription: l\u00f6sche entsprechenden Post\noperationId: deleteOnePost\nparameters:\n- name: id\nin: path\ndescription: Post-ID\nrequired: true\nstyle: simple\nexplode: false\nschema:\ntype: string\nresponses:\n\"200\":\ndescription: Post mit entsprechender id gel\u00f6scht\ncontent:\napplication/json:\nschema:\ntype: array\nitems:\n$ref: '#/components/schemas/Post'\nx-content-type: application/json\n\"404\":\ndescription: Post bzw. id nicht gefunden\nx-swagger-router-controller: Posts\ncomponents:\nschemas:\nPost:\nrequired:\n- image_id\n- location\n- title\ntype: object\nproperties:\ntitle:\ntype: string\nexample: H-Geb\u00e4ude\nlocation:\ntype: string\nexample: Campus Wilhelminenhof\nimage_id:\ntype: string\nexample: Campus Wilhelminenhof\nexample:\nlocation: Campus Wilhelminenhof\ntitle: H-Geb\u00e4ude\nimage_id: Campus Wilhelminenhof\n</code></pre> <p></p> <p></p>"},{"location":"backend/#ein-nodejs-projekt-mit-express","title":"Ein Node.js-Projekt mit Express","text":"<p>Wir starten damit, uns ein <code>node.js</code>-Projekt zu erstellen. Dazu erstellen wir uns zun\u00e4chst einen Ordner <code>backend</code>, wechseln in diesen Ordner und f\u00fchren dann <code>npm init</code> aus:</p> <pre><code>mkdir backend\ncd backend\nnpm init\n</code></pre> <p>Sie werden ein paar Sachen gefragt. Im Prinzip k\u00f6nnen Sie immer <code>Enter</code> dr\u00fccken, au\u00dfer beim <code>entry point</code>. Dort k\u00f6nnen Sie gleich <code>server.js</code> eingeben. Sie k\u00f6nnen das aber auch noch sp\u00e4ter in der <code>package.json</code> \u00e4ndern.</p> <pre><code>This utility will walk you through creating a package.json file.\nIt only covers the most common items, and tries to guess sensible defaults.\n\nSee `npm help init` for definitive documentation on these fields\nand exactly what they do.\n\nUse `npm install &lt;pkg&gt;` afterwards to install a package and\nsave it as a dependency in the package.json file.\n\nPress ^C at any time to quit.\npackage name: (backend) \nversion: (1.0.0) \ndescription: Backend REST-API\nentry point: (index.js) server.js\ntest command: \ngit repository: \nkeywords: rest api backend mongodb\nauthor: J. Freiheit\nlicense: (ISC) \nAbout to write to /Users/jornfreiheit/Sites/IKT22/05_Backend/00_skript/backend/package.json:\n\n{\n\"name\": \"backend\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Backend REST-API\",\n  \"main\": \"server.js\",\n  \"scripts\": {\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n  \"keywords\": [\n\"rest\",\n    \"api\",\n    \"backend\",\n    \"mongodb\"\n],\n  \"author\": \"J. Freiheit\",\n  \"license\": \"ISC\"\n}\n\n\nIs this OK? (yes) </code></pre> <p>Die <code>package.json</code> wurde erstellt. Nun ben\u00f6tigen wir noch das Modul Express. Express bietet uns eine unkomplizierte Middleware f\u00fcr die Weiterverwaltung von <code>http</code>-Anfragen an die Datenbank und zur\u00fcck. </p> <pre><code>npm install express --save\n</code></pre> <p>Die Option <code>--save</code> muss eigentlich nicht mehr angegeben werden, aber unter Express steht es noch so. Sie erhalten eine Meldung in der Form:</p> <pre><code>% npm install express --save\n\nadded 57 packages, and audited 58 packages in 887ms\n\n7 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n</code></pre> <p>In der <code>package.json</code> wurde die entsprechende Abh\u00e4ngigkeit eingetragen: </p> package.json <pre><code>{\n\"name\": \"backend\",\n\"version\": \"1.0.0\",\n\"description\": \"Backend REST-API\",\n\"main\": \"server.js\",\n\"scripts\": {\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n\"keywords\": [\n\"rest\",\n\"api\",\n\"backend\",\n\"mongodb\"\n],\n\"author\": \"J. Freiheit\",\n\"license\": \"ISC\",\n\"dependencies\": {\n\"express\": \"^4.18.2\"\n}\n}\n</code></pre>"},{"location":"backend/#serverjs-erstellen-und-implementieren","title":"server.js erstellen und implementieren","text":"<p>\u00d6ffnen Sie nun das <code>backend</code>-Projekt in Ihrer IDE und erstellen Sie sich dort eine Datei <code>server.js</code> mit folgendem Inhalt:</p> server.js <pre><code>const express = require('express');\nconst postRoutes = require('./routes/post.routes');\n\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.json());\napp.use('/posts', postRoutes);\n\napp.listen(PORT, (error) =&gt; {\nif (error) {\nconsole.log(error);\n} else {\nconsole.log(`server running on http://localhost:${PORT}`);\n}\n});\n</code></pre> <p>Das bedeutet, wir importieren <code>express</code> (Zeile <code>1</code>), erzeugen uns davon ein Objekt und speichern dieses in der Variablen <code>app</code> (Zeile <code>4</code>). Wir legen in einer Konstanten <code>PORT</code> die Portnummer <code>3000</code> fest (Zeile <code>5</code> - die Portnummer k\u00f6nnen Sie w\u00e4hlen). Das <code>backend</code> ist somit unter <code>http://localhost:3000</code> verf\u00fcgbar. Das eigentliche Starten des Webservers erfolgt in den Zeilen <code>10-16</code> durch Aufruf der <code>listen()</code>-Funktion von <code>express</code>. Die Syntax der <code>listen()</code>-Funktion ist generell wie folgt:</p> <pre><code>app.listen([port[, host[, backlog]]][, callback])\n</code></pre> <p>Wir \u00fcbergeben als ersten Parameter die <code>PORT</code>-Nummer (<code>3000</code>) und als zweiten Parameter eine (anonyme) Funktion als sogenannten callback. Callbacks sind hier n\u00e4her erl\u00e4utert. Die anonyme Funktion wird durch die <code>listen()</code>-Funktion aufgerufen. Sollte ein Fehler aufgetreten sein (z.B. wenn der Port bereits belegt ist), wird der anonymen Funktion ein <code>error</code>-Objekt \u00fcbergeben. Ist das der Fall, wird der Fehler auf der Konsole ausgegeben. Wird der anonymen Funktion kein Objekt \u00fcbergeben, wurde der Webserver korrekt gestartet und die entsprechende Meldung erscheint auf der Konsole. </p> <p>Beachten Sie auch die verwendete Syntax <code>${PORT}</code> im sogenannte template literal. Beachten Sie, dass template literals nicht in einfachen (<code>'</code>) oder doppelten (<code>\"</code>) Anf\u00fchrungsstrichen stehen, sondern in <code>`</code> (backticks). </p>"},{"location":"backend/#router","title":"Router","text":"<p>Noch l\u00e4sst sich unser Programm aber nicht ausf\u00fchren. Wir ben\u00f6tigen im Projektordner noch einen Ordner <code>routes</code> und darin eine Datei <code>post.routes.js</code>. Diese wird n\u00e4mlich in der <code>server.js</code> bereits in Zeile <code>2</code> eingebunden und in Zeile <code>8</code> verwendet. </p> routes/post.routes.js <pre><code>const express = require('express');\nconst router = express.Router();\n\n// eine GET-Anfrage\nrouter.get('/', async(req, res) =&gt; {\n\nres.send({ message: \"Hello FIW!\" });\n});\n\nmodule.exports = router;\n</code></pre> <p>Beim <code>Router</code> handelt es sich um eine Middleware (siehe hier), die die Routen verwaltet und <code>request</code>-Objekte an die entsprechende Routen weiterleitet und <code>response</code>-Objekte empf\u00e4ngt. In unserer <code>post.routes.js</code> haben wir zun\u00e4chst eine <code>GET</code>-Anfrage implementiert (Zeile <code>5</code>). Das <code>request</code>-Objekt hei\u00dft hier <code>req</code>. Das verwenden wir aber gar nicht. Das <code>respones</code>-Objekt hei\u00dft hier <code>res</code> und wird durch die Anfrage erzeugt. Wir senden in der <code>response</code> ein JavaScript-Objekt zur\u00fcck, das einen Schl\u00fcssel <code>message</code> enth\u00e4lt. </p> <p>In der <code>server.js</code> haben wir mit <code>app.use(express.json())</code> (Zeile <code>7</code>) angegeben, dass alle JavaScript-Objekte in der <code>response</code> nach JSON umgewandelt werden sollen. Wenn nun die URL <code>localhost:3000</code> aufgerufen wird, dann wird ein <code>request</code> ausgel\u00f6st, den wir hier mit <code>Hello FIW!</code> als <code>response</code> beantworten (Zeilen <code>5-8</code>). </p> <p>Wichtig ist, dass wir <code>router</code> mit <code>module.exports</code> exportieren, damit es von anderen Modulen importiert und genutzt werden kann. Siehe dazu z.B. hier. Meine Empfehlung ist, (noch) nicht das neue ESM6-Format zu nutzen! </p> <p>Noch \"l\u00e4uft\" unser Backend aber noch nicht. Wir m\u00fcssen es erst starten. </p>"},{"location":"backend/#starten-des-projektes-und-installation-von-nodemon","title":"Starten des Projektes und Installation von nodemon","text":"<p>Das Projekt l\u00e4sst sich nun starten. Wir geben dazu im Terminal im <code>backend</code>-Ordner</p> <pre><code>node server.js\n</code></pre> <p>ein. Im Terminal erscheint </p> <pre><code>server running on http://localhost:3000 </code></pre> <p>und wenn Sie im Browser die URL <code>http://localhost:3000/</code> eingeben, wird dort</p> <p></p> <p>angezeigt. Sie k\u00f6nnen auch Postman \u00f6ffnen und <code>http://localhost:3000</code> eintragen (<code>GET</code>-Methode):</p> <p></p> <p>Wann immer wir jetzt jedoch etwas an der Implementierung \u00e4ndern, m\u00fcssen wir im Terminal zun\u00e4chst den Webserver mit </p> <pre><code>Strg-C      // bzw. Control-C\n</code></pre> <p>stoppen, um ihn dann wieder mit <code>node server.js</code> zu starten. Um das zu umgehen, gibt es das Paket nodemon. Da es nur sinnvoll w\u00e4hrend der Entwicklung eingesetzt werden kann (und sollte), installieren wir es als eine development dependency:</p> <pre><code>npm install --save-dev nodemon\n</code></pre> <p>Die <code>package.json</code> sieht daraufhin so aus:</p> package.json <pre><code>{\n\"name\": \"backend\",\n\"version\": \"1.0.0\",\n\"description\": \"Backend REST-API\",\n\"main\": \"server.js\",\n\"scripts\": {\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n\"keywords\": [\n\"rest\",\n\"api\",\n\"backend\",\n\"mongodb\"\n],\n\"author\": \"J. Freiheit\",\n\"license\": \"ISC\",\n\"dependencies\": {\n\"express\": \"^4.18.2\"\n},\n\"devDependencies\": {\n\"nodemon\": \"^2.0.22\"\n}\n}\n</code></pre> <p>Zur Verwendung von <code>nodemon</code> f\u00fcgen wir in die <code>package.json</code> unter <code>\"scripts\"</code> noch die Eigenschaft <code>watch</code> (frei gew\u00e4hlt) und den dazugeh\u00f6rigen Wert <code>nodemon server.js</code> ein:</p> package.json <pre><code>{\n\"name\": \"backend\",\n\"version\": \"1.0.0\",\n\"description\": \"Backend REST-API\",\n\"main\": \"server.js\",\n\"scripts\": {\n\"watch\": \"nodemon ./server.js\",\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n\"keywords\": [\n\"rest\",\n\"api\",\n\"backend\",\n\"mongodb\"\n],\n\"author\": \"J. Freiheit\",\n\"license\": \"ISC\",\n\"dependencies\": {\n\"express\": \"^4.18.2\"\n},\n\"devDependencies\": {\n\"nodemon\": \"^2.0.22\"\n}\n}\n</code></pre> <p>Nun l\u00e4sst sich die Anwendung mithilfe von <code>nodemon</code> per </p> <pre><code>npm run watch\n</code></pre> <p>starten und muss auch nicht mehr gestoppt und neu gestartet werden, wenn \u00c4nderungen an der Implementierungen durchgef\u00fchrt wurden. Die Ausgabe im Terminal nach Eingabe von <code>npm run watch</code> ist ungef\u00e4hr so:</p> <pre><code>&gt; backend@1.0.0 watch\n&gt; nodemon ./server.js\n\n[nodemon] 2.0.22\n[nodemon] to restart at any time, enter `rs`\n[nodemon] watching path(s): *.*\n[nodemon] watching extensions: js,mjs,json\n[nodemon] starting `node ./server.js`\nserver running on http://localhost:3000\n</code></pre> <p>Hier nur zum Verst\u00e4ndnis. Angenommen, wir \u00e4ndern bspw. in der <code>server.js</code> die Zeile <code>8</code> zu </p> <pre><code>app.use('/api', routes);\n</code></pre> <p>, dann w\u00fcrden alle Routen, die wir in <code>routes.js</code> definieren, unter <code>localhost:3000/api</code> verf\u00fcgbar sein. Wenn wir dann also z.B. in der <code>routes.js</code> die Zeile <code>5</code> zu </p> <pre><code>router.get('/fiw', async(req, res) =&gt; {\n</code></pre> <p>\u00e4ndern, dann ist der GET-Endpunkt <code>localhost:3000/api/fiw</code>. </p>"},{"location":"backend/#mongodb-installieren","title":"MongoDB installieren","text":"<p>MongoDB ist die am meisten verwendete NoSQL (not only SQL) Datenbank. Sie basiert nicht auf Relationen, Tabellen und ihren Beziehungen zueinander (ist also keine relationale Datenbank), sondern speichert Dokumente in JSON-\u00e4hnlichem Format. Die Community Edition der MongoDB ist Open Source und kostenlos verf\u00fcgbar. Wir verwenden hier jedoch eine Cloud-Instanz MongoDB Atlas. Um die Cloud-Version zu verwenden, m\u00fcssen Sie sich bei MongoDB registrieren und einloggen. W\u00e4hlen Sie dann einen kostenlosen Cluster. Diesen habe ich <code>IKT-PWA</code> genannt:</p> <p> </p> <p>Wenn Sie unter dieser Ansicht auf <code>Connect</code> klicken und dann <code>Drivers</code>, erscheint folgendes Fenster:</p> <p> </p> <p>Der dort unter 3. aufgef\u00fchrte <code>connection string</code> ist f\u00fcr Sie wichtig, um sich mit der datenbank auf MongoDB Atlas zu verbinden. Hier habe ich zur Authentifizierung ein X.509-Zertifikat verwendet. Wenn Sie stattdessen ein Passwort gew\u00e4hlt haben, m\u00fcssen Sie darin den String <code>&lt;password&gt;</code> durch Ihr Passwort ersetzen, um sich mit der MongoDB zu verbinden. Wenn Sie MongoDB lokal installiert haben, ist der <code>connection string</code> typischer Weise <code>mongodb+://localhost:27017</code>.</p>"},{"location":"backend/#mongodb-compass","title":"MongoDB Compass","text":"<p>Um sich Ihre MongoDB-Datenbanken anzuschauen, empfehle ich Ihnen das Tool MongoDB Compass. Download und Installation sind normalerweise einfach. Stellen Sie mithilfe des <code>connection strings</code> eine Verbindung zur MongoDB her (siehe z.B. hier). </p>"},{"location":"backend/#das-modul-mongodb-installieren","title":"Das Modul MongoDB installieren","text":"<p>Zur Verwendung von MongoDB im Backend verwenden wir als offiziellen MongoDB-Node-Treiber das Modul MongoDB. Wir installieren MongoDB mithilfe von</p> <pre><code>npm install mongodb\n</code></pre> <p>In die <code>package.json</code> wird das Paket und die entsprechende Abh\u00e4ngigkeit eingetragen:</p> package.json <pre><code>{\n\"name\": \"backend\",\n\"version\": \"1.0.0\",\n\"description\": \"Backend REST-API\",\n\"main\": \"server.js\",\n\"scripts\": {\n\"watch\": \"nodemon ./server.js\",\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n\"keywords\": [\n\"rest\",\n\"api\",\n\"backend\",\n\"mongodb\"\n],\n\"author\": \"J. Freiheit\",\n\"license\": \"ISC\",\n\"dependencies\": {\n\"express\": \"^4.18.2\",\n\"mongodb\": \"^5.5.0\"\n},\n\"devDependencies\": {\n\"nodemon\": \"^2.0.22\"\n}\n}\n</code></pre> <p>MongoDB stellt eine einfach zu verwendende Schnittstelle zwischen Node.js und MongoDB bereit. Bevor wir uns mit der MongoDB verbinden, erstellen wir zun\u00e4chst noch eine Datenbank. </p>"},{"location":"backend/#dotenv-fur-sichere-zugangsdaten","title":"Dotenv f\u00fcr sichere Zugangsdaten","text":"<p>F\u00fcr die \"geheimen\" Zugangsdaten (die jetzt noch gar nicht \"geheim\" sind) verwenden wir das dotenv-Paket:</p> <pre><code>npm install dotenv --save\n</code></pre> <p>Im Projektordner erstellen wir und eine Datei <code>.env</code> (mit vorangestelltem Punkt!) und weisen darin dem Schl\u00fcssel <code>DB_CONNECTION</code> eine Wert zu. Dieser Wert entspricht dem <code>connection string</code> zu Ihrer MongoDB. D.h. f\u00fcr den Fall, dass Sie eine lokale Installation von MongoDB Community Server haben, k\u00f6nnte er wie folgt lauten (dabei ist <code>htwinsta</code> bereits als Datenbankname angegeben!):</p> .env <pre><code>DB_CONNECTION = mongodb://127.0.0.1:27017/htwinsta\n</code></pre> <p>Beachten Sie, dass der Wert nicht in Hochkomma steht und dass auch kein Semikolon folgt! </p> <p>Da ich die Authentifizierung mittels X.509-Zertifikat gew\u00e4hlt habe, sieht bei mir die <code>.env</code>-Datei z.B. so aus:</p> .env <pre><code>DB_CONNECTION = mongodb+srv://ikt-pwa.0elr1ih.mongodb.net/?authSource=%24external&amp;authMechanism=MONGODB-X509&amp;retryWrites=true&amp;w=majority\nDB_NAME = htwinsta\nCOLLECTION = posts\nPATH_TO_PEM = ./assets/X509-cert-3298914405631471913.pem\n</code></pre> <p>Ich habe f\u00fcr den Namen der Datenbank ein eigenes Schl\u00fcssel-Wertepaar (<code>DB_NAME = htwinsta</code>) angelegt und meinen Schl\u00fcssel in den Ordner <code>assets</code> abgelegt, auf den ich dann mithilfe von <code>PATH_TO_PEM</code> zugreife. Au\u00dferdem habe ich auch eine <code>COLLECTION</code>definiert (<code>posts</code>), in die dann die Datens\u00e4tze geschrieben werden soll. Sie k\u00f6nnen sich darin z.B. auch den Port konfigurieren, auf dem Ihr Backend laufen soll. Beachten Sie, die <code>.env</code>-Datei in die <code>.gitignore</code> einzutragen. Die <code>.env</code>-Datei sollte nicht committed werden!</p>"},{"location":"backend/#dbjs-verbindung-zur-mongodb","title":"db.js - Verbindung zur MongoDB","text":"<p>Zur Verwaltung der Verbindung zur MongoDB erstellen wir ein Skript <code>db.js</code> im Ordner <code>configure</code>:</p> configure/db.js <pre><code>const { MongoClient } = require('mongodb');\nrequire('dotenv').config();\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst client = new MongoClient(process.env.DB_CONNECTION, {\nsslKey: credentials,\nsslCert: credentials\n});\n\nconst dbconnection = client.connect();\nconst database = client.db(process.env.DB_NAME);\nconst collection = database.collection(process.env.COLLECTION);\nconsole.log(`Connected to DB ... `);\n\nmodule.exports.client = client;\nmodule.exports.dbconnection = dbconnection;\nmodule.exports.database = database;\nmodule.exports.collection = collection;\n</code></pre> <p>Hier sind mehrere Dinge erw\u00e4hnenswert:</p> <ul> <li>Nach dem Aufruf der <code>config()</code>-Funktion von <code>dotenv</code> (siehe Zeile <code>2</code>) k\u00f6nnen wir mithilfe von <code>process.env.</code> auf die einzelnen Schl\u00fcssel bzw. deren Werte aus der <code>.env</code>-Datei zugreifen.</li> <li>Wenn Sie sich nicht mithilfe eines Zertifikates authentifizieren, dann entfallen alle Zeilen mit <code>credentials</code>.</li> <li>Wir exportieren gleich mehrere Objekte. Dann kann wahlweise eines oder mehrere dieser Objekte in Skripte eingebunden werden, in denen diese jeweils ben\u00f6tigt werden. </li> </ul>"},{"location":"backend/#crud-zugriffe-auf-die-datenbank","title":"CRUD-Zugriffe auf die Datenbank","text":"<p>Nun haben wir alles, was wir ben\u00f6tigen, um unsere Anfragen zu implementieren. Wir nutzen den <code>express.Router</code>, um die Routen zu definieren und k\u00f6nnen mithilfe des <code>db.js</code>-Skriptes auf MongoDB zugreifen. Wir werden nun sukzessive alle Anfragen in die <code>routes/post.routes.js</code> einf\u00fcgen. </p>"},{"location":"backend/#r-read-all","title":"R - read all","text":"<p>Wir beginnen mit der Anfrage, alle Daten aus der Datenbank auszulesen. F\u00fcr die MongoDB erfolgt dies mit der Funktion <code>find()</code>. In <code>post.routes.js</code> \u00e4ndern wir unsere <code>GET</code>-Anfrage wie folgt: </p> routes/post.routes.js <pre><code>const express = require('express');\nconst router = express.Router();\nconst { collection } = require('../configure/db')\n// GET all posts\nrouter.get('/', async(req, res) =&gt; {\nconst allPosts = await collection.find().toArray();\nres.status(200);\nres.send(allPosts);\n});\nmodule.exports = router;\n</code></pre> <p>Beachten Sie, dass wir dazu <code>collection</code> aus der <code>db.js</code> (Zeile <code>3</code>) verwenden. Diese gibt uns die Verbindung zur Collection <code>posts</code>. Die Route wird mit <code>localhost:3000/posts</code> definiert (siehe <code>server.js</code>). Die anonyme Callback-Funktion enth\u00e4lt noch zwei Schl\u00fcsselw\u00f6rter: <code>async</code> und <code>await</code>. Die Funktion <code>find()</code> ist ein Promise (siehe dazu hier). Die Funktion <code>find()</code> wird asynchron ausgef\u00fchrt und \"irgendwann\" ist entweder das Ergebnis dieser Funktion verf\u00fcgbar oder die Funktion gibt einen Fehler zur\u00fcck. Auf eines der beiden wird gewartet (<code>await</code>). Nur eine als <code>async</code> deklarierte Funktion darf einen <code>await</code>-Aufruf enthalten (siehe dazu z.B. hier).</p> <p>neben dem Array aller Eintr\u00e4ge in der <code>posts</code>-Collection (Zeile <code>9</code>) wird auch der HTTP-Statuscode <code>200</code> zur\u00fcckgesendet (Zeile <code>8</code>). Wenn Sie nun in Postman <code>GET http://localhost:3000/posts</code> aufrufen, erscheinen alle Eintr\u00e4ge aus der Datenbank. Allerdings haben wir dort noch keine Eintr\u00e4ge. Wir bekommen deshalb ein leeres Array <code>[]</code> zur\u00fcck.</p>"},{"location":"backend/#c-create","title":"C - create","text":"<p>Als n\u00e4chstes implementieren wir einen Endpunkt, an dem wir einen neuen Datensatz in die Datenbank anlegen k\u00f6nnen. Daf\u00fcr gibt es die http-Methode <code>POST</code>. Wir f\u00fchren also nicht mehr eine <code>GET</code>-, sondern eine <code>POST</code>-Anfrage durch. Bei dieser <code>POST</code>-Anfrage wird der neue Datensatz an den Webserver mitgeschickt. Dies erfolgt im <code>body</code> des <code>request</code>-Objektes. Das Schreiben des Datensatzes in die Datenbank erfolgt mithilfe der <code>save()</code>-Funktion von MongoDB. </p> routes/post.routes.js <pre><code>// POST one new post\nrouter.post('/', async(req, res) =&gt; {\n\ntry {\nconst newPost = {\ntitle: req.body.title,\nlocation: req.body.location,\nimage_id: req.body.image_id }\nconst result = await collection.insertOne(newPost);\nres.status(201);\nres.send(result);\n} catch {\nres.status(404);\nres.send({\nerror: \"Post does not exist!\"\n});\n}\n});\n</code></pre> <p>In den Zeilen <code>17-19</code> werden die Daten aus dem <code>body</code> des <code>request</code>-Objektes ausgelesen und mit diesen Daten ein neues <code>Post</code>-Objekt erzeugt. Dieses neue <code>Post</code>-Objekt (<code>newPost</code>) wird in Zeile <code>21</code> in die Datenbank gespeichert und in Zeile <code>23</code> als <code>response</code> zusammen mit der Statusmeldung <code>201</code> (<code>created</code>) zur\u00fcckgeschickt.  </p> <p>Nun geben wir in Postman <code>POST http://localhost:3000/posts</code> ein und bef\u00fcllen den <code>Body</code> z.B. mit:</p> <pre><code>{ \"title\": \"H-Geb\u00e4ude\",\n\"location\": \"Campus Wilhelminenhof\",\n\"image_id\": \"test\" }\n</code></pre> <p>Achten Sie darauf, dass in der zweiten Men\u00fczeile rechts <code>JSON</code> ausgew\u00e4hlt ist (im Bild blau) - nicht <code>Text</code>. Wir klicken auf <code>Send</code> und es erscheint:</p> <p></p> <p>Schauen Sie auch in MongoDB Compass nach, ob der Datensatz dort erscheint:</p> <p></p>"},{"location":"backend/#r-read-one","title":"R - read one","text":"<p>Wir erweitern die <code>post.routes.js</code> um einen Endpunkt, der uns f\u00fcr eine gegebene <code>id</code> den entsprechenden Datensatz zur\u00fcckliefert. Die <code>_id</code> werden von MongoDB automatisch vergeben und sind recht kryptisch, also z.B. <code>\"6475ba5e88a1b91688569dda\"</code> (siehe oben). Wir k\u00f6nnen nat\u00fcrlich nach jedem beliebigen Wert f\u00fcr jeden Schl\u00fcssel in der Datenbank suchen. Wir nehmen hier beispielhaft die <code>_id</code>, da die Suche nach einer <code>_id</code> ein klein wenig komplexer ist, weil es sich dabei um eine <code>ObjectId</code> handelt (im Gegensatz zu z.B. <code>location</code> oder <code>image_id</code>, welche reine Strings sind). </p> <p>Die <code>id</code> wird aus der URL des Endpunktes ausgelesen, d.h. wenn wir bspw. den Endpunkt <code>GET http://localhost:3000/posts/6475ba5e88a1b91688569dda</code> eingeben, dann soll der Datensatz mit der <code>_id: 6475ba5e88a1b91688569dda</code> im JSON-Format zur\u00fcckgegeben werden. Wir nutzen dazu parametrisierte Routen und lesen die <code>id</code> aus der Parameterliste aus. Paremtrisierte Routen werden per <code>:</code> und dann den Namen des Parameters (hier <code>id</code>) erstellt. Um dann den Wert des Parametrs <code>id</code> aus der Parameterliste auszulesen, wird <code>params</code> verwendet. </p> <p>Da es sich bei der <code>_id</code> um eine <code>ObjectId</code> handelt (siehe oberes Bild von Compass), m\u00fcssen wir diesen Typ zun\u00e4chst aus dem <code>mongodb</code>-Package importieren:</p> routes/post.routes.js <pre><code>  const  ObjectId = require('mongodb').ObjectId\n</code></pre> <p>Wir nutzen die gleichnamige Variable <code>ObjectId</code>. Nun k\u00f6nnen wir mithilfe von <code>req.params</code> die <code>id</code> auslesen, die der Endpunkt-URL angeh\u00e4ngt wird (siehe <code>'/:id'</code> in Zeile <code>34</code>):</p> routes/post.routes.js <pre><code>// GET one post by id\nrouter.get('/:id', async(req, res) =&gt; {\n\ntry {\nconst id_obj = new ObjectId(req.params.id);\nconst post = await collection.find( {_id: id_obj } ).toArray();\nconsole.log('post', req.params.id)\nres.status(202);\nres.send(post);\n} catch {\nres.status(404);\nres.send({\nerror: \"Post does not exist!\"\n});\n}\n});\n</code></pre> <p>Wir erzeugen mithilfe der <code>id</code> ein neues <code>ObjectId</code>-Objekt (Zeile <code>37</code>). Zum Finden der passenden Datens\u00e4tze wird in MongoDB die Funktion <code>find()</code> verwendet (siehe hier). Wird der Datensatz gefunden, d.h. existiert die entsprechende <code>_id</code>, dann wird dieser in der <code>response</code> zur\u00fcckgesendet (Zeile <code>41</code>). Existiert er nicht, wird der HTTP-Statuscode <code>404</code> gesendet (Zeile <code>43</code>) und ein JSON mit der <code>error</code>-Nachricht <code>Post does not exist!</code> (Zeilen <code>44-46</code>). </p> <p>Nun geben wir in Postman z.B. <code>GET http://localhost:3000/posts/6475ba5e88a1b91688569dda</code> ein (bei Ihnen sind die <code>_id</code>-Werte andere!) und erhalten:</p> <p></p> <p>Probieren Sie auch einmal <code>GET http://localhost:3000/posts/0</code> aus, um die Fehlermeldung als JSON zu sehen. </p> <p></p>"},{"location":"backend/#u-update","title":"U - update","text":"<p>Um einen bereits existierenden Datensatz zu \u00e4ndern, kann entweder die HTTP-Anfrage <code>PUT</code> oder <code>PATCH</code> verwendet werden. Zur Unterscheidung zwischen <code>PUT</code> und <code>PATCH</code> siehe z.B. hier oder hier. Um einen Datensatz in der MongoDB zu \u00e4ndern, stehen prinzipiell mehrere Funktionen zur Verf\u00fcging:</p> <ul> <li><code>updateOne()</code>: \u00e4ndert einzelne (oder alle) Teile eines Datensatzes und sendet die <code>_id</code> zur\u00fcck, falls ein neur Datensatz angelegt wurde,</li> <li><code>findOneAndUpdate()</code>: \u00e4ndert einzelne (oder alle) Teile eines Datensatzes und sendet den kompletten Datensatz zur\u00fcck,</li> <li><code>replaceOne()</code>: \u00e4ndert den kompletten Datensatz. </li> </ul> <p>In der folgenden Implementierung haben wir uns f\u00fcr die HTTP-Anfragemethode <code>PATCH</code> und f\u00fcr die MongoDB-Funktion <code>updateOne()</code> entschieden. Diese Funktion erwartet als ersten Parameter einen <code>&lt;filter&gt;</code>, d.h. die Werte, nach denen nach einem Datensatz gesucht werden soll. Im folgenden Beispiel ist der Filter die <code>_id</code>. Dazu wird erneute ein Parameter <code>id</code> f\u00fcr die URL definiert. Der zweite Parameter der <code>updateOne()</code>-Funktion sind die zu \u00e4ndernden Werte f\u00fcr diesen Datensatz. Die zu \u00e4ndernden Werte werden mithilfe von <code>$set :</code> zur \u00c4nderung angegeben 8siehe Zeile <code>68</code>). In der folgenden Implementierung werden diese zu \u00e4ndernden Werte als ein JSON dem <code>body</code> des <code>request</code>-Objektes \u00fcbergeben. Um zu erm\u00f6glichen, dass ein, zwei oder drei Schl\u00fcssel-Werte-Paare in diesem JSON enthalten sein k\u00f6nnen, pr\u00fcfen wir die Eintr\u00e4ge im <code>body</code> und setzen daraus ein neues <code>post</code>-Objekt zusammen, wenn es bereits in der Datenbank existiert (deshalb zun\u00e4chst <code>findOne()</code>):</p> routes/post.routes.js <p>```javascript linenums=\"50\"</p> <p>// PATCH (update) one post router.patch('/:id', async(req, res) =&gt; {   try {         const id_obj = new ObjectId(req.params.id);       const post = await collection.findOne({ _id: id_obj })</p> <pre><code>  if (req.body.title) {\n      post.title = req.body.title\n  }\n\n  if (req.body.location) {\n      post.location = req.body.location\n  }\n\n  if (req.body.image_id) {\n      post.image_id = req.body.image_id\n  }\n\n  await collection.updateOne({ _id: id_obj }, { $set: post });\n  res.send(post)\n</code></pre> <p>} catch {       res.status(404)       res.send({ error: \"Post does not exist!\" })   }</p> <p>});     ```</p> <p>Wir k\u00f6nnen diese Funktion in Postman ausprobieren, indem wir im <code>body</code> z.B. das JSON </p> <pre><code>{ \"image_id\": \"test_neu\" }\n</code></pre> <p>mit unserem Request \u00fcbergeben und <code>PATCH http://localhost:3000/posts/6475ba5e88a1b91688569dda</code> w\u00e4hlen (bei Ihnen eine andere <code>id</code>!). Der Datensatz mit der <code>_id=6475ba5e88a1b91688569dda</code> wird dann aktualisiert. </p> <p></p> <p>Schauen Sie auch in der Datenbank nach (z.B. in MongoDB Compass) und w\u00e4hlen auch ruhig nochmal <code>GET http://localhost:3000/posts</code> (z.B. in Postman).</p>"},{"location":"backend/#d-delete-one","title":"D - delete one","text":"<p>Jetzt implementieren wir noch den Endpunkt, um einen Datensatz zu l\u00f6schen. Dazu werden die HTTP-Anfragemethode <code>DELETE</code> und die MongoDB-Funktion <code>deleteOne()</code> verwendet. Im folgenden Beispiel wird der Datensatz erneut \u00fcber die <code>_id</code> ermittelt und daf\u00fcr erneut die parametrisierte URL ausgelesen:</p> routes/post.routes.js <pre><code>// DELETE one post via id\nrouter.delete('/:id', async(req, res) =&gt; {\ntry {\nconst id_obj = new ObjectId(req.params.id);\nconst post = await collection.deleteOne({ _id: id_obj })\nconsole.log('post', post)\nif(post.deletedCount === 1) {\nres.status(204)\nres.send( { message: \"deleted\" })\n} else {\nres.status(404)\nres.send({ error: \"Post does not exist!\" })\n}\n} catch {\nres.status(404)\nres.send({ error: \"something wrong\" })\n}\n});\n</code></pre> <p>Die R\u00fcckgabe der <code>deleteOne()</code>-Funktion enth\u00e4lt die Eigenschaft <code>deletedCount</code>, die die Anzahl der gel\u00f6schten Datens\u00e4tze enth\u00e4lt. Wir verwenden diese (Zeile <code>82</code>), um zu ermitteln, ob ein oder kein Datensatz gel\u00f6scht wurde. je nachden, wird der Statuscode <code>204</code> oder <code>404</code> zur\u00fcckgegeben. Wenn wir nun in Postman z.B. <code>DELETE http://localhost:3000/members/6475ba5e88a1b91688569dda</code> w\u00e4hlen (bei Ihnen eine andere <code>id</code>!), wird der Datensatz mit der <code>_id=6475ba5e88a1b91688569dda</code> aus der Datenbank gel\u00f6scht. </p> <p>Hier nochmal die vollst\u00e4ndige <code>routes/post.routes.js</code>:</p> routes/post.routes.js <pre><code>const express = require('express');\nconst router = express.Router();\nconst { collection } = require('../configure/db')\nconst  ObjectId = require('mongodb').ObjectId\n\n// GET all posts\nrouter.get('/', async(req, res) =&gt; {\nconst allPosts = await collection.find().toArray();\nres.status(200);\nres.send(allPosts);\n});\n\n// POST one new post\nrouter.post('/', async(req, res) =&gt; {\n\ntry {\nconst newPost = {\ntitle: req.body.title,\nlocation: req.body.location,\nimage_id: req.body.image_id }\nconst result = await collection.insertOne(newPost);\nres.status(201);\nres.send(result);\n} catch {\nres.status(404);\nres.send({\nerror: \"Post does not exist!\"\n});\n}\n});\n\n// GET one post by id\nrouter.get('/:id', async(req, res) =&gt; {\n\ntry {\nconst id_obj = new ObjectId(req.params.id);\nconst post = await collection.find( {_id: id_obj } ).toArray();\nconsole.log('post', req.params.id)\nres.status(202);\nres.send(post);\n} catch {\nres.status(404);\nres.send({\nerror: \"Post does not exist!\"\n});\n}\n});\n\n// PATCH (update) one post\nrouter.patch('/:id', async(req, res) =&gt; {\ntry {\nconst id_obj = new ObjectId(req.params.id);\nconst post = await collection.findOne({ _id: id_obj })\n\nif (req.body.title) {\npost.title = req.body.title\n}\n\nif (req.body.location) {\npost.location = req.body.location\n}\n\nif (req.body.image_id) {\npost.image_id = req.body.image_id\n}\n\nawait collection.updateOne({ _id: id_obj }, { $set: post });\nres.send(post)\n} catch {\nres.status(404)\nres.send({ error: \"Post does not exist!\" })\n}\n});\n\n// DELETE one post via id\nrouter.delete('/:id', async(req, res) =&gt; {\ntry {\nconst id_obj = new ObjectId(req.params.id);\nconst post = await collection.deleteOne({ _id: id_obj })\nconsole.log('post', post)\nif(post.deletedCount === 1) {\nres.status(204)\nres.send( { message: \"deleted\" })\n} else {\nres.status(404)\nres.send({ error: \"Post does not exist!\" })\n}\n} catch {\nres.status(404)\nres.send({ error: \"something wrong\" })\n}\n});\n\nmodule.exports = router;\n</code></pre>"},{"location":"backend/#cross-origin-resource-sharing-cors","title":"Cross-Origin Resource Sharing (CORS)","text":"<p>Die Same Origin Policy (SOP) ist ein Sicherheitskonzept, das clientseitig Skriptsprachen (also z.B. JavaScript oder CSS) untersagt, Ressourcen aus verschiedenen Herkunften zu verwenden, also von verschiedenen Servern. Dadurch soll verhindert werden, dass fremde Skripte in die bestehende Client-Server-Kommunikation eingeschleust werden. Gleiche Herkunft (origin) bedeutet, dass das gleiche Protokoll (z.B. <code>http</code> oder <code>https</code>), von der gleichen Domain (z.B. <code>localhost</code> oder <code>htw-berlin</code>) sowie dem gleichen Port (z.B. <code>80</code> oder <code>4200</code>) verwendet werden. Es m\u00fcssen alle drei Eigenschaften \u00fcbereinstimmen. </p> <p>Mit dem Aufkommen von Single Page Applications und dem darin ben\u00f6tigten AJAX kam jedoch der Bedarf auf, die SOP aufzuweichen. Es sollte m\u00f6glich sein, dass z.B. JavaScript sowohl client-seitig das DOM \u00e4ndert als auch einen Request an den Server (das Backend) sendet. Der Kompromiss, der daf\u00fcr gefunden wurde, nennt sich Cross-Origin Resource Sharing (CORS). Damit ist es m\u00f6glich, f\u00fcr einige oder alle Anfragen zu definieren, dass sie im Sinne der SOP trotzdem erlaub sein sollen. </p> <p>Um CORS f\u00fcr Ihr Backend zu aktivieren, wechseln Sie im Terminal in Ihren <code>backend</code>-Ordner und geben dort</p> <pre><code>npm install cors\n</code></pre> <p>ein. \u00d6ffnen Sie dann die <code>server.js</code> und f\u00fcgen Sie die hervorgehobenen Zeilen ein:</p> server.js <pre><code>const express = require('express');\nconst postRoutes = require('./routes/post.routes');\nconst cors = require('cors')\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.json());\n// enable cors for all requests\napp.use(cors());\napp.use('/posts', postRoutes);\n\napp.listen(PORT, (error) =&gt; {\nif (error) {\nconsole.log(error);\n} else {\nconsole.log(`server running on http://localhost:${PORT}`);\n}\n});\n</code></pre> <p>Wenn Sie z.B. nur die <code>get</code>-Anfrage teilen wollen, dann w\u00e4hlen Sie nicht <code>app.use(cors());</code>, sondern </p> <pre><code>app.get(\"/\", cors(), (req, res) =&gt; {\nres.json({ message: \"Hello FIW!\" });\n});\n</code></pre> <p>Mehr zum CORS-Paket von node.js bzw. express finden Sie hier.</p> <p>Success<p>Das bis hier erstellte Backend ist unter https://github.com/jfreiheit/IKT-PWA-Backend.git verf\u00fcgbar. </p> </p>"},{"location":"backgroundsync/","title":"Hintergrundsynchronisation","text":"<p>Hint</p> <p>Aktueller Stand vor Hintergrundsynchronisation:</p> <ul> <li>Frontend</li> <li>Backend</li> <li>Collection post</li> <li>Collection post.files</li> <li>Collection post.chunks</li> </ul> <p>Hintergrundsynchronisation erlaubt die Synchronisation von Daten, selbst dann, wenn die Anwendung offline ist. Diese \"Synchronisation\" erfolgt nat\u00fcrlich \"asynchron\". Angenommen, Sie geben offline Daten in die Anwendung ein und wollen diese versenden, z.B. an das Backend, dann wird dieser Request so lange in Ihrer Anwendung gespeichert, bis Sie wieder online sind und erst dann ausgef\u00fchrt. </p> <p>Das Situation ist die Folgende:</p> <p></p> <p>Es sollen Daten an das Backend gesendet werden, aber die Internetverbindung ist unterbrochen. Deshalb werden die Daten in die IndexedDB gespeichert und im Service Worker wird eine Sync Task registriert. </p> <p></p> <p>Sobald die Verbindung wieder steht, wird ein Sync-Event im Service Worker ausgel\u00f6st und dieser sendet die Daten an das Backend (<code>POST-Request</code>).</p> <p>Dadurch, dass der Service Worker diesen <code>POST-Request</code> ausf\u00fchrt (und die Daten dabei mitsendet), kann die Hintergrundsynchronisation sogar dann stattfinden, wenn die Webanwendung bereits geschlossen ist! Deshalb sollten wir einfach immer beim Senden von Daten eine Sync Task registrieren, weil es sein kann, dass die Daten noch gar nicht vollst\u00e4ndig gesendet wurden, bevor wir den Browsertab schlie\u00dfen. </p>"},{"location":"backgroundsync/#aktueller-stand-daten-senden","title":"Aktueller Stand Daten senden","text":"<p>Wir schauen uns zun\u00e4chst nochmal an, wie wir derzeit die Daten, die wir \u00fcber das Eingabeformular eingeben, speichern. Wenn wir den <code>Speichern</code>-Button dr\u00fccken, wird das <code>Submit</code>-Ereignis des Formulars ausgel\u00f6st. Dies behandeln wir wie folgt:</p> /src/js/feed.js <pre><code>form.addEventListener('submit', event =&gt; {\nevent.preventDefault(); // nicht absenden und neu laden\n\nif (file == null) {\nalert('Erst Foto aufnehmen!')\nreturn;\n}\nif (titleInput.value.trim() === '' || locationInput.value.trim() === '') {\nalert('Bitte Titel und Location angeben!')\nreturn;\n}\n\ncloseCreatePostModal();\n\ntitleValue = titleInput.value;\nlocationValue = locationInput.value;\nconsole.log('titleInput', titleValue)\nconsole.log('locationInput', locationValue)\nconsole.log('file', file)\n\nsendDataToBackend();\n});\n</code></pre> <p>Wir verhindern zun\u00e4chst das Standardverhalten beim <code>submit</code>-Ereignis, n\u00e4mlich das Absenden der Daten und das Neuladen der Seite (Zeile <code>240</code>). In Zeile <code>242</code> pr\u00fcfen wir, ob die <code>file</code>-variable belegt ist, d.h. ob wir bereits ein Foto aufgenommen haben und in Zeile <code>246</code> pr\u00fcfen wir, ob beide <code>input</code>-Elemente, also sowohl f\u00fcr <code>title</code>, als auch f\u00fcr <code>location</code> einen Wert enthalten. Die JavaScript-<code>trim()</code>-Funktionen entfernt \"Leerzeichen\" aller Art am Ende des Strings (auch Tabs, Zeilenumbr\u00fcche etc.). Sollte eines der beiden (oder beide) Eingabefelder leer sein, beenden wir die Funktion mit einem <code>alert</code> und bleiben in dem Formular. <code>alert</code> ist nat\u00fcrlich nicht so toll, ein <code>toast</code> w\u00e4re viel besser, aber wir haben in unserer <code>index.html</code> nur einen <code>toast</code> f\u00fcr das erfolgreiche Speichern vordefiniert. Wenn beide Eingabefelder bef\u00fcllt und ein Foto (in <code>file</code>) gespeichert sind, schlie\u00dfen wir das Formulatfenster (Zeile <code>251</code>) und senden die Daten an das Backend (Zeile <code>259</code>). Die <code>sendDataToBackend()</code>-Funktion sieht wie folgt aus:</p> /src/js/feed.js <pre><code>function sendDataToBackend() {\nconst formData = new FormData();\nformData.append('title', titleValue);\nformData.append('location', locationValue);\nformData.append('file', file);\n\nconsole.log('formData', formData)\n\nfetch('http://localhost:3000/posts', {\nmethod: 'POST',\nbody: formData\n})\n.then( response =&gt; {\nconsole.log('Data sent to backend ...', response);\nreturn response.json();\n})\n.then( data =&gt; {\nconsole.log('data ...', data);\nconst newPost = {\ntitle: data.title,\nlocation: data.location,\nimage_id: imageURI\n}\nupdateUI([newPost]);\n});\n}\n</code></pre> <p>Es wird ein <code>FormData</code>-Objekt erstellt, da wir im <code>body</code> nicht nur Textfelder, sondern auch ein <code>file</code>-Objekt mitschicken. Mit der <code>POST</code>-Methode an das Backend wird dieses bef\u00fcllte <code>FormData</code>-Objekt gesendet. Da dieses Objekt in der <code>file</code>-Eigenschaft aber ein <code>File</code>-Objekt enth\u00e4lt, die <code>updateUI()</code>-Funktion an dem Schl\u00fcssel <code>image_id</code> aber den <code>base64</code>-String des Bildes erwartet, \u00fcbergeben wir dieser Funktion ein modifiziertes <code>Post</code>-Objekt. </p> <p>Schauen wir uns auch nochmal die IndexedDB an:</p> <p></p> <p>Wir sehen, dass in dem Store <code>posts</code> der IndexedDB die Datens\u00e4tze mit ihrer <code>_id</code> und in <code>image_id</code> mit ihrem <code>base64</code>-String gespeichert sind. Die <code>_id</code> erh\u00e4lt der Datensatz aber erst durch die MongoDB, wo der Wert f\u00fcr <code>_id</code> automatisch erzeugt wird. Angenommen, wir wollen diese Daten nun zun\u00e4chst in der IndexedDB zwischenspeichern und erst, wenn die Verbindung zum Backend besteht, an das Backend weiterleiten, ben\u00f6tigen wir in der IndexedDB einen anderen Store, der anders aufgebaut ist, als der <code>posts</code>-Store. Bevor wir uns darum k\u00fcmmern, erweiteren wir die <code>Submit</code>-Behandlung jedoch erst um die Registrierung an die Sync Task. </p>"},{"location":"backgroundsync/#sync-task-registrieren","title":"Sync Task registrieren","text":"<p>Wenn wir das Formular absenden und die in dem Formular eingegebenen Daten speichern wollen, steuern wir dies nun \u00fcber eine Sync Task. Diese Sync Task sorgt daf\u00fcr, dass die Daten (irgendwann) tats\u00e4chlich gespeichert werden, auch wenn wir gerade offline sind oder w\u00e4hrend des Speicherns offline geschaltet werden. F\u00fcr eine solche Sync Task existiert die SyncManager-API. Wenn Sie auf diesen Link klicken, dann sehen Sie, dass die <code>SyncManager-API</code></p> <ol> <li>nur 2 Methoden besitzt, n\u00e4mlich <code>register()</code> und <code>getTags()</code> und </li> <li>dass sie bis jetzt leider nur von Chrome und Edge unterst\u00fctzt wird. Allerdings auch in allen Android-Ger\u00e4ten (mit Chrome oder WebView) und somit trotzdem eine gro\u00dfe Reichweite besitzt. </li> </ol> <p>Wir erweitern die Anmeldung an den Listener f\u00fcr das <code>submit</code>-Event zun\u00e4chst wie folgt:</p> /src/js/feed.js <pre><code>form.addEventListener('submit', event =&gt; {\nevent.preventDefault(); // nicht absenden und neu laden\n\nif (file == null) {\nalert('Erst Foto aufnehmen!')\nreturn;\n}\nif (titleInput.value.trim() === '' || locationInput.value.trim() === '') {\nalert('Bitte Titel und Location angeben!')\nreturn;\n}\n\ncloseCreatePostModal();\n\ntitleValue = titleInput.value;\nlocationValue = locationInput.value;\nconsole.log('titleInput', titleValue)\nconsole.log('locationInput', locationValue)\nconsole.log('file', file)\n\nif('serviceWorker' in navigator &amp;&amp; 'SyncManager' in window) {\nnavigator.serviceWorker.ready\n.then( sw =&gt; {\nsw.sync.register('sync-new-post');\n});\n}\nsendDataToBackend();\n});\n</code></pre> <p>In diesem kleinen Code-St\u00fcckchen sind einige Dinge beachtenswert. Erstens, wird die <code>SyncManager-API</code> vom Service Worker verwendet, aber wir sind hier ja in <code>feed.js</code>, also in der Webanwendung. Wir k\u00f6nnen die Registrierung an die Sync Task nicht einfach in die <code>sw.js</code> schreiben, da das ausl\u00f6sende Ereignis der Registrierung (n\u00e4mlich das Absenden des Formulars) in der Webanwendung stattfindet und wir dieses Ereignis in <code>feed.js</code> behandeln. Wir ben\u00f6tigen in <code>feed.js</code> also einen Zugriff auf den Service Worker. </p> <p>Dazu fragen wir zun\u00e4chst, ob der Service Worker \u00fcberhaupt durch den Browser unterst\u00fctzt wird und auch, ob die <code>SyncManager-API</code> durch den Browser unterst\u00fctzt wird. Dies geschieht in Zeile <code>260</code>. Dort f\u00e4llt auf, dass der Service Worker eine Eigenschaft von <code>navigator</code> ist, die <code>SyncManager-API</code> eine Eigenschaft von <code>window</code>. Window ist das Fenster, das ein DOM Dokument (also eine Webanwendung) enth\u00e4lt. Eine Eigenschaft von <code>window</code> ist <code>navigator</code> (also <code>window.navigator</code>). Das Navigator-Objekt liefert Informationen \u00fcber den Browser, in dem die Anwendung ausgef\u00fchrt wird. </p> <p>Die (<code>readonly</code>)-Eigenschaft <code>ready</code> eines Service Workers ist eine Promise, welche <code>resolved</code> ist, sobald der Service Worker <code>active</code> ist. Siehe hier f\u00fcr <code>ready</code>. \u00dcber diese Promise erlangen wir Zugriff auf den Service Worker in unserer Webanwendung. Die sync-Eigenschaft ist in dem Interface ServiceWorkerRegistration definiert. Die <code>register()</code>-Funktion ist eine der beiden Methoden aus der <code>SyncManager-API</code> und registriert eine Sync Task. Jeder Sync Task wird ein <code>tag</code> zugewiesen (\u00e4hnlich einer <code>id</code>). \u00dcber diesen <code>tag</code> kann sp\u00e4ter auf diese Sync Task zugegriffen werden. Wir haben dieser Sync Task den <code>tag</code> <code>'sync-new-post'</code> gegeben. </p> <p>Die Sync Task ist nun registriert. Allerdings wei\u00df der Service Worker noch gar nicht, was er bei dieser Sync Task \u00fcberhaupt synchronisieren soll. Das definieren wir jetzt.</p>"},{"location":"backgroundsync/#daten-in-die-indexeddb-speichern","title":"Daten in die IndexedDB speichern","text":"<p>Die Daten, die (sp\u00e4ter) synchronisert werden sollen, werden zun\u00e4chst in der IndexedDB gespeichert. Dort k\u00f6nnen Sie so lange bleiben, bis die Webanwendung (wieder) online ist, um dann an das Backend durch den Service Worker gesendet zu werden. Dazu erzeugen wir uns ein passendes JavaScript-Objekt <code>post</code>:</p> /src/js/feed.js <pre><code>form.addEventListener('submit', event =&gt; {\nevent.preventDefault(); // nicht absenden und neu laden\n\nif (file == null) {\nalert('Erst Foto aufnehmen!')\nreturn;\n}\nif (titleInput.value.trim() === '' || locationInput.value.trim() === '') {\nalert('Bitte Titel und Location angeben!')\nreturn;\n}\n\ncloseCreatePostModal();\n\ntitleValue = titleInput.value;\nlocationValue = locationInput.value;\n\nif('serviceWorker' in navigator &amp;&amp; 'SyncManager' in window) {\nnavigator.serviceWorker.ready\n.then( sw =&gt; {\nlet post = {\nid: new Date().toISOString(),\ntitle: titleValue,\nlocation: locationValue,\nimage_id: file      // file durch den Foto-Button belegt\n};\nsw.sync.register('sync-new-post');\n});\n}\n});\n</code></pre> <p>Die <code>id</code> wurde hinzugef\u00fcgt, um einen eindeutigen Identifier f\u00fcr den <code>post</code> in der IndexedDB zu haben (<code>keyPath</code>). Damit der Wert auch eindeutig ist, wird der Zeitstempel zum String umgewandelt und verwendet (Zeile <code>260</code>). </p> <p>Diesen <code>post</code> wollen wir nun in die IndexedDB speichern. Dazu steht uns aus der <code>db.js</code> die Funktion <code>writeData()</code> zur Verf\u00fcgung. Diese Funktion erwartet als ersten Parameter den <code>Store</code>, in dem wir den <code>post</code> speichern wollen. Derzeit haben wir einen <code>Store</code> in unserer IndexedDB definiert, den <code>Store</code> <code>posts</code>:</p> /src/js/db.js <pre><code>const db = idb.openDB('posts-store', 1, {\nupgrade(db) {\n// Create a store of objects\nconst store1 = db.createObjectStore('posts', {\n// The '_id' property of the object will be the key.\nkeyPath: '_id',\n// If it isn't explicitly set, create a value by auto incrementing.\nautoIncrement: true,\n});\n// Create an index on the '_id' property of the objects.\nstore1.createIndex('_id', '_id');\n},\n});\n</code></pre> <p>Diesen <code>Store</code> (urspr\u00fcnglich hie\u00df die Variable noch <code>store</code>, wir haben hier bereits <code>store1</code> daraus gemacht, k\u00f6nnte aber auch <code>store</code> bleiben) verwenden wir aber, um unsere Daten aus der Datenbank/dem Backend zu cachen. Wir verwenden ihn zum Schreiben und Lesen der Daten aus unserer Datenbank. F\u00fcr das Synchroniseren der neuen Daten ben\u00f6tigen wir deshalb einen weiteren <code>Store</code>. Dazu kopieren wir einfach die <code>Store</code>-Erstellung in der <code>db.js</code> und nennen den neuhinzugekommen <code>Store</code> <code>sync-posts</code> (wir nennen die <code>id</code> hier auch <code>id</code> und nicht <code>_id</code>):</p> /src/js/db.js <pre><code>const db = idb.openDB('posts-store', 1, {\nupgrade(db) {\n// Create a store of objects\nconst store1 = db.createObjectStore('posts', {\nkeyPath: '_id',\n});\nstore1.createIndex('_id', '_id');\n\n// Create another store of objects\nconst store2 = db.createObjectStore('sync-posts', {\nkeyPath: 'id',\n});\nstore2.createIndex('id', 'id');\n},\n});\n</code></pre> <p>Gleichzeitig habe ich auch noch ein bisschen den Code gek\u00fcrzt. Die Kommentare sind raus und das <code>autoIncrement: true</code> ist auch Standard, deshalb muss es nicht mit angegeben werden. Wenn wir die Anwendung nun ausf\u00fchren, sehen wir unter <code>IndexedDB</code>, dass ein weiterer <code>Store</code> hinzugekommen ist:</p> <p></p> <p>Diesen Store verwenden wir nun, um die neuen <code>post</code>-Daten in die IndexedDB zu schreiben:</p> /src/js/feed.js <pre><code>form.addEventListener('submit', event =&gt; {\nevent.preventDefault(); // nicht absenden und neu laden\n\nif (file == null) {\nalert('Erst Foto aufnehmen!')\nreturn;\n}\nif (titleInput.value.trim() === '' || locationInput.value.trim() === '') {\nalert('Bitte Titel und Location angeben!')\nreturn;\n}\n\ncloseCreatePostModal();\n\ntitleValue = titleInput.value;\nlocationValue = locationInput.value;\nconsole.log('titleInput', titleValue)\nconsole.log('locationInput', locationValue)\nconsole.log('file', file)\n\nif('serviceWorker' in navigator &amp;&amp; 'SyncManager' in window) {\nnavigator.serviceWorker.ready\n.then( sw =&gt; {\nlet post = {\nid: new Date().toISOString(),\ntitle: titleValue,\nlocation: locationValue,\nimage_id: file\n};\n\nwriteData('sync-posts', post)\n.then( () =&gt; {\nsw.sync.register('sync-new-post');\n});\n});\n}\n});\n</code></pre> <p>Die Registrierung der Sync Task ist nur dann sinnvoll, wenn die Daten auch tats\u00e4chlich in der IndexedDB gespeichert wurden. Deshalb erfolgt die Registrierung in dem <code>resolved</code>-Pfad der <code>writeData</code>-Promise. </p> <p>Jetzt k\u00f6nnen wir noch unseren <code>toast</code> verwenden, den wir in der <code>index.html</code> definiert haben. Hierbei handelt es sich um eine Material Design Lite-Komponente Snackbar:</p> /index.html <pre><code>&lt;div id=\"confirmation-toast\" aria-live=\"assertive\" aria-atomic=\"true\" aria-relevant=\"text\" class=\"mdl-snackbar mdl-js-snackbar\"&gt;\n    &lt;div class=\"mdl-snackbar__text\"&gt;&lt;/div&gt;\n    &lt;button type=\"button\" class=\"mdl-snackbar__action\"&gt;&lt;/button&gt;\n&lt;/div&gt;\n</code></pre> <p>In der <code>feed.js</code> verketten wir die Promise f\u00fcr das Schreiben der Daten in die IndexedDB weiter und best\u00e4tigen dies mit einer Snackbar-Nachricht:</p> /src/js/feed.js <pre><code>form.addEventListener('submit', event =&gt; {\nevent.preventDefault(); // nicht absenden und neu laden\n\nif (file == null) {\nalert('Erst Foto aufnehmen!')\nreturn;\n}\nif (titleInput.value.trim() === '' || locationInput.value.trim() === '') {\nalert('Bitte Titel und Location angeben!')\nreturn;\n}\n\ncloseCreatePostModal();\n\ntitleValue = titleInput.value;\nlocationValue = locationInput.value;\nconsole.log('titleInput', titleValue)\nconsole.log('locationInput', locationValue)\nconsole.log('file', file)\n\nif('serviceWorker' in navigator &amp;&amp; 'SyncManager' in window) {\nnavigator.serviceWorker.ready\n.then( sw =&gt; {\nlet post = {\nid: new Date().toISOString(),\ntitle: titleValue,\nlocation: locationValue,\nimage_id: file\n};\n\nwriteData('sync-posts', post)\n.then( () =&gt; {\nreturn sw.sync.register('sync-new-post');\n})\n.then( () =&gt; {\nlet snackbarContainer = new MaterialSnackbar(document.querySelector('#confirmation-toast'));\nlet data = { message: 'Eingaben zum Synchronisieren gespeichert!', timeout: 2000};\nsnackbarContainer.showSnackbar(data);\n});\n});\n}\n});\n</code></pre> <p>Beachten Sie, dass Sie das <code>return</code> in Zeile <code>271</code> einf\u00fcgen, damit die Promise verkettet werden kann. Nachdem Sie nun Daten in das Formular eingegeben und auf <code>Speichern</code> geklickt haben, erscheint f\u00fcr 2 Sekunden unten eine Best\u00e4tigungsnachricht:</p> <p></p>"},{"location":"backgroundsync/#ein-fallback","title":"Ein Fallback","text":"<p>Wir haben festgelegt, was passieren soll, wenn der Browser Service Worker und die SyncManager-API unterst\u00fctzt. Wir sollten jedoch ein Fallback einbauen f\u00fcr den Fall, dass das nicht der Fall ist. Viel bleibt uns f\u00fcr diesen Fall nicht \u00fcbrig, zu tun. Wir k\u00f6nnen nur versuchen, die Daten, die wir in das Formular eingegeben haben, sofort an das Backend zu senden. Wir f\u00fcgen dazu den Aufruf der <code>sendDataToBackend()</code>-Funktion im <code>else</code>-Fall f\u00fcr die Behandlung des <code>submit</code>-Ereignisses auf:</p> /src/js/feed.js <pre><code>form.addEventListener('submit', event =&gt; {\nevent.preventDefault(); // nicht absenden und neu laden\n\nif (file == null) {\nalert('Erst Foto aufnehmen!')\nreturn;\n}\nif (titleInput.value.trim() === '' || locationInput.value.trim() === '') {\nalert('Bitte Titel und Location angeben!')\nreturn;\n}\n\ncloseCreatePostModal();\n\ntitleValue = titleInput.value;\nlocationValue = locationInput.value;\nconsole.log('titleInput', titleValue)\nconsole.log('locationInput', locationValue)\nconsole.log('file', file)\n\nif('serviceWorker' in navigator &amp;&amp; 'SyncManager' in window) {\nnavigator.serviceWorker.ready\n.then( sw =&gt; {\nlet post = {\nid: new Date().toISOString(),\ntitle: titleValue,\nlocation: locationValue,\nimage_id: file\n};\n\nwriteData('sync-posts', post)\n.then( () =&gt; {\nreturn sw.sync.register('sync-new-post');\n})\n.then( () =&gt; {\nlet snackbarContainer = new MaterialSnackbar(document.querySelector('#confirmation-toast'));\nlet data = { message: 'Eingaben zum Synchronisieren gespeichert!', timeout: 2000};\nsnackbarContainer.showSnackbar(data);\n});\n});\n} else {\nsendDataToBackend();\n}\n});\n</code></pre> <p>Dieser Fallback l\u00e4sst sich ausprobieren, indem man daf\u00fcr sorgt, dass die Bedingung <code>if('serviceWorker' in navigator &amp;&amp; 'SyncManager' in window)</code> <code>false</code> ist (z.B. <code>&amp;&amp; false</code>). Nun k\u00fcmmern wir uns darum, dass das <code>sync</code>-Ereignis im Service Worker behandelt wird. Das geschieht immer dann, wenn der Service Worker erkennt, dass die Internetverbindung wieder hergestellt wurde. </p>"},{"location":"backgroundsync/#ereignisbehandlung-des-sync-events","title":"Ereignisbehandlung des <code>sync</code>-Events","text":"<p>Wenn der Service Worker erkennt, dass die Verbindung zum Internet wieder hergestellt ist, wird automatisch das <code>sync</code>-Event ausgel\u00f6st. Dieses Ereignis wird auch dann ausgel\u00f6st, wenn die Internetverbindung besteht und eine Sync Task registriert wurde. Wir wollen in diesem Fall die Daten aus der IndexedDB an das Backend senden. Dazu erweitern wir die <code>sw.js</code> um die Behandlung des <code>sync</code>-Ereignisses. Wir f\u00fcgen diese Ereignisbehandlung an das Ende der <code>sw.js</code> ein:</p> sw.js <pre><code>self.addEventListener('sync', event =&gt; {\nconsole.log('service worker --&gt; background syncing ...', event);\nif(event.tag === 'sync-new-post') {\nconsole.log('service worker --&gt; syncing new posts ...');\nevent.waitUntil(\nreadAllData('sync-posts')\n.then( dataArray =&gt; {\nfor(let data of dataArray) {\nconsole.log('data from IndexedDB', data);\n// diese Daten an das Backend senden (siehe Fallback)\n}\n})\n);\n}\n})\n</code></pre> <p>Wir f\u00fcgen dem Service Worker also einen <code>EventListener</code> hinzu, wie wir das bereits von den anderen Ereignisbehandlungen im Service Worker kennen. Das <code>sync</code>-Ereignis gibt auch die <code>tags</code> zur\u00fcck, unter denen Sync Tasks gespeichert wurden. In unserem Fall war der verwendete <code>tag</code> <code>sync-new-post</code>. Wir verwenden auch erneut <code>event.waitUntil()</code>, um sicherzustellen, dass die Ereignisbehandlung nicht eher verlassen wird, bis alle definierten Anweisungen darin vollst\u00e4ndig abgearbeitet wurden. Als erstes greifen wir dann lesend auf die IndexedDB unter Verwendung der <code>readAllData()</code>-Methode aus der <code>db.js</code>.</p> <p>Diese Methode gibt ein Array aller gespeicherten Datens\u00e4tze in der IndexedDB im Store <code>sync-posts</code> zur\u00fcck. Mit einer <code>for</code>-Schleife betrachten wir jeden einzelnen Datensatz. Wir \"wissen\", dass ein solcher Datensatz ein JavaScript-Objekt mit den Eigenschaften <code>id</code>, <code>title</code>, <code>location</code> und <code>image_id</code> ist. </p> <p>Wir erweitern diese Behandlung nun um den Code, den wir zuvor f\u00fcr die Funktion <code>sendDataToBackend()</code> verwendet haben. Wir senden die Daten an das Backend. Dazu k\u00f6nnen wir uns den Code von der Fallback-Implementierung kopieren und anpassen:</p> sw.js <pre><code>self.addEventListener('sync', event =&gt; {\nconsole.log('service worker --&gt; background syncing ...', event);\nif(event.tag === 'sync-new-post') {\nconsole.log('service worker --&gt; syncing new posts ...');\nevent.waitUntil(\nreadAllData('sync-posts')\n.then( dataArray =&gt; {\nfor(let data of dataArray) {\nconsole.log('data from IndexedDB', data);\nconst formData = new FormData();\nformData.append('title', data.title);\nformData.append('location', data.location);\nformData.append('file', data.image_id);\nconsole.log('formData', formData)\nfetch('http://localhost:3000/posts', {\nmethod: 'POST',\nbody: formData\n})\n.then( response =&gt; {\nconsole.log('Data sent to backend ...', response);\nif(response.ok) {\ndeleteOneData('sync-posts', data.id)\n}\n})\n.catch( err =&gt; {\nconsole.log('Error while sending data to backend ...', err);\n})\n}\n})\n);\n}\n})\n</code></pre> <p>F\u00fcr die Daten, die an das Backend gesendet werden, wird nun, im Gegensatz zum Fallback, auf <code>data</code> zugegriffen, da wir ja die Daten senden, die aus der IndexedDB ausgelesen werden. Wenn die Daten erfolgreich an das Backend \u00fcbertragen worden sind (<code>response.ok</code> in Zeile <code>120</code>), dann werden diese Daten mithilfe der <code>deleteOneDate()</code>-Funktion (aus <code>db.js</code>) gel\u00f6scht, da sie in der IndexedDB nicht weiter ben\u00f6tigt werden. Der Store <code>sync-posts</code> ist ja \"nur\" dazu da, die Daten so lange zwischenzuspeichern, bis sie ins Backend (in die persistente Datenbank) gesendet sind. Sollte stattdessen ein Fehler auftreten, wird er mithilfe von <code>catch()</code> abgefangen und dort ausgegeben. </p> <p>Wenn wir nun neue Daten in das Formular eingeben und auf <code>Speichern</code> klicken, werden die Daten zum Backend gesendet - eventuell nicht gleich, sondern erst dann, wenn die Anwendung (und somit das Backend) wieder online ist.</p> <p>Das Ausprobieren der sp\u00e4teren Hintergrundsynchronisation erfolgt am Sichersten dadurch, dass Sie den Rechner komplett vom WLAN trennen. Das Offline-Schalten des Service Workers gen\u00fcgt dazu h\u00e4ufig nicht (bzw. wird beim Online-Schalten dann manchmal kein <code>sync</code>-Ereignis ausgel\u00f6st).</p> <ol> <li>Schalten Sie das WLAN an Ihrem Rechner aus. </li> <li>Geben Sie \u00fcber das Formular der Anwendung neue Daten ein und dr\u00fccken Sie auf den <code>Speichern</code>-Button. </li> <li>Schauen Sie in den Developer Tools unter <code>IndexedDB</code> in den Store <code>sync-posts</code>. Dort sollten die neuen Daten nun gespeichert sein. </li> <li>Schalten Sie das WLAN wieder ein. Auf der Konsole erscheint die <code>fetch</code>-Nachricht f\u00fcr <code>POST \"http://localhost:3000/posts\"</code>.</li> <li>In der persistenten Datenbank stehen die neuen Daten. </li> <li>Nach einem Reload der Anwendung werden diese Daten aus der Datenbank \u00fcber das Backend gelesen (ohne Bilder) und erscheinen als weitere <code>Cards</code>.</li> </ol> <p>Success</p> <p>Wir haben die Hintergrundsynchronisation implementiert! Das Senden der Daten an das Backend erfolgt \u00fcber das Registrieren einer Sync Task und dem (zwischen-)Speichern der zu sendenden Daten in der IndexedDB. Durch die Ereignisbehandlung des <code>sync</code>-Ereignisses werden diese Daten an das Backend (und dar\u00fcber in die Datenbank) geschrieben. Das <code>sync</code>-Ereignis wird ausgel\u00f6st, wenn der Service Worker online und eine Sync Task registriert ist. Wir k\u00f6nnen nun Daten eingeben und speichern, egal, ob wir online oder offline sind. Die Anwendung kann sogar geschlossen sein und trotzdem synchronisiert der Service Worker. </p>"},{"location":"bilder/","title":"Backend-Erweiterung um das Speichern von Bildern","text":"<p>Bis jetzt haben wir nur Daten im JSON-Format zwischen Frontend und Backend ausgetauscht und auch nur solche Daten in der MongoDB gespeichert. Bilder (und auch andere Dateien) sind FormData-Objects im <code>multipart/form-data</code>-Format. Zur Behandlung solcher Daten verwenden wir ein Middleware f\u00fcr unser Backend, namens Multer. </p> <p>Hint<p>Wenn Sie nur am Code f\u00fcr unser Backend interessiert sind, dann k\u00f6nnen Sie auch direkt zu Zusammenf\u00fchren der Funktionalit\u00e4ten springen. Im Folgenden werden die Entstehung aber n\u00e4her erl\u00e4utert und verschiedene Varianten diskutiert. </p> </p> <p>MongoDB speichert Daten bis zu einer Gr\u00f6\u00dfe von <code>16Mb</code> im Bin\u00e4rformat. Um auch gr\u00f6\u00dfere Dateien (Bilder, Videos, pdf, ...) speichern zu k\u00f6nnen, werden die Dateien in chunks zerlegt und k\u00f6nnen dann aus diesen St\u00fccken wieder zusammengesetzt werden. Daf\u00fcr gibt es in der MongoDB eine GridFS-Spezifikation. Das MongoDB-Paket (also der MongoDB-Node.js-Treiber bringt bereits eine GridFS-API mit. F\u00fcr die Zusammenarbeit von Multer und GridFS bietet sich Multer-GridFS-Storage an. </p> <p>Wir installieren Multer und Multer-GridFS-Storage im Backend-Projekt und zeigen im Folgenden deren Verwendung:</p> <pre><code>npm install multer multer-gridfs-storage\n</code></pre> <p>Leider ist die Version <code>5.0.2</code> von <code>multer-gridfs-storage</code> nicht kompatibel mit der <code>multer</code>-Version <code>1.4.5.-lts.1</code>. Wir m\u00fcssen deshalb in der <code>package.json</code> die Version f\u00fcr <code>multer</code> auf <code>1.4.4.</code> setzen:</p> <p>Die <code>package.json</code> sollte nun ungef\u00e4hr so aussehen:</p> package.json <pre><code>{\n\"name\": \"backend\",\n\"version\": \"1.0.0\",\n\"description\": \"Backend REST-API\",\n\"main\": \"server.js\",\n\"scripts\": {\n\"watch\": \"nodemon ./server.js\",\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n\"keywords\": [\n\"rest\",\n\"api\",\n\"backend\",\n\"mongodb\"\n],\n\"author\": \"J. Freiheit\",\n\"license\": \"ISC\",\n\"dependencies\": {\n\"cors\": \"^2.8.5\",\n\"dotenv\": \"^16.0.3\",\n\"express\": \"^4.18.2\",\n\"mongodb\": \"^5.5.0\",\n\"multer\": \"^1.4.4\",\n\"multer-gridfs-storage\": \"^5.0.2\"\n},\n\"devDependencies\": {\n\"nodemon\": \"^2.0.22\"\n}\n}\n</code></pre> <p>Zun\u00e4chst erstellen wir zwei weitere Routen <code>/download</code> und <code>/upload</code> in der <code>server.js</code>. </p> server.js <pre><code>const express = require('express');\nconst postRoutes = require('./routes/post.routes');\nconst uploadRoutes = require('./routes/upload.routes');\nconst downloadRoutes = require('./routes/download.routes');\nconst cors = require('cors')\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.json());\n// enable cors for all requests\napp.use(cors());\napp.use('/posts', postRoutes);\napp.use('/upload', uploadRoutes);\napp.use('/download', downloadRoutes);\n\napp.listen(PORT, (error) =&gt; {\nif (error) {\nconsole.log(error);\n} else {\nconsole.log(`server running on http://localhost:${PORT}`);\n}\n});\n</code></pre> <p>Wir ben\u00f6tigen also sowohl eine <code>routes/upload.routes.js</code> als auch eine <code>routes/download.routes.js</code>. Beachten Sie, dass zum Compilieren des Projektes in den beiden Skripten mindestens</p> routes/upload.routes.jsroutes/download.routes.js <pre><code>const express = require('express');\nconst router = express.Router();\n\nmodule.exports = router;\n</code></pre> <pre><code>const express = require('express');\nconst router = express.Router();\n\nmodule.exports = router;\n</code></pre> <p>enthalten sein muss. Wir k\u00fcmmern uns nun zun\u00e4chst darum, Bilder in die MongoDB hochzuladen. </p>"},{"location":"bilder/#upload-von-bildern","title":"Upload von Bildern","text":"<p>F\u00fcr den Upload der Bilder erstellen wir zun\u00e4chst einen Ordner <code>middleware</code> und darin eine Datei <code>upload.js</code>. In dieser Datei wird unter Verwendung von <code>Multer</code> ein <code>GridFsStorage</code> eingerichtet. Die zu verwendende Collection benennen wir hier <code>posts</code> (siehe <code>bucketName</code>). Die Datenbank hei\u00dft <code>image</code> (siehe <code>dbName</code>). Sie k\u00f6nnen diese Namen frei w\u00e4hlen. Beachten Sie dann aber im Folgenden \u00fcberall die Verwendung von <code>posts</code> (in der MongoDB entstehen die Collections <code>posts.files</code> und <code>posts.chunks</code> - siehe z.B. hier oder hier).</p> middleware/upload.js <pre><code>const multer = require(\"multer\");\nconst {\nGridFsStorage\n} = require(\"multer-gridfs-storage\");\nrequire('dotenv').config();\n\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst storage = new GridFsStorage({\n//db: connection,\nurl: process.env.DB_CONNECTION,\noptions: { sslKey: credentials,        // nur falls ein Zertifikat zur Autorisierung\nsslCert: credentials,       // f\u00fcr MongoDB Atlas verwendet wird\ndbName: \"htwinsta\" },\nfile: (req, file) =&gt; {\nconst match = [\"image/png\", \"image/jpeg\", \"image/jpg\"];\n\nif (match.indexOf(file.mimetype) === -1) {\nconsole.log('file.mimetype === -1')\nreturn `${Date.now()}-jf-${file.originalname}`;\n}\nconsole.log('store');\nreturn {\nbucketName: 'posts',\nfilename: `${Date.now()}-jf-${file.originalname}`,\n};\n},\n});\n\nmodule.exports = multer({ storage });\n</code></pre> <p>Beachten Sie, dass wir beim Upload der Bilder f\u00fcr diese Bilder Dateinamen mithilfe von <code>${Date.now()}-jf-${file.originalname}</code> erstellen bzw. festlegen. Damit diese Dateinamen eindeutig sind, wird mithilfe von <code>Date.now()</code> der aktuelle Zeitstempel verwendet. Der String <code>-jf-</code> in der Mitte kann nat\u00fcrlich auch durch Ihre Initialen ersetzt (oder weggelassen) werden. Au\u00dferdem wird auch noch der originale Dateiname verwendet. Insgesamt sollte sichergestellt werden, dass die Dateinamen eindeutig sind (deshalb auch <code>Date.now()</code>). </p> <p>In Zeile <code>18</code> werden die Dateitypen festgelegt, die akzeptiert werden, hier <code>png</code> und <code>jpeg</code>. Diese Liste kann erweitert oder eingegrenzt werden.</p> <p>Diese Middleware nutzen wir nun f\u00fcr den <code>POST</code>-Request des Bildes (siehe folgend Zeile <code>5</code> <code>upload.single('file')</code>) und implementieren die <code>routes/upload.routes.js</code> wie folgt:</p> routes/upload.route.js <pre><code>const express = require('express');\nconst router = express.Router();\nconst upload = require('../middleware/upload');\n\nrouter.post('/', upload.single('file'), (req, res) =&gt; {\nif (req.file === undefined) {\nreturn res.send({\n\"message\": \"no file selected\"\n});\n} else {\nconsole.log('req.file', req.file);\nconst imgUrl = `http://localhost:3000/download/${req.file.filename}`;\nreturn res.status(201).send({\nurl: imgUrl\n});\n}\n})\n\nmodule.exports = router;\n</code></pre> <p>In Zeile <code>5</code> wird die multer-Middleware mit <code>update.single('file')</code> aufgerufen. Deren Funktionalit\u00e4t haben wir in der <code>middleware/upload.js</code> \u00fcberschrieben und genauer spezifiziert. Neben der Funktion <code>.single(fieldname)</code> stehen auch die Funktionen <code>.array(fieldname[, maxCount])</code> und <code>.fields(field)</code> zur Verf\u00fcgung, um gleichzeitig mehrere Dateien hochzuladen (siehe multer). </p> <p>Als Response wird die URL zur\u00fcckgegeben, unter der das Bild heruntergeladen werden kann (<code>http://localhost:3000/download/${req.file.filename}</code>). Beachten Sie, dass die Backend-URL und auch der Port hier hart kodiert sind. Das sollte besser in die <code>.env</code>-Datei ausgelagert werden. </p>"},{"location":"bilder/#upload-mithilfe-von-postman","title":"Upload mithilfe von Postman","text":"<p>Das Hochladen der Bilder kann nun getestet werden. Starten Sie das Backend. \u00d6ffnen Sie Postman und geben Sie als URL <code>http://localhost:3000/upload</code> ein und w\u00e4hlen als Anfragemethode <code>POST</code>. Klicken Sie auf <code>Body</code> und markieren dann <code>form-data</code>:</p> <p></p> <p>Geben Sie unter <code>KEY</code> den Schl\u00fcssel <code>file</code> ein (das wird manchmal vergessen und dann bekommen Sie einen <code>multer</code>-Fehler <code>unexpected field</code>!) und w\u00e4hlen Sie aus dem Dropdown-Men\u00fc <code>File</code>. Unter <code>VALUE</code> erscheint der Button <code>Select Files</code>. Klicken Sie darauf und w\u00e4hlen ein <code>png</code>- oder ein <code>jpeg</code>-Bild (kann auch <code>.jpg</code> sein) aus, das Sie hochladen wollen. Klicken Sie dann auf <code>Send</code>. Es erscheint:</p> <p></p> <p>Ich habe in diesem Beispiel die Datei <code>fiw.jpg</code> hochgeladen. </p> <p>Wenn Sie sich die MongoDB anschauen (in Compass), dann finden Sie darin die beiden Collections <code>posts.files</code> und <code>posts.chunks</code>. In <code>posts.files</code> sind die Metadaten des hochgeladenen Bildes zu finden, z.B. </p> <pre><code>{\n\"_id\": {\n\"$oid\": \"646062e135cc14afbf5fd29b\"\n},\n\"length\": 86584,\n\"chunkSize\": 261120,\n\"uploadDate\": {\n\"$date\": \"2023-05-14T04:26:10.472Z\"\n},\n\"filename\": \"1684038369483-jf-fiw.jpg\",\n\"contentType\": \"image/jpeg\"\n}\n</code></pre> <p>Die dazugeh\u00f6rige <code>_id</code> finden Sie auch in <code>posts.chunks</code> (k\u00f6nnen Sie sich in der <code>mongosh</code> mit <code>db.posts.chunks.find({ _id: \"646062e135cc14afbf5fd29b\" })</code> anschauen). Darin ist das Bild im Binary-Format gespeichert. </p>"},{"location":"bilder/#download-von-bildern","title":"Download von Bildern","text":"<p>F\u00fcr den Download der gespeicherten Bilder gehen wir \u00e4hnlich vor, wie beim Upload, ben\u00f6tigen daf\u00fcr aber nicht mehr die multer-Middleware, daf\u00fcr aber GridFS Bucket aus dem MongoDB-Node-Paket. Wir implementieren <code>routes/download.routes.js</code> mit folgendem Inhalt:</p> routes/download.routes.js <pre><code>const express = require('express');\nconst router = express.Router();\nconst mongodb = require('mongodb')\nconst { database } = require('../configure/db')\n\nconst bucket = new mongodb.GridFSBucket(database, {\nbucketName: 'posts'\n});\n\nrouter.get('/:filename', async(req, res) =&gt; {\ntry {\nconst filename = req.params.filename;\nlet downloadStream = bucket.openDownloadStreamByName(filename);\ndownloadStream.on(\"data\", (data) =&gt; res.status(200).write(data));\ndownloadStream.on(\"error\", (err) =&gt; res.status(404).send({ message: filename + \" does not exist\" }));\ndownloadStream.on(\"end\", () =&gt; res.end());\n} catch (error) {\nconsole.log('error', error);\nres.send(\"not found\");\n}\n});\n\nmodule.exports = router;\n</code></pre> <p>GridFSBucket ist eine Klasse aus der Node.js-MongoDB-API. Diese h\u00e4tten wir auch schon f\u00fcr das Upload verwenden k\u00f6nnen (siehe z.B. hier). </p> <p>Mit der <code>openDownloadStream()</code>-Funktion der <code>GridFSBucket()</code>-Klasse \u00f6ffnen wir den Download-Stream des Bildes und geben ihn (genauer gesagt, die Daten <code>data</code> des Streams) als response <code>res</code> zur\u00fcck. </p>"},{"location":"bilder/#download-mithilfe-von-postman","title":"Download mithilfe von Postman","text":"<p>Der Test des <code>GET http://localhost:3000/download/:filename</code>-Endpunktes ist einfach. Dazu verwenden wir einfach die URL, die durch den Upload als Response  zur\u00fcckgegeben wurde (im obigen Beispiel also <code>\"http://localhost:3000/download/1684038369483-jf-fiw.jpg\"</code>):</p> <p>Geben Sie in Postman also Ihre URL ein, w\u00e4hlen <code>GET</code> und klicken <code>Send</code>. Es erscheint das Bild:</p> <p></p> <p>Da es sich um die GET-Methode handelt, k\u00f6nnen Sie die URL <code>http://localhost:3000/download/1684038369483-jf-fiw.jpg</code> nat\u00fcrlich auch in den Browser eingeben und das Bild erscheint. </p>"},{"location":"bilder/#delete-von-bildern","title":"Delete von Bildern","text":"<p>Das L\u00f6schen der Bilder ist ganz \u00e4hnlich zum Download. Wir kommen hier allerdings ohne einen Stream aus und ben\u00f6tigen nur die <code>delete()</code>-Funktion von <code>GridFSBucket</code>. Au\u00dferdem suchen wir hier nicht nach dem Dateinamen, sondern nach der <code>id</code>. Erstellen Sie die Datei <code>routes/delete.route.js</code>:</p> routes/delete.routes.js <pre><code>const express = require('express');\nconst router = express.Router();\nconst mongodb = require('mongodb')\nconst { database } = require('../configure/db')\nconst  ObjectId = require('mongodb').ObjectId\n\nconst bucket = new mongodb.GridFSBucket(database, {\nbucketName: 'posts'\n});\n\nrouter.delete('/:id', async(req, res) =&gt; {\nconst id = req.params.id;\ntry {\nawait bucket.delete(new ObjectId(id));\nconsole.log('result', result)\nres.status(200).send({ message: \"deleted\"})\n} catch (error) {\nconsole.log('error', error);\nres.status(404).send({ message: \"id \" + id + \" does not exist\" });\n}\n});\n\nmodule.exports = router;\n</code></pre> <p>und binden diese in die <code>server.js</code> ein:</p> server.js <pre><code>const express = require('express');\nconst postRoutes = require('./routes/post.routes');\nconst uploadRoutes = require('./routes/upload.routes');\nconst downloadRoutes = require('./routes/download.routes');\nconst deleteRoutes = require('./routes/delete.routes');\nconst cors = require('cors')\nconst app = express();\nconst PORT = 3000;\n\napp.use(express.json());\n// enable cors for all requests\napp.use(cors());\napp.use('/posts', postRoutes);\napp.use('/upload', uploadRoutes);\napp.use('/download', downloadRoutes);\napp.use('/delete', deleteRoutes);\napp.listen(PORT, (error) =&gt; {\nif (error) {\nconsole.log(error);\n} else {\nconsole.log(`server running on http://localhost:${PORT}`);\n}\n});\n</code></pre>"},{"location":"bilder/#delete-mithilfe-von-postman","title":"Delete mithilfe von Postman","text":"<p>Zum Testen verwenden Sie die <code>id</code> und w\u00e4hlen als Anfragemethode <code>DELETE</code>. Senden Sie ruhig zwei Mal ab, beim ersten Mal wird die Datei gel\u00f6scht (aus <code>.files</code> und auch aus <code>.chunks</code>) und beim zweiten Mal sollte eine Fehlermessage erfolgen. </p>"},{"location":"bilder/#zusammenfuhren-der-funktionalitaten","title":"Zusammenf\u00fchren der Funktionalit\u00e4ten","text":"<p>Wir haben nun recht viele Routen und Endpunkte in unserem Backend. Wir wollen aber gerne, dass es nur die f\u00fcnf genannten Endpunkte gibt:</p> \u00a0Methode \u00a0URL \u00a0Bedeutung \u00a0GET \u00a0/posts \u00a0hole alle Datens\u00e4tze \u00a0GET \u00a0/posts/11 hole den Datensatz mit der id=11 \u00a0POST \u00a0/posts \u00a0f\u00fcge einen neuen Datensatz hinzu \u00a0PUT \u00a0/posts/11 \u00a0\u00e4ndere den Datensatz mit der id=11 \u00a0DELETE \u00a0/posts/11 \u00a0l\u00f6sche den Datensatz mit der id=11 <p>Das bedeutet, wir binden den Upload und Download von Bildern nun in unsere <code>posts</code>-Routen ein. Die Funktionen werden dabei \"etwas\" umfangreicher. </p>"},{"location":"bilder/#zum-verstandnis","title":"Zum Verst\u00e4ndnis","text":"<p>Wir verwenden Multer und GridFs Storage. Multer ist eine Middleware f\u00fcr Node.js, um Daten im <code>multipart/form-data</code>-Format zu verwalten. Die grunds\u00e4tzliche Idee ist, dass im Request nicht nur ein <code>body</code>, sondern auch eine <code>file</code>-Eigenschaft enthalten ist (neben dem <code>header</code>). Multer verwendet einen <code>storage</code>, um Bilder (oder andere Dateien) zu speichern. Einen solchen <code>storage</code> bietet <code>GridFs Storage</code>. Dieser kann sogar Dateien gr\u00f6\u00dfer als 16 MB speichern und die Idee dabei ist, dass die Datei in zwei Collections gespeichert wird, in der <code>files</code>-Collection, welche die (Meta-)Informationen der Datei speichert und der <code>chunks</code>-Collection, die die eigentliche Datei (als Bin\u00e4rdaten) speichert. Eine Datei kann dabei in mehrere <code>chunks</code> unterteilt werden. Die folgende Abbildung zeigt das Prinzip von <code>GridFS</code>:</p> <p></p> <p>F\u00fcr unser Datenmodell sieht die Aufteilung der Daten somit wie folgt aus:</p> <ul> <li> <p>in der <code>posts</code>-Collection speichern wir</p> <ul> <li>die <code>_id</code> des Posts,</li> <li>den <code>title</code> eines Posts,</li> <li>die <code>location</code> und </li> <li>die <code>image_id</code>. Die <code>image_id</code> enth\u00e4lt den Dateinamen <code>filename</code> des Bildes.</li> </ul> </li> <li> <p>in der <code>posts.files</code>-Collection speichern wir (GridFs)</p> <ul> <li>die <code>_id</code> der Datei,</li> <li>die <code>length</code> der Datei,</li> <li>die <code>chunkSize</code>, </li> <li>das <code>uploadDate</code>, </li> <li>den <code>filename</code> (siehe in <code>posts</code> die <code>image_id</code>) und </li> <li>den <code>contenType</code> (z.B. <code>image/jpeg</code>)</li> </ul> </li> <li> <p>in der <code>posts.chunks</code>-Collection speichern wir (GridFs)</p> <ul> <li>die <code>_id</code> des Chunks,</li> <li>die <code>files_id</code> (diese entspricht der <code>_id</code> der Datei in der <code>posts.files</code>-Collection),</li> <li>ein <code>n</code> (fortlaufende Nummerierung der Chunks einer Datei beginnend mit <code>0</code>),</li> <li>die <code>data</code> der Datei (in diesem Chunk)</li> </ul> </li> </ul> <p>Chunks kann es zu einer Datei mehrere geben. Alle <code>data</code> aller Chunks einer Datei bilden zusammen die Datei als Bin\u00e4r- (bzw. base64-) Daten. Die folgende Abbildung zeigt unser Datenmodell in der Datenbank <code>posts</code>:</p> <p></p> <p>Um z.B. einen Datensatz (einen Post) anzulegen, speichern wir also die zugeh\u00f6rigen Daten in der <code>posts</code>-Collection (inkl. dem <code>filename</code> der Datei), speichern die Meta-Informationen der Datei in der <code>posts.files</code>-Collection und die zugeh\u00f6rigen Bin\u00e4rdaten der Datei in <code>posts.chunks</code>. </p>"},{"location":"bilder/#post-kompletter-datensatz","title":"POST - kompletter Datensatz","text":"<p>Die <code>POST</code>-Funktion f\u00fcr einen Datensatz ist nicht viel umfangreicher als zuvor:</p> aus routes/post.routes.js <pre><code>// POST one new post\nrouter.post('/', upload.single('file'), async(req, res) =&gt; {\nif (req.file === undefined) {\nreturn res.send({\n\"message\": \"no file selected\"\n});\n} else {\ntry {\nconst newPost = {\ntitle: req.body.title,\nlocation: req.body.location,\nimage_id: req.file.filename }\nawait collection.insertOne(newPost);\nres.status(201);\nres.send(result);\n} catch {\nres.status(404);\nres.send({\nerror: \"Post not created\"\n});\n}}\n});\n</code></pre> <p>Wichtig ist, dass <code>post.routes.js</code> nun auch die <code>upload.js</code> einbindet:</p> aus routes/post.routes.js <p><pre><code>const upload = require('../middleware/upload');\n</code></pre> Achten Sie darauf, dass Sie in <code>upload.js</code> die korrekte Datenbank verwenden (siehe <code>dbName</code>)!</p> <p>Beachten Sie, dass die Daten nun nicht mehr als JSON \u00fcbergeben werden, sondern als <code>form-data</code>. Der Test mithilfe von Postman sieht deshalb nun so aus:</p> <p> </p> <p>Als Response bekommen Sie aber wieder ein JSON zur\u00fcck, z.B.:</p> <pre><code>{\n\"acknowledged\": true,\n\"insertedId\": \"627a0ff2305433d805b6b435\"\n}\n</code></pre> <p>Das Bild ist nun in der Collection <code>posts</code> einerseits in <code>posts.files</code> mit den Daten</p> <p> </p> <p>und in <code>posts.chunks</code> mit den Daten</p> <p> </p> <p>gespeichert. Beachten Sie, dass das Bild so klein ist, dass es in nur einem <code>chunk</code> gespeichert werden kann. Gr\u00f6\u00dfere Dateien werden in mehrer <code>chunks</code> aufgeteilt. Alle diese <code>chunks</code>, die zu einem Bild geh\u00f6ren, haben dann dieselbe <code>files_id</code> (aber fortlaufende <code>_id</code>s).</p> <p>In der <code>posts</code>-Collection sieht der Datensatz dann wie folgt aus:</p> <p> </p>"},{"location":"bilder/#get-ein-kompletter-datensatz","title":"GET - ein kompletter Datensatz","text":"<p>Jetzt den kompletten Datensatz mit einer bestimmten <code>_id</code> zu laden, ist etwas aufwendiger:</p> <ol> <li>Wir laden zun\u00e4chst aus der <code>posts</code>-Collection den Datensatz mit der <code>_id</code>. </li> <li>Aus diesem Datensatz lesen wir die <code>image_id</code> aus. Das ist der <code>filename</code> mit dem wir in der <code>posts.files</code>-Collection suchen. </li> <li>Aus der <code>posts.files</code>-Collection lesen wir den Datensatz mit dem <code>filename</code> aus und identifizieren dessen <code>_id</code>. </li> <li>Nach dieser <code>_id</code> suchen wir unter <code>files_id</code> in der <code>posts.chunks</code>-Collection und lesen alle zugeh\u00f6rigen <code>chunks</code> aus. </li> </ol> <p>Dazu schreiben wir uns zun\u00e4chst eine Funktion <code>getOnePost(id)</code>, die ein <code>Promise</code> zur\u00fcckgibt.</p> aus routes/posts.routes.js <pre><code>require('dotenv').config();\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst connection = mongoose.createConnection(process.env.DB_CONNECTION, { sslKey: credentials,\nsslCert: credentials,\ndbName: \"htwinsta\" });\n\nfunction getOnePost(id) {\n\nreturn new Promise( async(resolve, reject) =&gt; {\ntry {\n\nconst post = await Post.findOne({ _id: id });\nlet fileName = post.image_id;\nconst files = connection.collection('posts.files');\nconst chunks = connection.collection('posts.chunks');\n\nconst cursorFiles = files.find({filename: fileName});\nconst allFiles = await cursorFiles.toArray();\nconst cursorChunks = chunks.find({files_id : allFiles[0]._id});\nconst sortedChunks = cursorChunks.sort({n: 1});\nlet fileData = [];\nfor await (const chunk of sortedChunks) {\nfileData.push(chunk.data.toString('base64'));\n}\nlet base64file = 'data:' + allFiles[0].contentType + ';base64,' + fileData.join('');\nlet getPost = new Post({\n\"title\": post.title,\n\"location\": post.location, \"image_id\": base64file\n});\n//console.log('getPost', getPost)\nresolve(getPost)\n} catch {\nreject(new Error(\"Post does not exist!\"));\n}\n})\n}\n</code></pre> <p>Die Konsolenausgaben k\u00f6nnen nat\u00fcrlich auch alle entfernt werden, aber es lohnt sich vielleicht auch zu sehen, was an den einzelnen Stellen passiert. In Zeile <code>37</code> erfolgt der Zugriff auf die <code>posts</code>-Collection und es wird der Datensatz mit der <code>_id</code> ermittelt, welche als Parameter der URL \u00fcbergeben wurde. Aus dem Ergebnis <code>post</code> wird dann der Dateiname des Bildes in Zeile <code>37</code> mithilfe von <code>post.image_id</code> ermittelt. </p> <p>In der <code>post.files</code>-Collection wird in Zeile <code>42</code> nach dem Datensatz mit dem entsprechenden <code>filename</code> gesucht. Die <code>_id</code> dieses Datensatzes ist der Wert von <code>files_id</code> in der Collection <code>posts.chunks</code>. Nach all diesen Eintr\u00e4gen wird in Zeile <code>44</code> gesucht. Aus allen <code>chunks</code> wird dann der <code>base64</code>-String erzeugt und dem <code>Post</code>-Objekt \u00fcbergeben, welches als <code>resolve</code> der <code>Promise</code> zur\u00fcckgeschickt wird. </p> <p>Diese Funktion k\u00f6nnen wir nun f\u00fcr unseren <code>get('/:id')</code>-Endpunkt verwenden. Die Funktion sieht dann wie folgt aus:</p> aus routes/posts.routes.js <pre><code>// GET one post via id\nrouter.get('/:id', async(req, res) =&gt; {\ngetOnePost(req.params.id)\n.then( (post) =&gt; {\nconsole.log('post', post);\nres.send(post);\n})\n.catch( () =&gt; {\nres.status(404);\nres.send({\nerror: \"Post does not exist!\"\n});\n})\n});\n</code></pre> <p>Wir \u00fcbergeben der <code>getOnePost()</code>-Funktion die als Parameter \u00fcbergebene <code>id</code> und senden den <code>resolve</code>-Wert der <code>Promise</code> als Response zur\u00fcck. </p>"},{"location":"bilder/#get-alle-datensatze","title":"GET - alle Datens\u00e4tze","text":"<p>Der Ansatz, um alle Datens\u00e4tze aus der MongoDB zu lesen, ist der gleiche, wie f\u00fcr einen Datensatz. Wir ermitteln sukzessive die <code>_id</code> alle Datens\u00e4tze in der <code>posts</code>-Collection. Dazu schreiben wir uns eine Funktion <code>getAllPosts()</code>. In dieser laden wir zun\u00e4chst alle <code>posts</code> und rufen dann f\u00fcr jeden einzelnen die <code>getOnePost(id</code>-Funktion auf:</p> aus routes/posts.routes.js <pre><code>function getAllPosts() {\nreturn new Promise( async(resolve, reject) =&gt; {\nconst sendAllPosts = [];\nconst allPosts = await Post.find();\ntry {\nfor(const post of allPosts) {\nconsole.log('post', post)\nconst onePost = await getOnePost(post._id);\nsendAllPosts.push(onePost);\n}\nconsole.log('sendAllPosts', sendAllPosts)\nresolve(sendAllPosts)\n} catch {\nreject(new Error(\"Posts do not exist!\"));\n}\n});\n}\n</code></pre> <p>Die Verwendung dieser Funktion ist wie oben:</p> aus routes/posts.routes.js <pre><code>// GET all posts\nrouter.get('/', async(req, res) =&gt; {\n\ngetAllPosts()\n.then( (posts) =&gt; {\nres.send(posts);\n})\n.catch( () =&gt; {\nres.status(404);\nres.send({\nerror: \"Post do not exist!\"\n});\n})\n});\n</code></pre>"},{"location":"bilder/#delete-einen-datensatz","title":"DELETE - einen Datensatz","text":"<p>Wird ein Post gel\u00f6scht, m\u00fcssen wir auch daf\u00fcr sorgen, dass das zugeh\u00f6rige Bild aus der <code>posts.files</code> und der <code>posts.chunks</code> gel\u00f6scht wird. Das L\u00f6schen ist also dreistufig:</p> aus routes/posts.routes.js <pre><code>// DELETE one post via id\nrouter.delete('/:id', async(req, res) =&gt; {\ntry {\nconst post = await Post.findOne({ _id: req.params.id })\nlet fileName = post.image_id;\nawait Post.deleteOne({ _id: req.params.id });\nawait files.find({filename: fileName}).toArray( async(err, docs) =&gt; {\nawait chunks.deleteMany({files_id : docs[0]._id});\n})\nawait files.deleteOne({filename: fileName});\nres.status(204).send()\n} catch {\nres.status(404)\nres.send({ error: \"Post does not exist!\" })\n}\n});\n</code></pre>"},{"location":"bilder/#zusammenfassung-code-des-backends","title":"Zusammenfassung - Code des Backends","text":"<p>Hier nochmal alle wichtigen Dateien unseres Backends:</p> server.js <pre><code>const express = require('express')\nconst cors = require('cors')\nconst postsRoutes = require('./routes/posts.routes')\nconst uploadRoutes = require('./routes/upload.routes');\nconst downloadRoute = require('./routes/download.routes');\nconst deleteRoute = require('./routes/delete.routes');\nconst mongoose = require('mongoose');\nrequire('dotenv').config();\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst app = express()\nconst PORT = 3000;\n\napp.use(express.json());\napp.use(cors())\napp.use('/posts', postsRoutes);\napp.use('/upload', uploadRoutes);\napp.use('/download', downloadRoute);\napp.use('/delete', deleteRoute);\n\n// connect to mongoDB\nmongoose.connect(process.env.DB_CONNECTION, { sslKey: credentials,\nsslCert: credentials,\ndbName: process.env.DATABASE });\n\nconst db = mongoose.connection;\ndb.on('error', err =&gt; {\nconsole.log(err);\n});\ndb.once('open', () =&gt; {\nconsole.log('connected to DB');\n});\n\napp.listen(PORT, (error) =&gt; {\nif(error) {\nconsole.log('error', error)\n} else {\nconsole.log(`server running on http://localhost:${PORT}`)\n}\n})\n</code></pre> middleware/upload.js <pre><code>const multer = require(\"multer\");\nconst {\nGridFsStorage\n} = require(\"multer-gridfs-storage\");\nconst mongoose = require('mongoose');\nrequire('dotenv').config();\n\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst storage = new GridFsStorage({\n//db: connection,\nurl: process.env.DB_CONNECTION,\noptions: { sslKey: credentials,        // nur falls ein Zertifikat zur Autorisierung\nsslCert: credentials,       // f\u00fcr MongoDB Atlas verwendet wird\ndbName: \"htwinsta\" },\nfile: (req, file) =&gt; {\nconst match = [\"image/png\", \"image/jpeg\"];\n\nif (match.indexOf(file.mimetype) === -1) {\nconsole.log('file.mimetype === -1')\nreturn `${Date.now()}-jf-${file.originalname}`;\n}\nconsole.log('store');\nreturn {\nbucketName: 'posts',\nfilename: `${Date.now()}-jf-${file.originalname}`,\n};\n},\n});\n\nmodule.exports = multer({ storage });\n</code></pre> routes/posts.routes.js <pre><code>const express = require('express')\nconst router = express.Router()\nconst mongoose = require('mongoose');\nconst Post = require('../models/posts');\nconst upload = require('../middleware/upload');\nrequire('dotenv').config();\n\n/* ----------------- POST ---------------------------- */\n\n// POST one post\nrouter.post('/', upload.single('file'), async(req, res) =&gt; {\nconst newPost = new Post({\ntitle: req.body.title,\nlocation: req.body.location,\nimage_id: req.file.filename\n})\nawait newPost.save();\nres.send(newPost);\n});\n\n/* ----------------- GET ---------------------------- */\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst connection = mongoose.createConnection(process.env.DB_CONNECTION, { sslKey: credentials,\nsslCert: credentials,\ndbName: \"htwinsta\" });\n\nfunction getOnePost(id) {\nreturn new Promise( async(resolve, reject) =&gt; {\ntry {\n\nconst post = await Post.findOne({ _id: id });\nlet fileName = post.image_id;\nconst files = connection.collection('posts.files');\nconst chunks = connection.collection('posts.chunks');\n\nconst cursorFiles = files.find({filename: fileName});\nconst allFiles = await cursorFiles.toArray();\nconst cursorChunks = chunks.find({files_id : allFiles[0]._id});\nconst sortedChunks = cursorChunks.sort({n: 1});\nlet fileData = [];\nfor await (const chunk of sortedChunks) {\nfileData.push(chunk.data.toString('base64'));\n}\nlet base64file = 'data:' + allFiles[0].contentType + ';base64,' + fileData.join('');\nlet getPost = new Post({\n\"title\": post.title,\n\"location\": post.location, \"image_id\": base64file\n});\n//console.log('getPost', getPost)\nresolve(getPost)\n} catch {\nreject(new Error(\"Post does not exist!\"));\n}\n})\n}\n\nfunction getAllPosts() {\nreturn new Promise( async(resolve, reject) =&gt; {\nconst sendAllPosts = [];\nconst allPosts = await Post.find();\ntry {\nfor(const post of allPosts) {\nconsole.log('post', post)\nconst onePost = await getOnePost(post._id);\nsendAllPosts.push(onePost);\n}\nconsole.log('sendAllPosts', sendAllPosts)\nresolve(sendAllPosts)\n} catch {\nreject(new Error(\"Posts do not exist!\"));\n}\n});\n}\n\n// GET one post via id\nrouter.get('/:id', async(req, res) =&gt; {\ngetOnePost(req.params.id)\n.then( (post) =&gt; {\nconsole.log('post', post);\nres.send(post);\n})\n.catch( () =&gt; {\nres.status(404);\nres.send({\nerror: \"Post does not exist!\"\n});\n})\n});\n\n// GET all posts\nrouter.get('/', async(req, res) =&gt; {\ngetAllPosts()\n.then( (posts) =&gt; {\nres.send(posts);\n})\n.catch( () =&gt; {\nres.status(404);\nres.send({\nerror: \"Post do not exist!\"\n});\n})\n});\n\n/* ----------------- DELETE ---------------------------- */\n\n// DELETE one post via id\nrouter.delete('/:id', async(req, res) =&gt; {\ntry {\nconst post = await Post.findOne({ _id: req.params.id })\nlet fileName = post.image_id;\nawait Post.deleteOne({ _id: req.params.id });\nawait files.find({filename: fileName}).toArray( async(err, docs) =&gt; {\nawait chunks.deleteMany({files_id : docs[0]._id});\n})\nawait files.deleteOne({filename: fileName});\nres.status(204).send()\n} catch {\nres.status(404)\nres.send({ error: \"Post does not exist!\" })\n}\n});\n\nmodule.exports = router;\n</code></pre> .env <pre><code>DB_CONNECTION = mongodb+srv://ikt-pwa.0elr1ih.mongodb.net/?authSource=%24external&amp;authMechanism=MONGODB-X509&amp;retryWrites=true&amp;w=majority\nDATABASE = htwinsta\nPATH_TO_PEM = assets/X509-cert-3298914405631471913.pem\nPORT = 3000\n</code></pre>"},{"location":"bilder/#zusammenfassung-die-mongodb-posts","title":"Zusammenfassung - die MongoDB <code>posts</code>","text":"<p>Hier einige Datens\u00e4tze f\u00fcr die Datenbank <code>posts</code>:</p> Collection posts <pre><code>{\"_id\":{\"$oid\":\"6278e79c6664ce70884dd0b0\"},\"title\":\"WH Eingang\",\"location\":\"Campus Wilhelminenhof\",\"image_id\":\"1652090780364-jf-htwbild4.jpg\",\"__v\":0}\n{\"_id\":{\"$oid\":\"627a0ff2305433d805b6b437\"},\"title\":\"HTW Geb\u00e4ude C\",\"location\":\"Campus Wilhelminenhof\",\"image_id\":\"1652166642127-jf-htwbild5.jpg\",\"__v\":0}\n{\"_id\":{\"$oid\":\"627a7cad8ae16b1ba5f62f76\"},\"title\":\"Mensastrand\",\"location\":\"Campus Wilhelminenhof Mensa\",\"image_id\":\"1652194477890-jf-htwbild1.jpg\",\"__v\":0}\n{\"_id\":{\"$oid\":\"627a7cdf8ae16b1ba5f62f80\"},\"title\":\"Wiese Campus WH\",\"location\":\"Campus Wilhelminenhof Geb\u00e4ude C\",\"image_id\":\"1652194527176-jf-htwbild2.jpg\",\"__v\":0}\n{\"_id\":{\"$oid\":\"627a7d0b8ae16b1ba5f62f84\"},\"title\":\"Ber\u00fchmt wegen FIW\",\"location\":\"Campus Wilhelminenhof Geb\u00e4ude C\",\"image_id\":\"1652194571822-jf-htwbild3.jpg\",\"__v\":0}\n{\"_id\":{\"$oid\":\"627a7d398ae16b1ba5f62f8b\"},\"title\":\"Haupttor HTW\",\"location\":\"Wilhelminenhofstra\u00dfe HTW\",\"image_id\":\"1652194617191-jf-htwbild4.jpg\",\"__v\":0}\n{\"_id\":{\"$oid\":\"627a7d608ae16b1ba5f62f8f\"},\"title\":\"Geb\u00e4ude C\",\"location\":\"HTW Berlin\",\"image_id\":\"1652194656102-jf-htwbild5.jpg\",\"__v\":0}\n</code></pre> Collection posts.files <pre><code>{\"_id\":{\"$oid\":\"6278d47e96a41858d66f1621\"},\"length\":984341,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T08:44:46.239Z\"},\"filename\":\"1652085886102-jf-htwbild1.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"6278d5f902370f2c675993e9\"},\"length\":1601800,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T08:51:05.478Z\"},\"filename\":\"1652086265414-jf-htwbild2.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"6278db738d2b5bc5968f453e\"},\"length\":1601800,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T09:14:27.957Z\"},\"filename\":\"1652087667872-jf-htwbild2.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"6278db918d2b5bc5968f4546\"},\"length\":1601800,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T09:14:57.113Z\"},\"filename\":\"1652087697071-jf-htwbild2.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"6278dd057c648b9e8e3bbb74\"},\"length\":117492,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T09:21:09.873Z\"},\"filename\":\"1652088069823-jf-htwbild3.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"6278e74458477bf1223fa286\"},\"length\":1038579,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T10:04:53.07Z\"},\"filename\":\"1652090692995-jf-htwbild4.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"6278e79c6664ce70884dd0ab\"},\"length\":1038579,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T10:06:20.437Z\"},\"filename\":\"1652090780364-jf-htwbild4.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"627a0ff2305433d805b6b435\"},\"length\":25449,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-10T07:10:42.191Z\"},\"filename\":\"1652166642127-jf-htwbild5.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"627a7cad8ae16b1ba5f62f71\"},\"length\":984341,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-10T14:54:37.954Z\"},\"filename\":\"1652194477890-jf-htwbild1.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"627a7cdf8ae16b1ba5f62f78\"},\"length\":1601800,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-10T14:55:27.23Z\"},\"filename\":\"1652194527176-jf-htwbild2.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"627a7d0b8ae16b1ba5f62f82\"},\"length\":117492,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-10T14:56:11.84Z\"},\"filename\":\"1652194571822-jf-htwbild3.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"627a7d398ae16b1ba5f62f86\"},\"length\":1038579,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-10T14:56:57.214Z\"},\"filename\":\"1652194617191-jf-htwbild4.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"627a7d608ae16b1ba5f62f8d\"},\"length\":25449,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-10T14:57:36.11Z\"},\"filename\":\"1652194656102-jf-htwbild5.jpg\",\"contentType\":\"image/jpeg\"}\n</code></pre> <p>Die Collection <code>posts.chunks</code> ist sehr gro\u00df, deshalb hier zum Download.</p>"},{"location":"caching/","title":"Caching mit Service Workern","text":"<p>Caching ist ein Konzept, um Ressourcen zu speichern, um sie nicht wieder vom Server laden zu m\u00fcssen. Browser verf\u00fcgen \u00fcber eigene Caches (\"Pufferspeicher\") und darin k\u00f6nnen Browser Bilder, CSS-Dateien, JavaScript-Dateien und andere Mediadateien (z.B. pdf) speichern, um diese nicht erneut vom Webserver laden zu m\u00fcssen. Das Caching beschleunigt das wiederholte Laden von Webseiten. </p> <p>Caching mit service workern verfolgt das gleiche Prinzip. Auch hier werden Ressourcen in einen Cache geladen. Der Vorteil hierbei ist jedoch nicht das schnellere Laden beim Wiederholen, sondern die M\u00f6glichkeit zu er\u00f6ffnen, die Webanwendung auch (teilweise) offline auszuf\u00fchren. Mit dem Service-Worker-Caching bieten wir somit die F\u00e4higkeit des Offline-Modus unserer Anwendung. Die Verwendung eines Caches durch einen service worker erfolgt mithilfe der Cache API.</p>"},{"location":"caching/#die-cache-api","title":"Die Cache API","text":"<p>Die Cache API verfolgt ein ganz simples Konzept. Mithilfe der Cache API werden einfach (Schl\u00fcssel-/Werte-)Paare von Requests und Responses  gespeichert. Auf den Cache (also auf die Menge aller gespeicherten Request-/Response-Paare) k\u00f6nnen sowohl service worker als auch das JavaScript der Webanwendung zugreifen. Allerdings kann es ja sein, dass das \"normale\" JavaScript der Webanwendung (noch) nicht geladen werden kann, weil z.B. die Internetverbindung zu schwach ist oder nicht vorhanden, ein service worker kann aber trotzdem bereits Daten aus dem Cache liefern, ohne \u00fcberhaupt einen Request \u00fcber das Internet zu senden. </p> <p>Wichtig ist noch zu betonen, dass die Cache API (noch) nicht von besonders vielen Browsern unterst\u00fctzt wird. Das sieht man hier, wenn Sie nach ganz unten scrollen. Im Prinzip funktioniert es nur (vollst\u00e4ndig) mit Chrome, Firefox und Opera.</p>"},{"location":"caching/#bereinigen-des-htw-insta-projektes","title":"Bereinigen des HTW-Insta-Projektes","text":"<p>Bevor wir unseren Service-Worker-Cache implementieren, bereinigen wir zun\u00e4chst noch unser HTW-Insta-Projekt. Aus der <code>public/src/js/app.js</code> entfernen wir den gesamten Code, der sich auf Promises und die Fetch API bezog. Die <code>app.js</code> sieht nun (wieder) so aus:</p> public/src/js/app.js <pre><code>if ('serviceWorker' in navigator) {\nnavigator.serviceWorker\n.register('/sw.js')\n.then(() =&gt; {\nconsole.log('service worker registriert')\n})\n.catch(\nerr =&gt; { console.log(err); }\n);\n}\n</code></pre> <p>In der <code>public/sw.js</code> (also in unserem service worker), l\u00f6schen wir die Ausgaben auf die Konsole f\u00fcr das <code>fetch</code>-Event. Stattdessen f\u00fcgen wir eine <code>respondWith()</code>-Funktion ein:</p> public/sw.js <pre><code>self.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\n})\n\nself.addEventListener('activate', event =&gt; {\nconsole.log('service worker --&gt; activating ...', event);\nreturn self.clients.claim();\n})\n\nself.addEventListener('fetch', event =&gt; {\nevent.respondWith(fetch(event.request));\n})\n</code></pre> <p>Die respondWith()-Funktion ist eine Funktion des <code>fetch</code>-Events (also <code>FetchEvent.respondWith()</code>). Sie sorgt einerseits daf\u00fcr, den Browser von seiner Standardbehandlung des <code>FetchEvents</code> abzuhalten und stattdessen eine eigene <code>Promise</code> f\u00fcr die Behandlung des <code>FetchEvents</code> zu definieren. Die Standardsyntax ist:</p> <pre><code>fetchEvent.respondWith(\n// Promise that resolves to a Response.\n);\n</code></pre> <p>Hier ist ein Beispiel f\u00fcr die <code>respondWith()</code>-Funktion aus:</p> <pre><code>addEventListener('fetch', event =&gt; {\n// Prevent the default, and handle the request ourselves.\nevent.respondWith(async function() {\n// Try to get the response from a cache.\nconst cachedResponse = await caches.match(event.request);\n// Return it if we found one.\nif (cachedResponse) return cachedResponse;\n// If we didn't find a match in the cache, use the network.\nreturn fetch(event.request);\n}());\n});\n</code></pre> <p>Darin wird f\u00fcr ein <code>fetch</code>-Event zun\u00e4chst gepr\u00fcft, ob der <code>request</code> im Cache vorhanden ist (Zeile <code>5</code>). Wenn ja, dann bekommt die Variable <code>cachedResponse</code> den Wert der <code>response</code> aus dem Cache (<code>match</code> liefert die <code>response</code> zum zugeh\u00f6rigen <code>request</code>). Wenn das der Fall ist, dann liefert <code>responseWith()</code> genau diese <code>response</code> aus dem Cache zur\u00fcck. Wenn der <code>request</code> nicht im Cache gespeichert ist, dann wird einfach der <code>event.request</code> weitergeleitet, also nichts aus dem Cache genommen. </p> <p>In unserer derzeitigen Implementierung (highlighted Zeile <code>11</code> oben), wird noch nicht auf den Cache zugegriffen, sondern der <code>request</code> direkt an den Webserver weitergeleitet. Sollten Sie daf\u00fcr einen Fehler bekommen, weil das <code>Promise</code> als nicht korrekt behandelt gilt, dann k\u00f6nnen Sie diese Zeile zun\u00e4chst auch einfach auskommentieren. </p> <p>Eine etwas gr\u00f6\u00dfere \u00c4nderung f\u00fchren wir in der <code>public/src/js/feed.js</code> durch. Wir f\u00fcgen statisch einen Blog-Eintrag hinzu. Die Anwendung sieht dann so aus:</p> <p></p> <p>Schauen Sie in die <code>index.html</code>. In das folgende <code>&lt;div id=\"shared-moments\"&gt;&lt;/div&gt;</code> f\u00fcgen wir eine Card der Form <code>&lt;div class=\"shared-moment-card mdl-card mdl-shadow--2dp\"&gt;&lt;/div&gt;</code> hinzu, welche das Foto und den Text enth\u00e4lt. Das passiert in einer Funktion <code>createCard()</code>:</p> public/src/js/feed.js <pre><code>let shareImageButton = document.querySelector('#share-image-button');\nlet createPostArea = document.querySelector('#create-post');\nlet closeCreatePostModalButton = document.querySelector('#close-create-post-modal-btn');\nlet sharedMomentsArea = document.querySelector('#shared-moments');\n\nfunction openCreatePostModal() {\ncreatePostArea.style.display = 'block';\n}\n\nfunction closeCreatePostModal() {\ncreatePostArea.style.display = 'none';\n}\n\nshareImageButton.addEventListener('click', openCreatePostModal);\n\ncloseCreatePostModalButton.addEventListener('click', closeCreatePostModal);\n\nfunction createCard() {\nlet cardWrapper = document.createElement('div');\ncardWrapper.className = 'shared-moment-card mdl-card mdl-shadow--2dp';\nlet cardTitle = document.createElement('div');\ncardTitle.className = 'mdl-card__title';\ncardTitle.style.backgroundImage = 'url(\"/src/images/htw-gebaeude-h.jpg\")';\ncardTitle.style.backgroundSize = 'cover';\ncardTitle.style.height = '180px';\ncardWrapper.appendChild(cardTitle);\nlet cardTitleTextElement = document.createElement('h2');\ncardTitleTextElement.className = 'mdl-card__title-text';\ncardTitleTextElement.textContent = 'Vor der HTW-Mensa';\ncardTitle.appendChild(cardTitleTextElement);\nlet cardSupportingText = document.createElement('div');\ncardSupportingText.className = 'mdl-card__supporting-text';\ncardSupportingText.textContent = 'HTW Berlin';\ncardSupportingText.style.textAlign = 'center';\ncardWrapper.appendChild(cardSupportingText);\ncomponentHandler.upgradeElement(cardWrapper);\nsharedMomentsArea.appendChild(cardWrapper);\n}\n\nfetch('https://jsonplaceholder.typicode.com/posts/1')\n.then((res) =&gt; {\nreturn res.json();\n})\n.then((data) =&gt; {\ncreateCard();\n});\n</code></pre> <p>Zun\u00e4chst wird in Zeile <code>4</code> auf das <code>div</code> mit der <code>id=\"shared-moments\"</code> zugegriffen. In dieses <code>div</code> wird die Card eingef\u00fcgt. Alles CSS-Klassen mit <code>mdl-</code> am Anfang sind Klassen von Material Design Ligt. F\u00fcr die CSS-Klasse <code>shared-moment-card</code> definieren wir in <code>public/src/css/feed.css</code> noch:</p> <pre><code>.shared-moment-card.mdl-card {\nmargin: 10px auto;\n}\n</code></pre> <p>so, dass die Card einen Abstand vom Rand bekommt. Interessant ist vielleicht noch die Zeile <code>36</code> <code>componentHandler.upgradeElement(cardWrapper);</code>. Mit dieser Funktion m\u00fcssen dynamisch erzeugte DOM-Elemente registriert werden, damit sie von Material Design Lite automatisch verwaltet werden. Siehe dazu Uses MDL on dynamic websites.</p>"},{"location":"caching/#ikt-pwa-03-bei-github","title":"IKT-PWA-03 bei GitHub","text":"<p>Das Bild htw-gebaeude-h.jpg muss auch noch dem <code>public/src/images</code>-Ordner hinzugef\u00fcgt werden. Die aktuelle Ausgangssituation unseres Projektes finden Sie hier.</p> <p>Achten Sie bitte darauf, dass Sie (zumindest so lange wir uns mit dem Service-Worker-Cache besch\u00e4ftigen) das H\u00e4kchen bei <code>Disable Cache</code> in den Developer Tools unter <code>Network</code> gesetzt haben: </p> <p></p>"},{"location":"caching/#was-soll-in-den-cache","title":"Was soll in den Cache?","text":"<p>Zun\u00e4chst \u00fcberlegen wir uns, was \u00fcberhaupt in den Cache soll und was nicht. Prinzipiell verfolgen wir mit dem Service-Worker-Cache die Idee, dass die Anwendung auch offline verwendbar bleiben soll. Wenn wir unsere aktuelle Anwendung betrachten, dann k\u00f6nnen wir unterscheiden zwischen </p> <ul> <li>\"statischen\" und </li> <li>\"dynamischen\" Inhalten.</li> </ul> <p>Statisch ist im Prinzip der Rahmen unserer Anwendung, also im prinzip alles, was wir hatten vor unserem ersten Blog-Eintrag. Dieser Rahmen gibt uns das Gef\u00fchl, dass die Anwendung \"l\u00e4uft\" - es fehlen nur die dynamischen Inhalte, also die Blog-Eintr\u00e4ge. Stattdessen k\u00f6nnte man aber eine Meldung ausgeben, dass diese Inhalte derzeit nicht verf\u00fcgbar sind. Das w\u00e4re alles jedenfalls besser als eine 404-Seite oder ein unendliches Warten oder das hier:</p> <p></p> <p>Der Rahmen einer Webanwendung wird auch App-Shell genannt. Wir wollen diese App-Shell  zun\u00e4chst in unseren Service-Worker-Cache speichern. </p>"},{"location":"caching/#static-cachingprecaching","title":"Static caching/Precaching","text":"<p>Wir wollen zun\u00e4chst die statischen Inhalte unserer Anwendung sin den Cache speichern. Dies geschieht beim Installieren (registrieren) des service workers. Das ist auch insofern praktisch, als dass der service worker ja nur dann neu registriert wird, wenn er ge\u00e4ndert wurde. Ansonsten bleibt einfach der \"alte\" existent. </p> <p>Ziel ist es also, zun\u00e4chst alles das in den Cache zu speichern, was unsere Webanwendung ausmacht:</p> <ul> <li>die <code>index.html</code>, </li> <li>alle <code>*.css</code>-Dateien, die mittels <code>&lt;link href=\"...\"&gt;</code> in dieser <code>index.html</code> einegunden werden, </li> <li>alle <code>*.js</code>-Dateien, die mittels <code>&lt;script src=\"...\"&gt;</code> in dieser <code>index.html</code> einegunden werden und </li> <li>alle <code>*.png</code>-Dateien, die mittels <code>&lt;link href=\"...\"&gt;</code> in dieser <code>index.html</code> einegunden werden.</li> </ul>"},{"location":"caching/#den-service-worker-cache-erstellen","title":"Den Service-Worker-Cache erstellen","text":"<p>Wir haben bereits eingangs festgelegt, dass wir den Cache in dem Moment anlegen wollen, in dem der service worker installiert wird. Das bedeutet, wir erstellen den Cache in der Ereignisbehandlung des Lebenszyklus-Event <code>install</code> des service workers, also hier (<code>sw.js</code>):</p> <pre><code>self.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\n// hier soll der Cache \"entstehen\"\n})\n</code></pre> <p>Den Service-Worker-Cache erstellen wir mithilfe der Anweisung <code>caches.open();</code>. Hierbei handelt es sich um eine Funktion von CacheStorage. Die Funktion <code>caches.open()</code> erzeugt ein <code>Cache</code>-Objekt, wenn es noch nicht existiert. Die R\u00fcckgabe (<code>response</code> der <code>Promise</code>) ist also ein <code>Cache</code>-Objekt. </p> <p>Man k\u00f6nnte nun annehmen, man schreibt einfach das hier:</p> <pre><code>self.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\ncaches.open();      // nicht gut!\n})\n</code></pre> <p>Diese Idee ist aber nicht so gut, da wir immer im Hinterkopf behalten m\u00fcssen, dass in einem service worker alles asynchron abgearbeitet wird. Das bedeutet, dass wir in diesem Fall bei der Baehandlung des <code>install</code>-Events zwei Anweisungen einfach \"antriggern\": die Ausgabe auf die Konsole (Zeile <code>2</code>) und das Erzeugen eines <code>Cache</code>-Objektes (Zeile <code>3</code>). Wie lange jedes einzelne braucht und wann etwas fertig ist, wissen wir nicht. Das bedeutet z.B. dass die Ereignisbehandlung des <code>install</code>-Events fertig ist, noch bevor die Ausgabe auf die Konsole und/oder das Erzeugen des <code>Cache</code>-Objektes abgeschlossen ist/sind. Das wiederum w\u00fcrde bedeuten, dass wir asynchron evtl. bereits <code>fetch</code>-Anfragen ausl\u00f6sen, noch bevor der <code>Cache</code> bereit ist. Um dieses Problem zu verhindern, betten wir die Erzeugung des <code>Cache</code>-Objektes in eine <code>event.waitUntil()</code>-Funktion ein. Erst wenn diese Funktion abgeschlossen ist, ist auch die Ereignisbehandlung des <code>install</code>-Events abgeschlossen (siehe auch hier). Das richtige Vorgehen ist also dieses:</p> <pre><code>self.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\nevent.waitUntil(\ncaches.open('static')\n.then( cache =&gt; {\nconsole.log('Service-Worker-Cache erzeugt und offen');\n})\n);\n})\n</code></pre> <p><code>caches.open()</code> erzeugt also ein <code>Promise</code>, dessen <code>response</code> der erzeugte <code>Cache</code> ist. Wir konsumieren diesen <code>Cache</code> und geben zun\u00e4chst nur eine Ausgabe auf der Konsole aus. </p> <p>Der Parameter <code>'static'</code> in <code>caches.open()</code> ist ein Name f\u00fcr den Cache. Die Namen sind frei w\u00e4hlbar und man kann verschiedene Namen vergeben. Das sind dann jeweils eine Art \"Unter\"-Caches (oder sub caches) im Service-Worker-Cache. </p>"},{"location":"caching/#eine-ressource-in-den-cache-speichern","title":"Eine Ressource in den Cache speichern","text":"<p>Nun kann der Cache entsprechend mit <code>request</code>-<code>response</code>-Schl\u00fcssel-Werte-Paaren bef\u00fcllt werden. Die auf den Cache anwenbaren Funktionen sind hier dokumentiert. Es sind <code>match(request, options)</code>,  <code>matchAll(request, options)</code>, <code>add(request)</code>, , <code>addAll(request)</code>, <code>put(request, response)</code>, <code>delete(request, options)</code> und , <code>keys(request, options)</code>. Alle liefern nat\u00fcrlich ein <code>Promise</code> zur\u00fcck. </p> <p>Um die statischen Inhalte unserer Webanwendung in den Cache zu laden, verwenden wir die <code>add(request)</code>-Funktion. Diese Funktion macht folgendes:</p> <ul> <li>sie f\u00fchrt den <code>request</code> aus (<code>fetch(request)</code>) und </li> <li>speichert die <code>response</code> (also die angefragte Ressource) \u2192 dieses Speichern entspricht einem <code>put(request, response)</code> im Cache.</li> </ul> <p>Wenn wir also folgendes implementieren:</p> <pre><code>self.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\nevent.waitUntil(\ncaches.open('static')\n.then( cache =&gt; {\nconsole.log('Service-Worker-Cache erzeugt und offen');\ncache.add('/src/js/app.js');    // relativ vom public-Ordner\n})\n);\n})\n</code></pre> <p>, dann wird beim Initialisieren des service workers die Ressource <code>public/src/js/app.js</code> beim Webserver angefragt und die <code>response</code>, also die <code>app.js</code> im Cache gespeichert. Wenn wir unsere Anwednung so ausf\u00fchren, dann sehen wir in den DeveloperTools im Reiter <code>Application</code> im <code>Cache Storage</code> den Cache <code>static</code> und darin die gespeicherte Ressource <code>/src/js/app.js</code>. </p> <p></p>"},{"location":"caching/#eine-ressource-aus-dem-cache-lesen","title":"Eine Ressource aus dem Cache lesen","text":"<p>Jetzt haben wir einen Ressource in den Cache geladen, aber wir verwenden sie noch nicht, da wir in der bisherigen Behandlung des <code>fetch</code>-Events den Cache noch nicht nutzen. Zur Erinnerung: bei der Behandlung des <code>fetch</code>-Events wirkt der service worker wie ein Proxy. Er \"schaltet\" sich zwischen die Webanwendung und die Anfrage dieser an den Webserver. In unserer derzeitigen Implementierung des <code>fetch</code>-Events wird der <code>request</code> einfach an den Webserver durchgeschleust, ohne irgendetwas damit zu tun. Das wollen wir nun \u00e4ndern:</p> <pre><code>self.addEventListener('fetch', event =&gt; {\nevent.respondWith(\ncaches.match(event.request)\n.then( response =&gt; {\nif(response) {\nreturn response;\n} else {\nreturn fetch(event.request);\n}\n})\n);\n})\n</code></pre> <p>Wir reagieren auf das <code>fetch</code>-Ereignis zun\u00e4chst mit der <code>respondWith()</code>-Funktion, die wir bereits oben besprochen haben. Diese Funktion verhindert die Ausf\u00fchrung des Standardverhaltens beim <code>fetch</code>, n\u00e4mlich die Anfrage an den Webserver. Stattdessen fragen wir mithilfe der <code>caches.match()</code>-Funktion alle sub caches unseres Caches nach dem als Parameter \u00fcbergebenen <code>request</code> an. Im Cache sind die Eintr\u00e4ge als Schl\u00fcssel-Werte-Paare <code>request</code>-<code>response</code> abgespeichert. Findet sich der <code>request</code> im Cache, dann liefert die <code>Promise</code> ein <code>response</code>-Objekt zur\u00fcck. Wenn das so ist (Zeile <code>5</code>), dann geben wir dieses <code>response</code>-Objekt an die Webanwendung zur\u00fcck (Zeile <code>6</code>). Das ist dann also die aus dem Cache geladene Ressource. </p> <p>Wenn die <code>match()</code>-Funktion jedoch den Schl\u00fcssel <code>request</code> nicht im Cache gefunden hat (und somit auch keine <code>response</code>), gibt sie zwar trotzdem ein <code>Promise</code> zur\u00fcck, aber dann ist die <code>response</code> <code>null</code>. Das bedeutet, dass die <code>if</code>-Abfrage in Zeile <code>5</code> ein <code>false</code> zur\u00fcckgibt und wir somit Zeile <code>8</code> ausf\u00fchren. Darin wird die Anfrage einfach an den Webserver weitergeleitet, die Ressource also vom Webserver geladen.</p> <p>Wir \u00fcberpr\u00fcfen die Funktionalit\u00e4t dieser <code>fetch</code>-Ereignisbehandlung:</p> <p></p> <p>Unter dem Reiter <code>Network</code> in den DeveloperTools sehen wir, dass die <code>app.js</code> durch den Service Worker geladen wurde. Alle anderen Ressourcen wurden auch durch den Service Worker geladen, das liegt daran, dass wir im Service Worker die Anfrage an den Webserver durch den Service Worker durchschleusen. Wichtig ist aber, dass die <code>app.js</code> nicht vom Webserver geladen wurde. Das erkennen war daran, dass alle anderen Ressourcen mit ihren Gr\u00f6\u00dfenangaben in der Tabelle stehen und dass damit gesagt, wurde, wieviel Bytes vom Webserver geladen wurden. Die <code>app.js</code> taucht dabei aber nicht auf. Sie wurde durch den Service Worker aus dem Service-Worker-Cache (<code>Cache Storage</code>) geladen!</p> <p>Okay, das ist jetzt vielleicht noch nicht besonders eindrucksvoll, weil der Offline-Modus f\u00fcr unsere Webanwendung noch nicht funktioniert und wir bis jetzt nur die <code>app.js</code> in den Cache speichern und von dort bei einem <code>fetch()</code> laden. Dadurch sieht man noch nicht wirklich viel. Deshalb laden wir jetzt den statischen \"Rest\", insbesondere die <code>index.html</code> und die dazugeh\u00f6rigen <code>*.css</code>-Dateien. Zuvor jedoch noch eine kurze Anmerkung zu den Schl\u00fcssel-Werte-Paaren <code>request</code> und <code>response</code> im Cache:</p>"},{"location":"caching/#schlussel-werte-paare-request-und-response","title":"Schl\u00fcssel-Werte-Paare <code>request</code> und <code>response</code>","text":"<p>Wir laden jetzt unsere <code>index.html</code>-Datei in den Cache:</p> <pre><code>self.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\nevent.waitUntil(\ncaches.open('static')\n.then( cache =&gt; {\nconsole.log('Service-Worker-Cache erzeugt und offen');             cache.add('/index.html');\ncache.add('/src/js/app.js');    // relativ vom public-Ordner\n})\n);\n})\n</code></pre> <p>Wenn wir unsere Anwendung neu starten und den service worker erneut registrieren, dann sollte jetzt die <code>index.html</code> im Offline-Modus angezeigt werden (wenn auch ohne die CSS-Styles). Allerdings sieht die Anwendung nach dem Reload im Offline-Modus leider so aus wie auf der linken Seite der folgenden Abbildung gezeigt:</p> <p></p> <p>Der Grund daf\u00fcr ist, dass wir die Anwendung mit <code>localhost:8080</code> (oder <code>127.0.0.1:8080</code>) aufrufen, der <code>request</code> also <code>/</code> ist. Im Cache gespeichert haben wir aber den <code>request</code> <code>/index.html</code>. Und tats\u00e4chlich, wenn wir <code>localhost:8080/index.html</code> (oder <code>127.0.0.1:8080/index.html</code>) aufrufen, dann wird der <code>request</code> <code>/index.html</code> im Cache gefunden und als <code>response</code> die <code>index.html</code> zur\u00fcckgegeben (rechte Seite in der Abbildung). Wichtig ist also, dass wir bedenken, dass alle <code>requests</code>, f\u00fcr die wir <code>responses</code> im Cache hinterlegen wollen, auch tats\u00e4chlich in den Cache hinzugef\u00fcgt werden. Unsere <code>sw.js</code> sollte also auch so aussehen:</p> <pre><code>self.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\nevent.waitUntil(\ncaches.open('static')\n.then( cache =&gt; {\nconsole.log('Service-Worker-Cache erzeugt und offen'); cache.add('/');            cache.add('/index.html');\ncache.add('/src/js/app.js');    // relativ vom public-Ordner\n})\n);\n})\n</code></pre> <p>Dann erhalten wir auch das rechte Bild der Abbildung beim Aufruf von <code>localhost:8080</code> (oder <code>127.0.0.1:8080</code>) im Offline-Modus. Wir sollten also beachten, dass alle <code>requests</code>, die wir cachen wollen, auch tats\u00e4chlich in den Cache gespeichert werden.</p>"},{"location":"caching/#alle-statischen-ressourcen-in-den-cache-laden","title":"Alle statischen Ressourcen in den Cache laden","text":"<p>Wir laden jetzt alle statischen Ressourcen in den Cache, d.h. alles, was notwendig ist, um unsere Webanwendung auch im Offline-Modus so aussehen zu lassen, als w\u00fcrde sie \"laufen\". Dazu geh\u00f6rt nat\u00fcrlich die <code>index.html</code> und dann noch alle Ressourcen, die in der <code>index.html</code> eingebunden werden, also einige <code>*.js</code>-Dateien, einige <code>*.css</code>-Dateien und das Bild, das oben in der Webanwendung erscheint. </p> <p>Man k\u00f6nnte das alles mit einzelnen <code>cache.add()</code>-Funktionen erledigen, so wie oben. Daf\u00fcr gibt es aber auch die <code>cache.addAll()</code>-Funktion, der ein Array aus lauter <code>requests</code> \u00fcbergeben wird. Die Implementierung der <code>install</code>-Ereignisbehandlung in unserer <code>sw.js</code> sieht dann so aus:</p> <pre><code>self.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\nevent.waitUntil(\ncaches.open('static')\n.then( cache =&gt; {\nconsole.log('Service-Worker-Cache erzeugt und offen'); cache.addAll([\n'/',\n'/index.html',\n'/src/js/app.js',\n'/src/js/feed.js',\n'/src/js/material.min.js',\n'/src/css/app.css',\n'/src/css/feed.css',\n'/src/images/htw.jpg',\n'https://fonts.googleapis.com/css?family=Roboto:400,700',\n'https://fonts.googleapis.com/icon?family=Material+Icons',\n'https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css'\n]);\n})\n);\n})\n</code></pre> <p>Wenn wir nun unsere Anwendung neu starten und darauf achten, dass der neue Service Worker auch wirklich registriert wird und dann in den Offline-Modus schalten, dann sieht unsere Anwendung so aus:</p> <p></p> <p>Wie auf der rechten Seite der Abbildung zu sehen ist, funktioniert auch das JavaScript, um zum Formular zu gelangen. Einige Sachen funktionieren im Offline-Modus nicht, weil wir sie nicht in den Cache geladen haben:</p> <ul> <li>die Hilfeseite (<code>/help/index.html</code> und die dazugeh\u00f6rige <code>help.css</code>) sowie</li> <li>den Blogeintrag, den wir bereits (statisch) vorgenommen haben (den binden wir gleich noch dynamisch ein).</li> </ul> <p>Eine andere Sache f\u00e4llt aber vielleicht auf: die Icons von Material Design Lite erscheinen nicht, d.h. das Men\u00fc links oben ist nur ein leeres Quadrat und auf dem roten runden Button fehlt das Plus, stattdessen steht dort <code>add</code>. </p> <p>Wenn wir diesem Problem nachgehen, dann sehen wir in den DeveloperTools unter dem Reiter <code>Network</code>, dass alle Ressourcen, die wir im Cache gespeichert haben, auch tats\u00e4chlich aus diesem Cache geladen werden:</p> <p></p> <p>Zus\u00e4tzlich schlagen aber noch \"kryptische\" GET-Anfragen fehl (die roten ganz unten in der Abbildung). Hier werden offensichtlich noch Anfragen an den Webserver gestellt, von denen wir gar nichts wussten und die wir nicht im Cache vorhalten. Wo kommen diese Anfragen her? Wenn wir dort in den DeveloperTools bspw. auf die Ressource <code>https://fonts.googleapis.com/icon?family=Material+Icons</code> klicken, dann erscheint daneben der Inhalt der geladenen Ressource und wir finden darin einen weiteren <code>request</code>, den wir aber nicht in unserem Cache hinterlegt haben (weil wir es gar nicht wussten):</p> <p></p> <p>Diese Anfragen schlagen im Offline-Modus (nat\u00fcrlich) fehl und deshalb fehlen uns die Material Design Icons. Gut w\u00e4re es, wenn solche dynamischen Anfragen ebenfalls im Cache landen w\u00fcrden. Mit diesem dynamischen Caching besch\u00e4ftigen wir uns deshalb jetzt:</p>"},{"location":"caching/#dynamisches-caching","title":"Dynamisches Caching","text":"<p>Bis jetzt haben wir mit <code>cache.add()</code> bzw. <code>cache.addAll()</code> vorab festgelegt, was in den Cache geladen werden soll. Das wird statisches Caching oder pre-caching genannt. Jetzt k\u00fcmmern wir uns um sogenanntes dynamisches Caching. Manchmal m\u00f6chte man gar nicht schon gleich zu Beginn alles in den Cache laden, um die \"Installation\", das erstmalige Aufrufen der Seite nicht zu aufw\u00e4ndig und somit zu langsam zu gestalten. Manchmal kennt man aber auch gar nicht die Ressourcen, die man noch zum Cache hinzuf\u00fcgen m\u00f6chte, wie das obere Beispiel gezeigt hat, als wir die Material Icons nicht in den Cache geladen haben, weil wir diese Anfrage vorab gar nicht kannten. </p>"},{"location":"caching/#die-behandlung-des-fetch-events-erweitern","title":"Die Behandlung des fetch-Events erweitern","text":"<p>Wir schauen uns zun\u00e4chst nochmal die aktuelle Behandlung des <code>fetch</code>-Events im service worker an:</p> <pre><code>self.addEventListener('fetch', event =&gt; {\nevent.respondWith(\ncaches.match(event.request)\n.then( response =&gt; {\nif(response) {\nreturn response;\n} else {\nreturn fetch(event.request);\n}\n})\n);\n})\n</code></pre> <p>Zur Erinnerung: mit dieser Behandlung schalten wir uns zwischen die Abfrage der Webseite an den Webserver. Diese Behandlung wirkt wie ein Proxy. Bei jeder Anfrage der Webseite an den Webserver wird diese Implementierung des <code>fetch</code>-Events aufgerufen. Wir erwidern den <code>request</code> mit einer <code>response</code>. </p> <p>Entweder kommt diese <code>response</code> aus dem Cache, n\u00e4mlich dann, wenn <code>caches.match(event.request)</code> eine <code>response</code> zur\u00fcckgibt. In diesem Fall wird die <code>response</code> zur\u00fcck an die Webseite geschickt und der Webserver wird gar nicht mehr weiter angefragt. </p> <p>Oder wir leiten die Anfrage tats\u00e4chlich an den Webserver weiter (<code>return fetch(event.request);</code>), n\u00e4mlich dann, wenn der <code>event.request</code> nicht als Schl\u00fcssel im Cache verf\u00fcgbar ist und dieser deshalb keine <code>response</code> zur\u00fcckgibt. An dieser Stelle f\u00fcgen wir nun unser dynamisches Caching ein. Der Webserver wird mit einer <code>response</code> antworten und wir werden diese <code>response</code> in unseren Cache laden. </p> <p>Dazu ben\u00f6tigen wir zwei Dinge:</p> <ol> <li>einen neuen, weiteren Cache, in dem wir den entsprechenden <code>request</code> und die <code>response</code> des Webservers speichern und</li> <li>die <code>cache.put()</code>-Anweisung. <code>put()</code> unterscheidet sich von <code>add()</code> dahingehend, dass <code>add()</code> nur einen Parameter ben\u00f6tigt, n\u00e4mlich den <code>request</code> und die <code>response</code> automatisch als ein Schl\u00fcssel-Werte-Paar (<code>request, response</code>) speichert, w\u00e4hrend <code>put()</code> beide Werte als Schl\u00fcssel-Werte-Paar speichert, d.h. zwei Parameter erwartet (<code>request</code>, <code>response</code>).</li> </ol> <p>Ein erster Implementierungsversuch sieht so aus: </p> <pre><code>} else {\nreturn fetch(event.request)\n.then( res =&gt; {             // nicht erneut response nehmen, haben wir schon\ncaches.open('dynamic')      // neuer, weiterer Cache namens dynamic\n.then( cache =&gt; {\ncache.put(event.request.url, res);      // hier die put-Anweisung\n})\n});\n}\n</code></pre> <p>Die Zeilen <code>9-14</code> sind hinzugekommen. Die <code>fetch()</code>-Anweisung ist ein Promise, deshalb f\u00fcgen wir ein <code>.then()</code> an. Die <code>response</code> m\u00fcssen wir jetzt anders nennen, da es die Variable <code>response</code> ja bereits gibt und es jetzt um die <code>response</code> des Webservers geht, also nennen wir sie <code>res</code> (kann nat\u00fcrlich auch anders hei\u00dfen). Dann \u00f6ffnen wir einen neuen Cache, den wir <code>dynamic</code> nennen - kann auch anders hei\u00dfen. Wenn der Cache noch nicht existiert, wird er durch <code>open()</code> erstellt. <code>open()</code> ist wiederum ein Promise, so dass wir <code>.then()</code> ankn\u00fcpfen k\u00f6nnen und f\u00fcgen in den Cache mithilfe von <code>put()</code> das Schl\u00fcssel-Werte-Paar (<code>event.request.url, res</code>) ein. </p> <p>Das w\u00e4re schon fast korrekt, aber es fehlt noch, dass wir die Response <code>res</code> nat\u00fcrlich an die Webseite zur\u00fcckgeben wollen. Dazu f\u00fcgen wir einerseits <code>return res;</code> ein, m\u00fcssen aber auch daf\u00fcr sorgen, dass die <code>res</code> auch an den <code>fetch()</code>-Aufruf zur\u00fcckgegeben wird. Dehalb ben\u00f6tigen wir auch vor <code>caches.open()</code> noch ein <code>return</code>. </p> <p>Au\u00dferdem m\u00fcssen wir noch einen weiteren Aspekt beachten. Wenn eine Response verwendet wird, wird sie konsumiert, d.h. verbraucht. Das ist so f\u00fcr Responses, auch wenn es nicht so wirklich nachvollziehbar und verst\u00e4ndlich ist. Wir verwenden in unserem Code zwei Mal <code>res</code>, einmal um es in den Cache zu speichern und ein anderes Mal, um es an die Webseite zur\u00fcckzugeben. In einer der beiden Verwendungen w\u00fcrde unsere <code>res</code> verbraucht/konsumiert werden und das andere Mal w\u00e4re sie leer. Kein Ahnung, warum das so ist ;-) . Aber wir ben\u00f6tigen an einer der beiden Stellen ein <code>res.clone()</code>, um den Clone der Response zu verwenden und die Response nicht zu \"verbrauchen\". Wir speichern den Clone der Response in den Cache (wir k\u00f6nnten auch die <code>res</code> in den Cache speichern und <code>res.clone()</code> zur\u00fcckgeben). </p> <p>Die gesamte Implementierung sieht dann so aus: </p> <pre><code>self.addEventListener('fetch', event =&gt; {\nevent.respondWith(\ncaches.match(event.request)\n.then( response =&gt; {\nif(response) {\nreturn response;\n} else {\nreturn fetch(event.request)\n.then( res =&gt; {     // nicht erneut response nehmen, haben wir schon\nreturn caches.open('dynamic')      // neuer, weiterer Cache namens dynamic\n.then( cache =&gt; {\ncache.put(event.request.url, res.clone());\nreturn res;\n})\n});\n}\n})\n);\n})\n</code></pre> <p>Wenn wir nun die Anwendung ausf\u00fchren ( <code>npm start</code>), dann in den <code>Offline</code>-Modus gehen und ein <code>Reload</code> im Browser durchf\u00fchren, sehen wir, dass die Material-Icons nun auch im Offline-Modus vorhanden sind:</p> <p></p> <p>Wenn wir uns in den DeveloperTools unter <code>Application</code> auf der linken Seite unter <code>Cache</code> den <code>Cache Storage</code> anschauen, dann sehen wir, dass dort nun 2 Caches sind, der <code>static</code> und der <code>dynamic</code> Cache. </p> <p></p> <p>In dem <code>dynmic</code> Cache finden wir nun auch die Material Icons wieder</p> <p></p> <p>und unter dem <code>Network</code>-Reiter gibt es auch keine \"Fehler\" mehr, sondern alle Ressourcen werden vom Service Worker aus dem Cache geladen:</p> <p></p> <p>Als weiteres Zeichen, dass nun alle Inhalte dynamisch geladen werden, erkennen wir auch die \"Mensa-Card\" in unserer Anwendung im Offline-Modus. Diese hatten wir ja statisch nicht hinzugef\u00fcgt. Probieren Sie auch einmal die \"Hilfe-Seite\" der Anwendung aus. Im Offline-Modus ist sie noch nicht verf\u00fcgbar. Wenn wir aber wieder online gehen, die \"Hilfe-Seite\" aufrufen und dann wieder offline gehen, ist die Hilfe-Seite im Cache und wird angezeigt. </p>"},{"location":"caching/#chromewebrequest-api","title":"chrome.webRequest-API","text":"<p>Der Chromium-Browser hat eine eigene API f\u00fcr Requests und schaltet sich bei Anfragen selbst dazwischen, um den Traffic zu analysieren und eventuelle Anfragen zu blockieren. Auch diese Anfragen l\u00f6sen ein <code>fetch</code>-Event aus. Allerdings gibt es bei von Chromium ausgel\u00f6sten Requests in dem <code>request</code> keine <code>url</code>-Eigenschaft. Vielleicht haben Sie einen solchen Fehler auch in Ihren DeveloperTools entdeckt. Eine Chromium-Anfrage unterscheidet sich von einer \"normalen\" Anfrage der Webseite an den Webserver dadurch, dass in einer \"normalen\" Anfrage die angefragte Ressource unter \"<code>htttp://...</code>\", also unter einer URL verf\u00fcgbar ist. Um nun den fehlerhaften Zugriff auf die <code>url</code>-Eigenschaft von <code>request</code> bei einer Anfrage durch Chrome zu vermeiden, f\u00fcgen wir ganz am Anfang der Ereignisbehandlung des <code>fetch</code>-Events noch die Abfrage ein, ob der <code>request</code> das Wort \"<code>http</code>\" enth\u00e4lt. Wenn nicht, verlassen wir die Behandlung des Events einfach:</p> <pre><code>self.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (!(event.request.url.indexOf('http') === 0)) return; // skip the request if request is not made with http protocol\nevent.respondWith(\ncaches.match(event.request)\n.then( response =&gt; {\nif(response) {\nreturn response;\n} else {\nreturn fetch(event.request)\n.then( res =&gt; {     // nicht erneut response nehmen, haben wir schon\nreturn caches.open('dynamic')      // neuer, weiterer Cache namens dynamic\n.then( cache =&gt; {\ncache.put(event.request.url, res.clone());\nreturn res;\n})\n});\n}\n})\n);\n})\n</code></pre>"},{"location":"caching/#versionierung-von-caches","title":"Versionierung von Caches","text":"<p>Wir haben nun sowohl statisch als auch dynamisch Ressourcen unserer Webanwendung geladen. Wenn wir eine Weile auf unserer Anwendung navigieren, laden wir nach und nach alle Ressourcen in den Cache, die unsere Anwendung ausmachen. Irgendwann k\u00f6nnen wir sie komplett offline betreiben. Alle Ressourcen sind im Cache und keine Ressourcen werden mehr vom Webserver geladen. </p> <p>Was passiert aber, wenn wir etwas \u00e4ndern? Wenn wir den Service worker <code>sw.js</code> \u00e4ndern, dann k\u00f6nnen wir daf\u00fcr sorgen, dass er neu geladen wird. Der Service worker darf auch niemals in den Cache geladen werden, denn dann h\u00e4tten wir eine unendliche Schleife, die immer wieder Ressourcen in den Cache l\u00e4dt! Wenn wir irgendeine andere Datei, eine <code>*.html</code>-, <code>*.css</code>- oder <code>*.js</code>-Datei \u00e4ndern, dann wird diese nie mehr in ihrer aktuellen Version vom Webserver geladen, da sie ja bereits im Cache ist und deshalb immer (in ihrer alten Version) aus dem Cache geladen wird. Um dieses problem zu beheben, versionieren wir unsere Caches.</p>"},{"location":"caching/#neue-cache-versionen-erstellen","title":"Neue Cache-Versionen erstellen","text":"<p>Eine neue \"Version\" eines Caches erstellen wir dadurch, dass wir einen neuen Cache mit anderem Namen erstellen. Unsere beiden Caches (der statische und der dynamische) werden jeweils im Service Worker (<code>sw.js</code>) benannt:</p> aktueller Stand sw.js <pre><code>self.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\nevent.waitUntil(\ncaches.open('static')\n.then( cache =&gt; {\nconsole.log('Service-Worker-Cache erzeugt und offen');\ncache.addAll([\n'/',\n'/index.html',\n'/src/js/app.js',\n'/src/js/feed.js',\n'/src/js/material.min.js',\n'/src/css/app.css',\n'/src/css/feed.css',\n'/src/images/htw.jpg',\n'https://fonts.googleapis.com/css?family=Roboto:400,700',\n'https://fonts.googleapis.com/icon?family=Material+Icons',\n'https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css'\n]);\n})\n);\n})\n\nself.addEventListener('activate', event =&gt; {\nconsole.log('service worker --&gt; activating ...', event);\nreturn self.clients.claim();\n})\n\nself.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (!(event.request.url.indexOf('http') === 0)) return; // skip the request. if request is not made with http protocol\n\nevent.respondWith(\ncaches.match(event.request)\n.then( response =&gt; {\nif(response) {\nreturn response;\n} else {\nreturn fetch(event.request)\n.then( res =&gt; {     // nicht erneut response nehmen, haben wir schon\nreturn caches.open('dynamic')      // neuer, weiterer Cache namens dynamic\n.then( cache =&gt; {\ncache.put(event.request.url, res.clone());\nreturn res;\n})\n});\n}\n})\n);\n})\n</code></pre> <p>Mit wechselndem Namen wechseln wir auch die \"Version\" des Caches. Wenn wir die Implementierung des statischen Service Workers (mit dem dynamischen ist es gleich, wir zeigen es hier zun\u00e4chst nur f\u00fcr den statischen) in der Zeile <code>4</code> bespielsweise auf </p> <pre><code> caches.open('static-v1')\n</code></pre> <p>\u00e4ndern, ensteht ein neuer zus\u00e4tzlicher Caches <code>static-v1</code>. Mit solchen \"Versionierungen\" erreichen wir, dass der Service Worker neu ausgef\u00fchrt und somit wirksam wird. Ge\u00e4nderte Dateien gelangen so neu in diesen neuen Caches. </p> <p></p> <p>Leider bleiben aber auch die alten Caches noch bestehen und die Funktion <code>caches.match()</code> sucht in allen Caches nach dem passenden Request. Die \u00c4nderungen w\u00e4ren dann also trotzdem noch nicht sichtbar. Wir m\u00fcssen jetzt noch daf\u00fcr sorgen, dass die \"alten\" Caches gel\u00f6scht werden. </p> <p>Um uns zu \u00fcberlegen, an welcher Stelle ein geeigneter Platz w\u00e4re, die alten Caches zu l\u00f6schen, hier nochmal eine kurze Wiederholung des Service-Worker-Lifecycles: </p> <ul> <li>install: Das <code>install</code>-Ereignis ist das erste Ereignis, das ein Service Worker ausl\u00f6st. Es wird genau einmal ausgel\u00f6st. Die Promise in <code>installEvent.waitUntil()</code> gibt Auskunft dar\u00fcber, ob das Installieren des Service Workers erfolgreich war oder nicht. So lange der Service Worker installiert wird, kann er keine <code>fetch</code>-Ereignisse empfangen und behandeln. </li> <li>activate: Sobald die Installation erfolgreich abgeschlossen ist, wird das <code>activate</code>-Ereignis ausgel\u00f6st. </li> <li>waiting: Wenn ein Service Worker <code>activated</code> ist, d.h. das <code>activate</code>-Event f\u00fcr diesen Service Worker ausgel\u00f6st wurde, kontrolliert er die Anfragen der Webseite (insb. wenn <code>clients.claim()</code> ausgef\u00fchrt wurde, was dazu f\u00fchrt, dass auch alle Unterseiten der Seite \"kontrolliert\" werden). Wird der Service Worker ge\u00e4ndert (aktualisiert) und erneut installiert, kann der ge\u00e4nderte Service Worker nicht sofort in den <code>activated</code> Zustand \u00fcbergehen, so lange ein anderer Service Worker <code>active</code> ist. Der aktualisierte Service Worker ist dann <code>waiting</code>.</li> </ul> <p></p> <p>Das Bild zeigt einen aktualisierten Service Worker (<code>#877</code>) <code>waiting</code> solange der Service Worker <code>#875</code> noch <code>activated</code> ist. Erst, wenn <code>skipWaiting</code> geklickt wird (<code>self.skipWaiting()</code>), wird der aktualisierte Service Worker <code>activated</code>. </p> <p>Ein guter Punkt, existierende Caches zu l\u00f6schen, die man nicht mehr verwenden m\u00f6chte, ist, wenn ein (neuer/aktualisierter) Service Worker <code>activated</code> ist. Wir erweitern also die behandlung des <code>activate</code>-Ereignisses:</p> <pre><code>self.addEventListener('activate', event =&gt; {\nconsole.log('service worker --&gt; activating ...', event);\nevent.waitUntil(\ncaches.keys()\n.then( keyList =&gt; {\nreturn Promise.all(keyList.map( key =&gt; {\nif(key !== 'static-v1' &amp;&amp; key !== 'dynamic') {\nconsole.log('service worker --&gt; old cache removed :', key);\nreturn caches.delete(key);\n}\n}))\n})\n);\nreturn self.clients.claim();\n})\n</code></pre> <p>Die ersten beiden und die letzten beiden Zeilen hatten wir bereits. Zeilen <code>3-13</code> sind neu. Betrachten wir den Code genauer:</p> <ul> <li>Die Funktion <code>waitUntil()</code> (Zeile <code>4</code>) gibt es sowohl f\u00fcr das <code>install</code>-Event als auch f\u00fcr das <code>activate</code>-Ereignis. Dieser Funktion wird ein Promise \u00fcbergeben. Wir \u00fcbergeben als Promise die Funktion <code>caches.keys()</code> (Zeile <code>5</code>).</li> <li><code>caches.keys</code> gibt alle Namen der Service-Worker-Caches als Schl\u00fcssel zur\u00fcck. In unserem Fall also <code>static</code>, <code>static-v1</code> und <code>dynamic</code>. </li> <li>die Funktion <code>Promise.all()</code> wird, verwendet, wenn auf ein Array von Promises \"gewartet\" werden soll. Die Funktion ist also dann beendet, wenn alle Promises des Arrays beendet sind. </li> <li><code>Promise.all()</code> wartet auf ein Array von Promises. Wir haben aber mit <code>keyList</code> \"nur\" ein Array von Strings (die Namen der Caches). Mithilfe der <code>map()</code>-Funktion wandeln wir dieses Array von Strings in ein Array von Promises um. </li> <li>die <code>map</code>-Funktion nimmt nun jeden einzelnen String aus dem Array <code>keyList</code> und \"macht\" damit etwas (Zeilen <code>7-10</code>)</li> <li>es wird gepr\u00fcft, ob der <code>key</code> entweder dem dynamischen Cache entspricht (<code>'dynamic'</code>) oder dem neuen statischen Cache (<code>'static-v1'</code>). Wenn das nicht der Fall ist, dann wird der Cache mit dem Namen <code>key</code> gel\u00f6scht (Zeile <code>9</code>).</li> <li><code>return caches.delete(key)</code> gibt somit ein Promise zur\u00fcck (an die <code>map</code>-Funktion). Somit wird jeder Schl\u00fcssel aus der <code>keyList</code> in ein Promise umgewandelt (f\u00fcr <code>static-v1</code> und <code>dynamic</code> wird <code>null</code> zur\u00fcckgegeben). </li> <li>wenn alle dieses Promises beendet sind, ist auch die <code>Promise.all()</code>-Funktion beendet und somit auch die <code>event.waitUntil()</code>-Funktion.</li> </ul> <p>Somit l\u00f6schen wir alle \"alten\" statischen Caches und behalten nur die Caches <code>static-v1</code> und <code>dynamic</code>. </p> <p></p> <p>Wenn wir also etwas in unseren <code>*.html</code>, <code>*.css</code> und/oder <code>*.js</code>-Dateien \u00e4ndern und das Ge\u00e4nderte wirksam werden lassen wollen, \u00e4ndern wir einfach die Namen der Caches im Service Worker und sobald der Service Worker aktiviert ist, existieren nur noch die neuen Caches und die alten sind gel\u00f6scht. Damit wir das an zentraler Stelle im <code>sw.js</code> machen, lagern wir die aktuellen Namen der Caches in Konstanten aus. Die vollst\u00e4ndige Implementierung unseres Service Workers sieht so aus:</p> <pre><code>const CURRENT_STATIC_CACHE = 'static-v2';\nconst CURRENT_DYNAMIC_CACHE = 'dynamic-v2';\n\nself.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\nevent.waitUntil(\ncaches.open(CURRENT_STATIC_CACHE)\n.then( cache =&gt; {\nconsole.log('Service-Worker-Cache erzeugt und offen');\ncache.addAll([\n'/',\n'/index.html',\n'/src/js/app.js',\n'/src/js/feed.js',\n'/src/js/material.min.js',\n'/src/css/app.css',\n'/src/css/feed.css',\n'/src/images/htw.jpg',\n'https://fonts.googleapis.com/css?family=Roboto:400,700',\n'https://fonts.googleapis.com/icon?family=Material+Icons',\n'https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css'\n]);\n})\n);\n})\n\nself.addEventListener('activate', event =&gt; {\nconsole.log('service worker --&gt; activating ...', event);\nevent.waitUntil(\ncaches.keys()\n.then( keyList =&gt; {\nreturn Promise.all(keyList.map( key =&gt; {\nif(key !== CURRENT_STATIC_CACHE &amp;&amp; key !== CURRENT_DYNAMIC_CACHE) {\nconsole.log('service worker --&gt; old cache removed :', key);\nreturn caches.delete(key);\n}\n}))\n})\n);\nreturn self.clients.claim();\n})\n\nself.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (!(event.request.url.indexOf('http') === 0)) return; // skip the request. if request is not made with http protocol\n\nevent.respondWith(\ncaches.match(event.request)\n.then( response =&gt; {\nif(response) {\nreturn response;\n} else {\nreturn fetch(event.request)\n.then( res =&gt; {     // nicht erneut response nehmen, haben wir schon\nreturn caches.open(CURRENT_DYNAMIC_CACHE)      // neuer, weiterer Cache namens dynamic\n.then( cache =&gt; {\ncache.put(event.request.url, res.clone());\nreturn res;\n})\n});\n}\n})\n);\n})\n</code></pre>"},{"location":"caching/#zusammenfassung","title":"Zusammenfassung","text":"<p>Die Zusammanfassung f\u00fcr das Caching kann man im folgenden Bild darstellen. </p> <p></p> <p>Mithilfe des Caching haben wir es geschafft, dass unsere Anwendung im Offline-Modus nicht mehr so aussieht, wie links, sondern wie rechts. Toll!</p> <p>Noch einige n\u00fctzliche Links:</p> <ul> <li>Service Worker API</li> <li>The offline cookbook</li> <li>Google: Service Worker</li> </ul>"},{"location":"einfuehrung/","title":"Einf\u00fchrung","text":"<p>In diesem Semester geht es um Progressive Web Apps (PWA). PWA sind Funktionen, die wir Webanwendungen hinzuf\u00fcgen k\u00f6nnen, um sie in ihrer Funktionalit\u00e4t zu erweitern. Die so werweiterten Webanwendungen kommen mit solchen Funktionen nativen Apps immer n\u00e4her, d.h. das Look and Feel gleicht sich mit PWAs nativen Apps an. Dazu geh\u00f6ren Funktionalit\u00e4ten, wie z.B. </p> <ul> <li>die M\u00f6glichkeit, die Webanwendung auch offline zu verwenden,</li> <li>die Kamera zu nutzen, </li> <li>den eigenen Standort zu verwenden, </li> <li>Daten im Hintergrund zu synchronisieren. </li> </ul> <p>Das bedeutet aber nicht automatisch, dass wir ausschlie\u00dflich auf moderne Browser angewiesen sind, die diese Funktionalit\u00e4ten von PWAs unterst\u00fctzen. Die Webanwendungen sollen auch weiterhin auf alten Webbrowsern laufen, dann jedoch eventuell ohne einige oder alle PWA-Funktionalit\u00e4ten. </p> <p>Progressive Web Apps m\u00fcssen </p> <ul> <li>zuverl\u00e4ssig (reliable) sein, d.h. sie m\u00fcssen schnelle Ladezeiten aufweisen und sogar (teilweise) offline funktionieren, </li> <li>schnell sein, d.h. schnell auf Nutzerinteraktionen reagieren, </li> <li>motivierend sein, die Webanwendung zu verwenden, d.h. einerseits intuitiv bedienbar und anderseits, z.B. \u00fcber Push-Notifikationen, die Nutzerinnen animieren, die App zu nutzen.</li> </ul> <p>Die prinzipielle Idee einer Progressive Web App l\u00e4sst sich vereinfacht durch die folgenden Abbildung veranschaulichen:</p> <p></p> <p>Eine Progressive Web App ist eine Webanwendung, die sich wie eine native mobile App verh\u00e4lt. </p>"},{"location":"einfuehrung/#webanwendungen-vs-native-apps","title":"Webanwendungen vs. native Apps","text":"<p>Die meisten Nutzerinnen verwenden die meiste Zeit native Apps auf ihrem Smartphone. Nur zu einem geringen Prozentsatz werden Web-Anwendungen (also der Browser) auf dem Smartphone verwendet. Das spricht eigentlich eher daf\u00fcr, dass wir uns mit der Entwicklung nativer Apps besch\u00e4ftigen sollten, als mit der Entwicklung von (mobilen) Webanwendungen. Die vorrangige Verwendung nativer Apps hat mehrere Gr\u00fcnde:</p> <ul> <li>Push-Notifikationen: Native Apps laufen im Hintergrund und die Nutzerinnen werden \u00fcber Push-Notifikationen informiert, wenn etwas Neues passiert ist, z.B. neue Nachrichten , E-Mails, etc. Man muss also gar nicht aktiv die native App bedienen, um \u00fcber Aktuelles informiert zu werden. </li> <li>App-Icons auf dem Home-Bildschirm: erm\u00f6glichen einen schnellen, direkten Zugang zu den Apps. </li> <li>Ger\u00e4tefunktionen: wie z.B. Standortermittlung, Kameras und Mikrofine k\u00f6nnen leicht in native Apps eingebaut werden. F\u00fcr Webanwendungen ist dies nur aufw\u00e4ndig m\u00f6glich. </li> <li>Offline-Funktionalit\u00e4ten: viele native Apps k\u00f6nnen auch offline ganz oder teilweise verwendet werden, z.B. Spiele oder Musikapps, die heruntergeladene Musik abspielen. </li> </ul> <p>App-Icons auf dem Home-Bildschirm k\u00f6nnen wir auch f\u00fcr Links auf unsere Webanwendung erstellen und die anderen drei Argumente wollen wir ja genau mit Progressive Web Apps zunichte machen. Das hei\u00dft, mit Progressive Web Apps kommen die Vorteile nativer Apps im Vergleich zu Webanwendungen nicht mehr zum Tragen. </p> <p>Demgegen\u00fcber stahen zwei Gr\u00fcnde, warum Webanwendungen besser sind als native Apps:</p> <ul> <li>Native Apps m\u00fcssen sowohl f\u00fcr iOS als auch f\u00fcr Android erstellt werden, um eine m\u00f6glichst gro\u00dfe Nutzerinnenzahl anzusprechen. Dazu m\u00fcssen auch unterschiedliche programmiersprachen verwendet werden (Swift f\u00fcr iOS und Java/Kotlin f\u00fcr Android). Zwar versuchen Hybride Tools diesen Nachteil zu umgehen, aber es gelingt nicht wirklich. </li> <li>Es werden so gut wie nie neue native Apps auf Smartphones geladen. Umfragen ergeben, dass Nutzerinnen die allermeiste Zeit am Smartphone mit h\u00f6chstens drei Apps verbringen. Alle weiteren Apps werden am Anfang der Nutzung installiert. Es kommen im Laufe eines \"Smartphone-Lebens\" kaum welche hinzu. Die durchschnittliche Anzahl neuhinzugef\u00fcgter Apps im Monat liegt bei nahe 0. </li> </ul> <p>Die Verwendung von Webanwendungen ist deutlich einfacher. Man muss nichts installieren. Man googlet einfach und \u00f6ffnet dann die Seite. Die Bandbreite aller Webanwendungen ist deutlich schneller erreichbar als eine gro\u00dfe Anzahl an nativen Apps. Die Reichweite einer Webanwendung ist deutlich gr\u00f6\u00dfer als die Reichweite einer nativen App. </p> \u00a0Funktionalit\u00e4ten \u00a0Nutzerinnen-Reichweite native App Zugriff auf Ger\u00e4tefunktionalit\u00e4ten nur sehr wenige Apps werden von sehr vielen Nutzerinnen die meiste Zeit verwendet herk\u00f6mmliche Webanwendungen sehr eingeschr\u00e4nkter (gar kein) Zugriff auf Ger\u00e4tefunktionalit\u00e4ten hohe Reichweite, sehr einfacher Zugang progressive Webanwendungen Zugriff auf Ger\u00e4tefunktionalit\u00e4ten hohe Reichweite, sehr einfacher Zugang"},{"location":"einfuehrung/#links-und-videos","title":"Links und Videos","text":"<p>Hier zwei kurze Einf\u00fchrungsvideos zu PWAs:</p> <ul> <li>Progressive Web Apps in 100 Seconds</li> <li>Progressive Web Apps - PWA Roadshow</li> </ul> <p>Hier einige interessante Links zu PWAs:</p> <ul> <li>Learn PWA</li> <li>Progressive Web-Apps: Was versprechen die progressiven Apps?</li> <li>Online Verzeichnis PWAs</li> </ul>"},{"location":"einfuehrung/#pwas-vs-spas","title":"PWAs vs. SPAs","text":"<p>Wir haben noch immer nicht unsere erste Progressive Web App erstellt ;-(. Bevor wir das tun, diskutieren wie zun\u00e4chst noch die Unterschiede zwischen einer Progressive Web App und einer Single Page Application, wie wir sie im WebTech-Kurs erstellt haben. </p> <p>Single Page Applications (SPAs) sind Webanwendungen, die mit JavaScript erstellt werden, typischerweise mit einem JavaScript-Framewaork, wie Angular, React oder Vue.js. In SPAs wird das DOM st\u00e4ndig neu gerendert, welches sich durch Nutzereingaben oder Lifecycle-Events \u00e4ndert. Das Grundger\u00fcst einer SPA besteht aus genau einer <code>HTML</code>-Seite (typischerweise <code>index.html</code>), in die verschiedene Komponenten eingebunden wird. Eine Single Page Application ist vornehmlich hoch reaktiv auf Nutzereingaben, im Sinne von schneller Reaktion. </p> <p>Progressive Web Applications (PWAs) sind eine Sammlung verschiedener Technologien. Es ist v\u00f6llig egal, ob diese Technologien in eine Single Page Application eingebunden werden oder in eine \"herk\u00f6mmliche\" (Multi-Page-) Webanwendung. Die Idee einer PWA ist, dass sie hoch reaktiv im Sinne st\u00e4ndiger Verf\u00fcgbarkeit ist. JavaScript spielt bei PWAs nicht die dominate Rolle, wie bei SPAs. Sie k\u00f6nnen eine oder mehrere progressive Funktionalit\u00e4ten existierender Webanwendungen hinzuf\u00fcgen (service worker, caching, push notifivcations, ...) oder eine PWA von Grund auf neu implementieren. </p>"},{"location":"einfuehrung/#lighthouse","title":"Lighthouse","text":"<p>Lighthouse ist ein Plugin f\u00fcr die Developertools von Chrome, mit dessen Hilfe gemessen werden kann, wie progressive eine Webanwendung ist. Die folgende Abbildung zeigt den Einsatz von Lighthouse f\u00fcr die PWA https://2048.love2dev.com/ - ein Spiel, das Sie wahrscheinlich kennen. </p> <p></p> <p>Wechseln Sie in den Developertools auf die mobile Ansicht. W\u00e4hlen Sie dann im Reiter <code>Lighthouse</code> die Analyse. Probieren Sie auch mal aus, die Anwendung im Offline-Modus zu verwenden. Wechseln Sie dazu in den Developertools auf den Reiter <code>Network</code> und dort in der Auswahlliste auf <code>Offline</code>. Selbst wenn Sie <code>Disable Cache</code> anklicken, werden Sie feststellen, dass sich das Spiel noch spielen l\u00e4sst. Viel Spa\u00df! ;-)</p>"},{"location":"einfuehrung/#pwa-checklist","title":"PWA Checklist","text":"<p>Im Lighthouse-Plugin finden Sie auch einen Link zur PWA Checklist. Diese Checklist wird verwendet, um zu beurteilen, wie progressive eine Webanwendung ist. Eine gute \u00dcbersicht finden Sie auch hier.</p>"},{"location":"einfuehrung/#erstes-kleines-beispiel","title":"Erstes kleines Beispiel","text":"<p>Wir erstellen uns in einem Ordner eine <code>index.html</code> mit </p> index.html <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\" /&gt; &lt;!-- muss nicht --&gt;\n\n    &lt;title&gt;IKT Start&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Willkommen zu den Aktuellen Trends der IKT&lt;/h1&gt;\n    &lt;p&gt;Wir besch\u00e4ftigen uns mit &lt;i&gt;Progressive Web Apps (PWA)&lt;/i&gt;. \n        Ein wesentlicher Bestandteil von PWAs sind &lt;i&gt;Service Worker&lt;/i&gt;.&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Einen gro\u00dfen Teil unserer Untersuchungen in diesem Modul nehmen Web APIs ein. Wir werden einige von Ihnen n\u00e4her beleuchten. </p> <p>Das zentrale Konzept von PWAs sind ServiceWorker. Wir erstellen uns in unserem Ordner eine Datei <code>service-worker.js</code> und binden diese in unsere <code>index.html</code> ein:</p> index.html <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\" /&gt; &lt;!-- muss nicht --&gt;\n\n    &lt;title&gt;IKT Start&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Willkommen zu den Aktuellen Trends der IKT&lt;/h1&gt;\n    &lt;p&gt;Wir besch\u00e4ftigen uns mit &lt;i&gt;Progressive Web Apps (PWA)&lt;/i&gt;. \n        Ein wesentlicher Bestandteil von PWAs sind &lt;i&gt;Service Worker&lt;/i&gt;.&lt;/p&gt;\n&lt;script&gt;\n// Check that service workers are supported\nif ('serviceWorker' in navigator) {\n// Use the window load event to keep the page load performant\nwindow.addEventListener('load', () =&gt; {\nnavigator.serviceWorker.register('/service-worker.js');\n});\n}\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>In die <code>service-worker.js</code> schreiben wir zun\u00e4chst nur</p> service-worker.js <pre><code>console.log('service worker registriert');\n</code></pre> <p>Wir starten die Anwendung (z.B. mit <code>npx serve</code>) und schalten die Entwicklertools ein. Auf der Konsole erscheint <code>service worker registriert</code>. Wir wechseln nach <code>Application --&gt; Service Worker</code> und sehen den aktiven <code>service-worker.js</code>. Wenn wir die Anwendung im Browser erneut laden, erscheint die Ausgabe nicht erneut. Wir \u00e4ndern den Service worker, z.B. auf <code>console.log('neuer service worker registriert</code>) und laden die Anwendung erneut. Die Ausgabe erscheint. Wechseln sie erneut nach <code>Application --&gt; Service Worker</code>. </p> <p>Der Service worker l\u00e4uft auch dann noch, wenn die Anwendung geschlossen ist!</p>"},{"location":"einfuehrung/#installierbar","title":"Installierbar","text":"<p>Wenn wir unter Lighthouse einen Report generieren, dann sieht es zwar prinzipiell schon ganz gut aus, es handelt sich aber auch noch nicht um eine PWA, da sie (noch) nicht installierbar ist. </p> <p></p> <p>Wir werden n\u00e4chste Woche damit beginnen, unsere App installierbar zu machen. Hier \"verraten\" wir aber bereits, dass wir dazu eine <code>manifest.json</code> ben\u00f6tigen. Diese erstellen wir und binden sie in die <code>index.html</code> ein:</p> index.html <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\" /&gt; &lt;!-- muss nicht --&gt;\n&lt;link rel=\"manifest\" href=\"manifest.json\"&gt;\n&lt;title&gt;IKT Start&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Willkommen zu den Aktuellen Trends der IKT&lt;/h1&gt;\n    &lt;p&gt;Wir besch\u00e4ftigen uns mit &lt;i&gt;Progressive Web Apps (PWA)&lt;/i&gt;. \n        Ein wesentlicher Bestandteil von PWAs sind &lt;i&gt;Service Worker&lt;/i&gt;.&lt;/p&gt;\n    &lt;script&gt;\n// Check that service workers are supported\nif ('serviceWorker' in navigator) {\n// Use the window load event to keep the page load performant\nwindow.addEventListener('load', () =&gt; {\nnavigator.serviceWorker.register('/service-worker.js');\n});\n}\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>In die <code>manifest.json</code> tragen wir ein:</p> manifest.json <pre><code>{\n\"name\": \"IKT-PWA\",\n\"start_url\": \"/\",\n\"id\": \"/\",\n\"icons\": [],\n\"theme_color\": \"#000000\",\n\"background_color\": \"#FFFFFF\",\n\"display\": \"fullscreen\",\n\"orientation\": \"portrait\"\n}\n</code></pre> <p>Wir kommen zu den einzelnen Eigenschaften n\u00e4chste Woche noch ausf\u00fchrlich. Die <code>manifest.json</code> ist jedoch noch nicht vollst\u00e4ndig, da das <code>icons</code>-Array noch bef\u00fcllt werden muss. In dieses Array tragen wir alle Bilder ein, die als Icons auf dem Startbildschirm verwendet werden sollen, je nach Aufl\u00f6sung des Ger\u00e4tes, auf dem die Anwendung gestartet werden soll. Die Generierung dieser Icons wird uns zum Gl\u00fcck abgenommen. Wir erstellen die Icons auf Basis eines Icons, das in recht gro\u00dfer Aufl\u00f6sung vorliegt. </p> <p>F\u00fcgen Sie dazu das fiwlogo in Ihren Projektordner ein. Wir nutzen den pwa-asset-generator. Im Terminal geben wir in unserem Projektordner ein:</p> <pre><code>npx pwa-asset-generator fiwlogo.png icons\n</code></pre> <p>Dabei ist <code>fiwlogo.png</code> das Icon, auf dessen Basis alle weiteren Icons erzeugt werden sollen und diese sollen in den Ordner <code>icons</code> erstellt werden. Die Ausgabe ist ungef\u00e4hr wie folgt:</p> <pre><code>11:49:08 getSplashScreenMetaData Initialising puppeteer to load latest splash screen metadata \ud83e\udd16\n11:49:08 getAppleSplashScreenData Navigating to Apple Human Interface Guidelines website - https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/adaptivity-and-layout/\n11:49:10 getAppleSplashScreenData Waiting for the data table to be loaded\n11:49:10 getAppleSplashScreenData Retrieved splash screen data\n11:49:10 getSplashScreenMetaData Loaded metadata for iOS platform \ud83d\ude4c\n11:49:11 generateImages Looks like folder icons doesn't exist. Created one for you \ud83e\udd14\n11:49:11 saveImages Initialising puppeteer to take screenshots \ud83e\udd16\n11:49:11 getShellHtml Generating shell html with provided image source\n11:49:11 getShellHtml Providing shell html as page content\n11:49:12 saveImages Saved image apple-splash-2388-1668 \ud83d\ude4c\n11:49:12 saveImages Saved image apple-splash-2732-2048 \ud83d\ude4c\n11:49:12 saveImages Saved image apple-splash-1536-2048 \ud83d\ude4c\n11:49:12 saveImages Saved image apple-splash-2048-1536 \ud83d\ude4c\n11:49:12 saveImages Saved image apple-splash-1668-2388 \ud83d\ude4c\n11:49:12 saveImages Saved image apple-splash-2048-2732 \ud83d\ude4c\n11:49:12 saveImages Saved image apple-splash-1668-2224 \ud83d\ude4c\n11:49:12 saveImages Saved image apple-splash-2224-1668 \ud83d\ude4c\n11:49:12 saveImages Saved image apple-splash-1620-2160 \ud83d\ude4c\n11:49:12 saveImages Saved image apple-splash-2436-1125 \ud83d\ude4c\n11:49:12 saveImages Saved image apple-splash-1242-2688 \ud83d\ude4c\n11:49:12 saveImages Saved image apple-splash-2532-1170 \ud83d\ude4c\n11:49:12 saveImages Saved image apple-splash-2160-1620 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-splash-1125-2436 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-splash-1284-2778 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-splash-1242-2208 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-splash-1792-828 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-splash-1170-2532 \ud83d\ude4c\n11:49:13 saveImages Saved image manifest-icon-192 \ud83d\ude4c\n11:49:13 saveImages Saved image manifest-icon-512 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-splash-2778-1284 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-splash-2208-1242 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-splash-1136-640 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-splash-2688-1242 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-splash-750-1334 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-icon-180 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-splash-640-1136 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-splash-1334-750 \ud83d\ude4c\n11:49:13 saveImages Saved image apple-splash-828-1792 \ud83d\ude4c\n11:49:13 cli Web App Manifest file is not specified, printing out the content to console instead \ud83e\udd14\n11:49:13 cli Below is the icons content for your manifest.json file. You can copy/paste it manually \ud83d\ude4c\n\n[\n  {\n    \"src\": \"icons/manifest-icon-192.maskable.png\",\n    \"sizes\": \"192x192\",\n    \"type\": \"image/png\",\n    \"purpose\": \"any\"\n  },\n  {\n    \"src\": \"icons/manifest-icon-192.maskable.png\",\n    \"sizes\": \"192x192\",\n    \"type\": \"image/png\",\n    \"purpose\": \"maskable\"\n  },\n  {\n    \"src\": \"icons/manifest-icon-512.maskable.png\",\n    \"sizes\": \"512x512\",\n    \"type\": \"image/png\",\n    \"purpose\": \"any\"\n  },\n  {\n    \"src\": \"icons/manifest-icon-512.maskable.png\",\n    \"sizes\": \"512x512\",\n    \"type\": \"image/png\",\n    \"purpose\": \"maskable\"\n  }\n]\n\n\n11:49:13 cli Index html file is not specified, printing out the content to console instead \ud83e\udd14\n11:49:13 cli Below is the iOS meta tags content for your index.html file. You can copy/paste it manually \ud83d\ude4c\n\n\n&lt;link rel=\"apple-touch-icon\" href=\"icons/apple-icon-180.png\"&gt;\n\n&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt;\n\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2048-2732.jpg\" media=\"(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2732-2048.jpg\" media=\"(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1668-2388.jpg\" media=\"(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2388-1668.jpg\" media=\"(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1536-2048.jpg\" media=\"(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2048-1536.jpg\" media=\"(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1668-2224.jpg\" media=\"(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2224-1668.jpg\" media=\"(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1620-2160.jpg\" media=\"(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2160-1620.jpg\" media=\"(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1284-2778.jpg\" media=\"(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2778-1284.jpg\" media=\"(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1170-2532.jpg\" media=\"(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2532-1170.jpg\" media=\"(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1125-2436.jpg\" media=\"(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2436-1125.jpg\" media=\"(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1242-2688.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2688-1242.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-828-1792.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1792-828.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1242-2208.jpg\" media=\"(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2208-1242.jpg\" media=\"(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-750-1334.jpg\" media=\"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1334-750.jpg\" media=\"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-640-1136.jpg\" media=\"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1136-640.jpg\" media=\"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n</code></pre> <p>Wir h\u00e4tten auch die <code>manifest.json</code> mit angeben k\u00f6nnen (Flag <code>m</code>) und auch die <code>index.html</code> (Flag <code>-i</code>), aber wir kopieren die Ausgaben h\u00e4ndisch in die jeweiligen Dateien. Das JSON </p> <pre><code>  {\n    \"src\": \"icons/manifest-icon-192.maskable.png\",\n    \"sizes\": \"192x192\",\n    \"type\": \"image/png\",\n    \"purpose\": \"any\"\n  },\n  {\n    \"src\": \"icons/manifest-icon-192.maskable.png\",\n    \"sizes\": \"192x192\",\n    \"type\": \"image/png\",\n    \"purpose\": \"maskable\"\n  },\n  {\n    \"src\": \"icons/manifest-icon-512.maskable.png\",\n    \"sizes\": \"512x512\",\n    \"type\": \"image/png\",\n    \"purpose\": \"any\"\n  },\n  {\n    \"src\": \"icons/manifest-icon-512.maskable.png\",\n    \"sizes\": \"512x512\",\n    \"type\": \"image/png\",\n    \"purpose\": \"maskable\"\n  }\n</code></pre> <p>kopieren wir in das <code>icons</code>-Array der <code>manifest.json</code>:</p> manifest.json <pre><code>{\n\"name\": \"IKT-PWA\",\n\"start_url\": \"/\",\n\"id\": \"/\",\n\"icons\": [\n{\n\"src\": \"icons/manifest-icon-192.maskable.png\",\n\"sizes\": \"192x192\",\n\"type\": \"image/png\",\n\"purpose\": \"any\"\n},\n{\n\"src\": \"icons/manifest-icon-192.maskable.png\",\n\"sizes\": \"192x192\",\n\"type\": \"image/png\",\n\"purpose\": \"maskable\"\n},\n{\n\"src\": \"icons/manifest-icon-512.maskable.png\",\n\"sizes\": \"512x512\",\n\"type\": \"image/png\",\n\"purpose\": \"any\"\n},\n{\n\"src\": \"icons/manifest-icon-512.maskable.png\",\n\"sizes\": \"512x512\",\n\"type\": \"image/png\",\n\"purpose\": \"maskable\"\n}\n],\n\"theme_color\": \"#000000\",\n\"background_color\": \"#FFFFFF\",\n\"display\": \"fullscreen\",\n\"orientation\": \"portrait\"\n}\n</code></pre> <p>und die iOS meta tags in die <code>index.html</code>:</p> index.html <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;link rel=\"shortcut icon\" href=\"favicon.ico\"/&gt;\n    &lt;link rel=\"manifest\" href=\"manifest.json\"&gt;\n&lt;link rel=\"apple-touch-icon\" href=\"icons/apple-icon-180.png\"&gt;\n&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2048-2732.jpg\" media=\"(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2732-2048.jpg\" media=\"(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1668-2388.jpg\" media=\"(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2388-1668.jpg\" media=\"(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1536-2048.jpg\" media=\"(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2048-1536.jpg\" media=\"(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1668-2224.jpg\" media=\"(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2224-1668.jpg\" media=\"(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1620-2160.jpg\" media=\"(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2160-1620.jpg\" media=\"(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1284-2778.jpg\" media=\"(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2778-1284.jpg\" media=\"(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1170-2532.jpg\" media=\"(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2532-1170.jpg\" media=\"(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1125-2436.jpg\" media=\"(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2436-1125.jpg\" media=\"(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1242-2688.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2688-1242.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-828-1792.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1792-828.jpg\" media=\"(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1242-2208.jpg\" media=\"(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-2208-1242.jpg\" media=\"(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-750-1334.jpg\" media=\"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1334-750.jpg\" media=\"(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-640-1136.jpg\" media=\"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\"&gt;\n&lt;link rel=\"apple-touch-startup-image\" href=\"icons/apple-splash-1136-640.jpg\" media=\"(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)\"&gt;\n&lt;title&gt;IKT Start&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Willkommen zu den aktuellen Trends der IKT&lt;/h1&gt;\n    &lt;script&gt;\nif ('serviceWorker' in navigator) {\nnavigator.serviceWorker.register('service-worker.js');\n}\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Prinzipiell w\u00e4re jetzt alles da, damit unsere Anwendung installiert werden kann. Jedoch gibt es derzeit keine M\u00f6glichkeit, dass die Anwendung auch offline verwendbar ist. Dazu ben\u00f6tigt es eine M\u00f6glichkeit des Cachings von Daten. Ohne jetzt schon wirklich zu wissen, was wir tun, passen wir die <code>service-worker.js</code> wie folgt an:</p> service-worker.js <pre><code>importScripts(\n'https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js'\n);\n\nworkbox.routing.registerRoute(\n({request}) =&gt; request.destination === 'image',\nnew workbox.strategies.NetworkFirst()     // NetworkFirst() vs CacheFirst()\n)\n</code></pre> <p>Wir haben also bereits mehrer Sachen identifiziert, mit denen wir uns besch\u00e4ftigen wollen:</p> <ul> <li>Manifest,</li> <li>Service worker und</li> <li>Caching</li> </ul> <p>und das sind auch genau die Themen der kommenden Wochen. </p> <p>Success</p> <p>Wir haben jetzt eine Idee davon, was Progressive Web Apps sind. Jetzt legen wir los und erstellen eigene PWAs!</p>"},{"location":"geolocation/","title":"Geolocation-API","text":"<p>Hint</p> <p>Aktueller Stand vor Geolocation-API:</p> <ul> <li>Frontend</li> <li>Backend</li> <li>Collection post</li> <li>Collection post.files</li> <li>Collection post.chunks</li> </ul> <p>Die Geolocation-API wird von allen Browsern unterst\u00fctzt (sogar Internet Explorer). Es gibt viele Dokumentationen dar\u00fcber, z.B. hier, hier und hier. Die Verwendung ist recht einfach. </p> <p>In der <code>index.html</code> haben wir uns bereits einen Button erstellt, f\u00fcr den wir \"nur noch\" das <code>click</code>-Ereignis behandeln m\u00fcssen. </p> public/index.html <pre><code>&lt;div class=\"input-section\"&gt;\n    &lt;button class=\"mdl-button mdl-js-button mdl-button--colored\" type=\"button\" id=\"location-btn\"&gt;Location&lt;/button&gt;\n    &lt;div class=\"mdl-spinner mdl-js-spinner is-active\" id=\"location-loader\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Zun\u00e4chst vereinfachen wir uns in der <code>feed.js</code> wieder den Zugriff auf den Button und den Spinner (Loader) und erstellen noch eine globale Variable <code>fetchedLocation</code>:</p> public/src/js/feed.js <pre><code>let shareImageButton = document.querySelector('#share-image-button');\nlet createPostArea = document.querySelector('#create-post');\nlet closeCreatePostModalButton = document.querySelector('#close-create-post-modal-btn');\nlet sharedMomentsArea = document.querySelector('#shared-moments');\nlet form = document.querySelector('form');\nlet titleInput = document.querySelector('#title');\nlet locationInput = document.querySelector('#location');\nlet videoPlayer = document.querySelector('#player');\nlet canvasElement = document.querySelector('#canvas');\nlet captureButton = document.querySelector('#capture-btn');\nlet imagePicker = document.querySelector('#image-picker');\nlet imagePickerArea = document.querySelector('#pick-image');\nlet file = null;\nlet titleValue = '';\nlet locationValue = '';\nlet imageURI = '';\nlet locationButton = document.querySelector('#location-btn');\nlet locationLoader = document.querySelector('#location-loader');\nlet fetchedLocation;\n</code></pre> <p>und wir setzen den <code>Loader</code> in der <code>feed.css</code> auf unsichtbar:</p> public/src/js/feed.css <pre><code>#create-post #pick-image, #create-post #location-loader {\ndisplay: none;\n}\n</code></pre> <p><code>create-post #pick-image</code> stand dort schon, wir haben nur noch den Selektor <code>#create-post #location-loader</code> hinzugef\u00fcgt.</p> <p>Wir f\u00fcgen in der <code>feed.js</code> die Behandlung des <code>click</code>-Ereignisses f\u00fcr den <code>Location</code>-Button hinzu und auch noch, wie f\u00fcr die Kamera, eine <code>initializeLocation()</code>-Funktion, in der gepr\u00fcft wird, ob die <code>Geolocation</code>-API \u00fcberhaupt im Browser verf\u00fcgbar ist: </p> public/src/js/feed.js <pre><code>locationButton.addEventListener('click', event =&gt; {\nif(!('geolocation' in navigator)) {\nreturn;\n}\n\nlocationButton.style.display = 'none';\nlocationLoader.style.display = 'block';\n\nnavigator.geolocation.getCurrentPosition( position =&gt; {\nlocationButton.style.display = 'inline';\nlocationLoader.style.display = 'none';\nfetchedLocation = { latitude: position.coords.latitude, longitude: position.coords.longitude };\nconsole.log('current position: ', fetchedLocation);\nlocationInput.value = 'In Berlin';\ndocument.querySelector('#manual-location').classList.add('is-focused');\n}, err =&gt; {\nconsole.log(err);\nlocationButton.style.display = 'inline';\nlocationLoader.style.display = 'none';\nalert('Couldn\\'t fetch location, please enter manually!');\nfetchedLocation = null;\n}, { timeout: 5000});\n});\n\nfunction initializeLocation() {\nif(!('geolocation' in navigator)) {\nlocationButton.style.display = 'none';\n}\n}\n</code></pre> <p>In der <code>initializeLocation()</code>-Funktion wird gepr\u00fcft, ob der Browser die <code>Geolocation</code>-API unterst\u00fctzt. Wenn nicht, wird der <code>Location</code>-Button versteckt. Wir haben trotzdem, sicherheitshalber, die Abfrage nochmal in die Behandlung des <code>click</code>-Ereignisses f\u00fcr diesen Button eingef\u00fcgt (Zeilen <code>22-24</code>), obwohl dies nicht wirklich notwendig ist, da der Button nicht angeklickt werden kann, wenn die <code>Geolocation</code>-API nicht unterst\u00fctzt wird, da er nicht angezeigt wird. </p> <p>Wenn auf den Button geklickt wurde, setzen wir den Button selbst auf unsichtbar (Zeile <code>26</code>) und den Spinner (Loader) auf sichtbar (Zeile <code>27</code>). Zeile <code>29</code> zeigt den eigentlichen Zugriff auf die aktuelle Position. Dort wird die Funktion <code>getCurrentPosition()</code> der <code>Geolocation</code>-API aufgerufen. Wir \u00fcbergeben drei Parameter:</p> <ul> <li>der erste Parameter ist die (Callback-)Funktion, die die aktuelle Position zur\u00fcckgibt. Wenn diese Funktion ausgef\u00fchrt wird, setzen wir den Button wieder auf sichtbar (Zeile <code>30</code>) und den Loader auf unsichtbar (Zeile <code>31</code>). Die aktuelle Position <code>position</code> enth\u00e4lt die Eigenschaft <code>coords</code>, die die <code>latitude</code> und <code>longitude</code> als Werte enth\u00e4lt (siehe GeolocationPosition und GeolocationCoordinates).  Diese Position geben wir auf der Konsole aus (Zeile <code>33</code>). Wir bef\u00fcllen das <code>locationInput</code>-Eingabefeld noch mit einem Dummy-Wert und fokussieren auf das Eingabefeld (Zeilen <code>34-35</code>).</li> <li>der zweite Parameter ist eine Funktion, die ausgef\u00fchrt wird, wenn ein Fehler auftritt. M\u00f6gliche Fehler sind, dass im Browser der Zugriff auf die Position deaktiviert wurde, dass die Nutzerin den Zugriff auf die aktuelle Position blockiert hat oder dass die Position nicht \"schnell genug\" ermittelt werden konnte. Im Fehlerfall geben wir den Fehler auf der Konsole aus und schalten den Button wieder ein und den Loader wieder aus (Zeilen <code>37-39</code>).</li> <li>der dritte Parameter ist ein JavaScript-Objekt mit <code>options</code>. Wir w\u00e4hlen hier nur eine einzige Option, n\u00e4mlich wie lange nach der aktuellen Position gesucht werden soll. In der Einstellung erfolgt der <code>timeout</code> nach <code>5 sek</code>. </li> </ul> <p>Wir passen nun in der <code>feed.js</code> noch die beiden Funktionen <code>openCreatePostModal()</code> und <code>closeCreatePostModal()</code> an:</p> public/src/js/feed.js <pre><code>function openCreatePostModal() {\ncreatePostArea.style.transform = 'translateY(0)';\ninitializeMedia();\ninitializeLocation();\n}\n\nfunction closeCreatePostModal() {\ncreatePostArea.style.transform = 'translateY(100vH)';\nimagePickerArea.style.display = 'none';\nvideoPlayer.style.display = 'none';\ncanvasElement.style.display = 'none';\nlocationButton.style.display = 'inline';\nlocationLoader.style.display = 'none';\n}\n</code></pre> <p>Wenn Sie die Anwendung nun starten, werden Sie gefragt, ob Sie die Abfrage nach Ihrem Standort zulassen oder blockieren wollen. Die meisten von Ihnen werden aber die Ortungsdienste ausgeschaltet haben. Dann ist auch die Abfrage zun\u00e4chst egal. Im Mac kann man diese (kurzzeitig, dann wieder ausschalten) \u00fcber <code>Systemeinstellungen --&gt; Sicherheit &amp; Datenschutz --&gt; Reiter Datenschutz --&gt; Ortungsdienste</code> f\u00fcr <code>Google Chrome</code> aktivieren. </p> <p>Wenn Sie die Positionsbestimmung zulassen, dann wird nach dem Klicken auf den <code>Location</code>-Button die aktuelle Position auf der Konsole eingegeben und im Formular erscheint unter Ort <code>In Berlin</code>.</p> <p>Wir machen nichts weiter mit der aktuellen Position. Es gibt viele M\u00f6glichkeiten, die jetzt noch ausprobiert werden k\u00f6nnten. Dazu geh\u00f6ren beisielsweise:</p> <ul> <li>Wir k\u00f6nnten mithilfe der Google-Geolocation-API die Adresse ermitteln, die Google f\u00fcr eine gegebene Position (<code>longitude</code> und <code>latitude</code>) zur\u00fcckgibt. Dazu br\u00e4uchten wir aber auch einen API-Key von Google.</li> <li>Wir k\u00f6nnten das Gleiche mit der Nominatim-API f\u00fcr Open Street Map machen. Sie k\u00f6nnen den Service hier einmal ausprobieren, indem Sie Ihre <code>latitude</code> und <code>longitude</code> aus der Konsolenausgabe eingeben.</li> <li>Wir k\u00f6nnten OpenLayers verwenden, um die Position auf einer Karte anzuzeigen.</li> <li>Wir k\u00f6nnten die Datenbank erweitern und f\u00fcr alle Posts auch noch die Koordinaten der Position abspeichern und dann alle Posts auf einer Karte (mithilfe von OpenLayers + OpenStreetMap) visualisieren.</li> </ul>"},{"location":"geolocation/#beispiel-nominatimorg","title":"Beispiel nominatim.org","text":"<p>Die oben genannten Verwendungsbeispiele sind alle relativ einfach, da die jeweiligen APIs wirklich gut sind. Wir zeigen hier exemplarisch die Verwendung der Nominatim-API, mit deren Hilfe wir f\u00fcr gegebene Breiten- und L\u00e4ngengrade ein Adress-Objekt zur\u00fcckbekommen. Genauer gesagt, handelt es sich um ein Open Street Map (OSM)-Objekt. Einen groben \u00dcberblick \u00fcber die Endpunkte der Nominatim-API erhalten Sie hier. Uns interessiert dabei insbesondere der /reverse-Endpunkt, der ein OSM-Objekt f\u00fcr eine gegebene Lokation zur\u00fcckgibt. </p> <p>Prinzipiell sieht die Anfrage wie folgt aus:</p> <pre><code>https://nominatim.openstreetmap.org/reverse?format=&lt;value&gt;&amp;lat=&lt;value&gt;&amp;lon=&lt;value&gt;&amp;&lt;params&gt;\n</code></pre> <ul> <li>Als R\u00fcckgabe-<code>format</code> kann einer der folgenden Werte verwendet werden: <code>[xml|json|jsonv2|geojson|geocodejson]</code>. Der Standard ist <code>xml</code>. Wir sollten am besten <code>jsonv2</code> verwenden.  </li> <li>F\u00fcr <code>lat</code> und <code>long</code> setzen wir die <code>latitude</code> und <code>longitude</code> ein, die wir in <code>fetchedLocation</code> speichern.</li> <li>F\u00fcr m\u00f6gliche weitere Parameter <code>&lt;params&gt;</code>, wie z.B. <code>zoom</code>, <code>extratags</code> oder <code>namedetails</code>, schauen Sie hier.</li> </ul> <p>Wenn wir z.B. folgende Anfrage stellen: </p> <pre><code>GET https://nominatim.openstreetmap.org/reverse?format=jsonv2&amp;lat=52.457310&amp;lon=13.526877\n</code></pre> <p>erhalten wir als Response folgendes JSON:</p> <pre><code>{\n\"place_id\": 106322469,\n\"licence\": \"Data \u00a9 OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright\",\n\"osm_type\": \"way\",\n\"osm_id\": 25346348,\n\"lat\": \"52.45699635\",\n\"lon\": \"13.526577702867113\",\n\"place_rank\": 30,\n\"category\": \"building\",\n\"type\": \"university\",\n\"importance\": 0,\n\"addresstype\": \"building\",\n\"name\": \"Geb\u00e4ude C\",\n\"display_name\": \"Geb\u00e4ude C, Johannes-Kraaz-Stra\u00dfe, Obersch\u00f6neweide, Treptow-K\u00f6penick, Berlin, 12459, Deutschland\",\n\"address\": {\n\"building\": \"Geb\u00e4ude C\",\n\"road\": \"Johannes-Kraaz-Stra\u00dfe\",\n\"suburb\": \"Obersch\u00f6neweide\",\n\"borough\": \"Treptow-K\u00f6penick\",\n\"city\": \"Berlin\",\n\"state\": \"Berlin\",\n\"postcode\": \"12459\",\n\"country\": \"Deutschland\",\n\"country_code\": \"de\"\n},\n\"boundingbox\": [\n\"52.4561412\",\n\"52.4577257\",\n\"13.5255179\",\n\"13.5274139\"\n]\n}\n</code></pre> <p>Wir k\u00f6nnten nun einen ausgew\u00e4hlten Wert in unser Formular \u00fcbernehmen, z.B. <code>display_name</code> oder <code>suburb</code> oder <code>city</code>. Wir zeigen im Folgenden die \u00dcbernahme von <code>display_name</code> in das Eingabeformular:</p> public/src/js/feed.js <pre><code>locationButton.addEventListener('click', event =&gt; {\nif(!('geolocation' in navigator)) {\nreturn;\n}\n\nlocationButton.style.display = 'none';\nlocationLoader.style.display = 'block';\n\nnavigator.geolocation.getCurrentPosition( position =&gt; {\nlocationButton.style.display = 'inline';\nlocationLoader.style.display = 'none';\nfetchedLocation = { latitude: position.coords.latitude, longitude: position.coords.longitude };\nconsole.log('current position: ', fetchedLocation);\n\nlet nominatimURL = 'https://nominatim.openstreetmap.org/reverse'; nominatimURL += '?format=jsonv2';   // format=[xml|json|jsonv2|geojson|geocodejson]\nnominatimURL += '&amp;lat=' + fetchedLocation.latitude;\nnominatimURL += '&amp;lon=' + fetchedLocation.longitude;\n\nfetch(nominatimURL)\n.then((res) =&gt; {\nconsole.log('nominatim res ...', res);\nreturn res.json();\n})\n.then((data) =&gt; {\nconsole.log('nominatim res.json() ...', data);\nlocationInput.value = data.display_name;\n})\n.catch( (err) =&gt; {\nconsole.error('err', err)\nlocationInput.value = 'In Berlin';\n});\n\ndocument.querySelector('#manual-location').classList.add('is-focused');\n}, err =&gt; {\nconsole.log(err);\nlocationButton.style.display = 'inline';\nlocationLoader.style.display = 'none';\nalert('Couldn\\'t fetch location, please enter manually!');\nfetchedLocation = null;\n}, { timeout: 5000});\n});\n</code></pre> <ul> <li>In den Zeilen <code>35-38</code> setzen wir die URL zusammen, unter der wir <code>nominatim.org</code> anfragen. In Zeile <code>40</code> erfolgt die Anfrage mithilfe der <code>fetch</code>-API. Wir erhalten ein <code>Response</code>-Objekt zur\u00fcck, das wir mithilfe von <code>res.json()</code> so extrahieren, dass es dem oben gezeigten JSON entspricht. </li> </ul>"},{"location":"geolocation/#beispiel-openlayersorg","title":"Beispiel OpenLayers.org","text":"<p>OpenLayers stellt eine Bibliothek von JavaScript- und CSS-Funktionalit\u00e4ten bereit, um Landkarten in die Webanwendung einzubinden. Wir zeigen die Anwendung hier an einer sehr einfachen Einf\u00fchrung, die im Prinzip dem Einf\u00fchrungsbeispiel von OpenLayers entspricht. </p>"},{"location":"geolocation/#einbinden-in-die-indexhtml","title":"Einbinden in die index.html","text":"<p>Zun\u00e4chst kann die CSS- und JavaScript-Bibliothek \u00fcber ein CDN eingebunden werden:</p> Auszug index.html <pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta name=\"viewport\"\n        content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt;\n  &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;\n  &lt;title&gt;IKT-PWA&lt;/title&gt;\n  &lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Roboto:400,700\"&gt;\n  &lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"&gt;\n  &lt;link rel=\"stylesheet\" href=\"https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css\"&gt;\n&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.14.1/css/ol.css\" type=\"text/css\"&gt;\n&lt;script src=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.14.1/build/ol.js\"&gt;&lt;/script&gt;\n&lt;link rel=\"stylesheet\" href=\"/src/css/app.css\"&gt;\n  &lt;link rel=\"stylesheet\" href=\"/src/css/feed.css\"&gt;\n  &lt;link rel=\"manifest\" href=\"manifest.webmanifest\"&gt;\n\n  &lt;!-- und hier der Rest --&gt;\n</code></pre> <p>Dann integrieren wir ein <code>&lt;div&gt;</code>-Element, in dem sp\u00e4ter die Landkarte erscheint:</p> Auszug index.html <pre><code>      &lt;div class=\"input-section\"&gt;\n        &lt;button class=\"mdl-button mdl-js-button mdl-button--colored\" type=\"button\" id=\"location-btn\"&gt;Location&lt;/button&gt;\n        &lt;div class=\"mdl-spinner mdl-js-spinner is-active\" id=\"location-loader\"&gt;&lt;/div&gt;\n      &lt;/div&gt;\n\n&lt;div id=\"map\" class=\"map\"&gt;&lt;/div&gt;\n&lt;br&gt;\n      &lt;div&gt;\n        &lt;button class=\"mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\"\n                type=\"submit\" id=\"post-btn\"&gt;Speichern\n        &lt;/button&gt;\n      &lt;/div&gt;\n</code></pre>"},{"location":"geolocation/#anpassen-der-feedcss","title":"Anpassen der feed.css","text":"<p>Zun\u00e4chst m\u00fcssen wir in der <code>feed.js</code> einen Selektor \u00e4ndern. Wir haben die <code>map</code> innerhalb des <code>div</code> mit der <code>id=\"create-post\"</code> angelegt. In der <code>feed.js</code> befindet sich folgender Eintrag:</p> feed.css <pre><code>#create-post video, #create-post canvas {\nwidth: 512px;\nmax-width: 100%;\ndisplay: none;\nmargin: auto;\n}\n</code></pre> <p>Wir sprechen also alle HTML-Elemente <code>video</code> und <code>canvas</code> an, die sich im <code>div</code> mit der <code>id=\"create-post\"</code> befinden. Allerdings wird unsere <code>map</code> auch ein <code>canvas</code>-Element enthalten, welches ebenfalls mit angesprochen (und auf <code>display: none</code> gesetzt) werden w\u00fcrde. Wir spezialisieren diese Selektoren nun, indem wir jeweils die <code>id</code>s des <code>video</code>- und des <code>canvas</code>-Elementes verwenden, die sich um die Aufnahme des Fotos k\u00fcmmern:</p> feed.css <pre><code>#create-post #player, #create-post #canvas {\nwidth: 512px;\nmax-width: 100%;\ndisplay: none;\nmargin: auto;\n}\n</code></pre> <p>Nun k\u00f6nnen wir die Eigenschaften hinzuf\u00fcgen, die f\u00fcr die <code>map</code> relevant sind:</p> feed.css <pre><code>#create-post .map {\nheight: 400px;\nwidth: 400px;\ndisplay: none;\nmargin: 10px auto;\n}\n</code></pre> <p>Sie k\u00f6nnen f\u00fcr H\u00f6he und Breite auch relative oder auch andere absolute Werte setzen. Zun\u00e4chst ist das <code>div</code> mit der CSS-Klasse <code>map</code> aber auf nicht sichtbar gesetzt.</p>"},{"location":"geolocation/#anpassen-der-feedjs","title":"Anpassen der feed.js","text":"<p>In der <code>feed.js</code> erweitern wir die <code>fetch()</code>-Anfrage an <code>nominatim.org</code>. Diese sieht bis jetzt so aus:</p> public/src/js/feed.js <pre><code>        fetch(nominatimURL)\n.then((res) =&gt; {\nconsole.log('nominatim res ...', res);\nreturn res.json();\n})\n.then((data) =&gt; {\nconsole.log('nominatim res.json() ...', data);\nlocationInput.value = data.display_name;\n})\n.catch( (err) =&gt; {\nconsole.error('err', err)\nlocationInput.value = 'In Berlin';\n});\n</code></pre> <p>Siehe die <code>feed.js</code> aus Beispiel nominatim.org oben.  Unter Verwendung der Variablen <code>fetchedLocation</code>, die die <code>longitude</code> und <code>latitude</code> unseres Standortes enth\u00e4lt, f\u00fcgen wir nun die Erstellung einer Map mithilfe von OpenLayers hinzu:</p> public/src/js/feed.js <pre><code>        fetch(nominatimURL)\n.then((res) =&gt; {\nconsole.log('nominatim res ...', res);\nreturn res.json();\n})\n.then((data) =&gt; {\nconsole.log('nominatim res.json() ...', data);\nlocationInput.value = data.display_name;\nreturn data;\n})\n.then( d =&gt; {\nlocationButton.style.display = 'none';\nlocationLoader.style.display = 'none';\nmapDiv.style.display = 'block';\n\nconst map = new ol.Map({\ntarget: 'map',\nlayers: [\nnew ol.layer.Tile({\nsource: new ol.source.OSM()\n})\n],\nview: new ol.View({\ncenter: ol.proj.fromLonLat([fetchedLocation.longitude, fetchedLocation.latitude]),\nzoom: 12\n})\n});\n\nconst layer = new ol.layer.Vector({\nsource: new ol.source.Vector({\nfeatures: [\nnew ol.Feature({\ngeometry: new ol.geom.Point(ol.proj.fromLonLat([fetchedLocation.longitude, fetchedLocation.latitude]))\n})\n]\n})\n});\n\nmap.addLayer(layer);\n\nconsole.log('map', map)\n})\n.catch( (err) =&gt; {\nconsole.error('err', err)\nlocationInput.value = 'In Berlin';\n});\n</code></pre> <ul> <li>In Zeile <code>53</code> wird das <code>div</code>, das die <code>map</code> enth\u00e4lt, auf sichtbar gesetzt (Definieren Sie dazu <code>let mapDiv = document.querySelector('#map');</code>). Der <code>locationButton</code> und der Spinner werden unsichtbar.</li> <li>Mit <code>new ol.Map()</code> wird eine neue Map erstellt (Zeile <code>55</code>). </li> <li>Dieses <code>Map</code>-Objekt wird mit <code>target: 'map'</code> dem <code>div</code> mit der <code>id=\"map\"</code> zugewiesen (Zeile <code>56</code>).</li> <li>Das <code>layers</code>-Array enth\u00e4lt alle Schichten, die zur Map hinzugef\u00fcgt werden (Zeile <code>57</code>).</li> <li>In unserem Fall wird eine Schicht hinzugef\u00fcgt, n\u00e4mlich eine Kachel (Tile)-Schicht, die die Landkarte enth\u00e4lt. Diese wird in unserem Fall von der Quelle OSM (also Open Street Map) geholt. Beachten Sie Ihre Konsole. Sie werden Eintr\u00e4ge in der folgenden Art darin finden:</li> </ul> <p></p> <p>Das sind die Bilder, aus denen die Landkarte zusammengesetzt wird.  </p> <ul> <li>Die eigentliche Ansicht wird mit <code>view</code> definiert. Wir erstellen ein einfaches <code>View</code>-Objekt, das durch den <code>center</code>-Punkt (<code>[fetchedLocation.longitude, fetchedLocation.latitude]</code>) und ein <code>zoom</code>-Level beschrieben wird (hier <code>zoom:12</code>). Je h\u00f6her das <code>zoom</code>-Level, je h\u00f6her wird hineingezoomt. Zoom-Level <code>0</code> zeigt die Welt. (Zeilen <code>62-65</code>)</li> </ul> <p>Die Zeilen <code>55-65</code> gen\u00fcgen bereits, um die Karte anzuzeigen. Wir haben aber hier auch noch einen Marker f\u00fcr den aktuellen Standort hinzugef\u00fcgt. Dazu wird eine weitere <code>Layer</code> definiert und der Map mithilfe von <code>map.addLayer()</code> hinzugef\u00fcgt. Dies geschieht hier in den Zeilen <code>68-78</code>. Bei dem Marker handelt es sich hier um einen <code>Point</code>, der wiederum auf <code>[fetchedLocation.longitude, fetchedLocation.latitude]</code> gesetzt wird. Beachten Sie, dass die Reihenfolge sowohl in der <code>View</code> als auch beim <code>Feature</code> zun\u00e4chst <code>longitude</code> und dann <code>latitude</code> ist!</p> <p>Success</p> <p>Wir haben erfolgreich den Zugriff auf die Kamera (MediaDevices-API) und die Geolocation-API ausprobiert und in unsere Anwendung eingebunden. Die MediaDevices-API bietet neben der <code>video</code>-Eigenschaft auch noch die <code>audio</code>-Eigenschaft, um das Mikrofon zu verwenden. Neben der Geolocation-API haben wir auch zwei weitere Services bzw. Bibliotheken verwendet, n\u00e4mlich nomination.org und OpenLayers. Der Umgang mit den Karten kann beliebig erweitert werden. Beispielsweise k\u00f6nnten auch alle Blogs auf einer Landkarte angezeigt werden, je nachdem, wo sie erstellt wurden. Sie k\u00f6nnten anklickbar sein und dann detailliert angezeigt werden. Das ist alles relativ leicht m\u00f6glich. Ihrer Phantasie und Ihren M\u00f6glichkeiten sind hier keine Grenzen gesetzt. Wir k\u00f6nnten hier auch noch auf die Sensoren der Mobilger\u00e4te eingehen (z.B. Beschleunigungssensor). Das machen wir aber in diesem Semester nicht.  </p>"},{"location":"grundgeruest/","title":"Grundger\u00fcst unserer PWA","text":"<p>Wir beginnen jetzt mit der Implementierung von progressive Funktionalit\u00e4ten. Das machen wir, indem wir sukzessive eine Progressive Web App erstellen, die viele der derzeit verf\u00fcgbaren Funktionalit\u00e4ten enth\u00e4lt, die derzeit f\u00fcr Progressive Web Apps verf\u00fcgbar sind. Das Grundger\u00fcst (oder der Ausgangspunkt) unserer PWA wird deshalb zur Verf\u00fcgung gestellt, weil wir uns nicht um die Implementierung von HTML, CSS und JavaScript, sondern nur um die progressive Funktionalit\u00e4ten k\u00fcmmern wollen. Auf Basis dieses Grundger\u00fcstes werden sukzessive Funktionalit\u00e4ten, wie Push-Notifikationen, Offline-Verwendung, Geolocation, Kameranutzung usw. hinzuf\u00fcgen. Die Idee ist, dass wir eine Art HTW-Instagram erstellen. Ich habe Instagram aber noch nie genutzt, deshalb wei\u00df ich nicht, ob wir dem \"Original\" nahe kommen werden. Wahrscheinlich nicht, aber daf\u00fcr behalten wir unsere Daten auch bei uns. </p>"},{"location":"grundgeruest/#installation","title":"Installation","text":"<p>Den Quellcode f\u00fcr das Grundger\u00fcst finden Sie hier (GitHub). Clonen Sie sich das Projekt in einem Ordner Ihrer Wahl und folgen Sie dann der <code>README.MD</code>: </p> <ul> <li> <p>Zum Ausf\u00fchren des Projektes wird Node.js verendet. Sie m\u00fcssen es auf Ihren Rechner installieren. </p> </li> <li> <p>In der Wahl Ihrer IDE sind Sie v\u00f6llig frei. Empfehlungen finden Sie unter Integrated Development Environment (IDE)</p> </li> <li> <p>Zum Starten des Projektes wechseln Sie im Terminal (Terminal Ihres Rechners oder das Terminal in der IDE) in den Projektordner (<code>cd IKT-PWA-01</code>) und f\u00fchren dort </p> <p><code>npm install</code> </p> <p>aus. Damit werden alle erforderlichen Abh\u00e4ngigkeiten installiert.</p> </li> <li> <p>Nach erfolgreicher Installation der Abh\u00e4ngigkeiten, geben Sie  </p> <p><code>npm start</code> </p> <p>ein (oder genereller: <code>npm run start</code>), um Ihr Projekt auszuf\u00fchren. Klicken Sie danach auf localhost:8080 oder geben Sie die URL direkt in Ihren Browser ein.</p> </li> </ul>"},{"location":"grundgeruest/#starten","title":"Starten","text":"<p>Starten Sie das Projekt mit <code>npm start</code> (nachdem Sie einmalig <code>npm install</code> ausgef\u00fchrt haben) und \u00f6ffnen Sie dann den Browser mit der URL <code>http://localhost:8080/</code>. Es erscheint</p> <p></p> <p>bzw. wenn Sie die Viewport-Breite verkleinern</p> <p>. </p> <p>Sie erkennen wahrscheinlich schon, dass wir Material Design Lite verwenden. Die Navigationskomponente kennen wir auch schon aus WebTech. Wenn Sie auf den <code>+</code>-Button klicken, erscheint ein kleines Men\u00fc. Dort k\u00f6nnen Sie zwar schon etwas eintragen, aber der <code>SPEICHERN</code>-Button funktioniert noch nicht. Auch beim <code>BENACHRICHTIGUNGEN EIN</code>-Button ist noch keine Ereignisbehandlung hinterlegt. Wenn Sie im Men\u00fc <code>Hilfe</code>klicken, \u00f6ffnet sich die (fast leere) Hilfe-Seite. </p> <p>Schalten Sie beim Betrachten der Anwendung stets die <code>DeveloperTools</code> ein. Sie k\u00f6nnen dort sehr leicht auf die mobile Ansicht wechseln. Wichtig ist, dass Sie - zum besseren Ausprobieren der Anwendung - in den DeveloperTools unter dem Reiter <code>Network</code> ein H\u00e4kchen bei <code>Disable Cache</code> setzen. Wir wollen in Zukunft das Caching unseren Service workern \u00fcberlassen und nicht den Cache des Browsers verwenden. </p> <p></p>"},{"location":"grundgeruest/#projekt","title":"Projekt","text":"<p>Bevor wir loslegen, werfen wir noch einen kurzen Blick auf die bisherigen Dateien im Projekt. Wir beginnen mit der <code>index.html</code> aus dem <code>public</code>-Ordner.</p> public/index.html <pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta name=\"viewport\"\n        content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt;\n  &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;\n  &lt;title&gt;IKT-PWA&lt;/title&gt;\n  &lt;link href=\"https://fonts.googleapis.com/css?family=Roboto:400,700\" rel=\"stylesheet\"&gt;\n  &lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"&gt;\n  &lt;link rel=\"stylesheet\"\n        href=\"https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css\"&gt;\n  &lt;link rel=\"stylesheet\" href=\"/src/css/app.css\"&gt;\n  &lt;link rel=\"stylesheet\" href=\"/src/css/feed.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;div id=\"app\"&gt;\n  &lt;div class=\"mdl-layout mdl-js-layout mdl-layout--fixed-header\"&gt;\n    &lt;header class=\"mdl-layout__header\"&gt;\n      &lt;div class=\"mdl-layout__header-row\"&gt;\n        &lt;!-- Title --&gt;\n        &lt;span class=\"mdl-layout-title\"&gt;IKT-PWA&lt;/span&gt;\n        &lt;!-- Add spacer, to align navigation to the right --&gt;\n        &lt;div class=\"mdl-layout-spacer\"&gt;&lt;/div&gt;\n        &lt;!-- Navigation. We hide it in small screens. --&gt;\n        &lt;nav class=\"mdl-navigation mdl-layout--large-screen-only\"&gt;\n          &lt;a class=\"mdl-navigation__link\" href=\"/\"&gt;Bilder&lt;/a&gt;\n          &lt;a class=\"mdl-navigation__link\" href=\"/help\"&gt;Hilfe&lt;/a&gt;\n          &lt;div class=\"drawer-option\"&gt;\n            &lt;button class=\"enable-notifications mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\"&gt;\n              Benachrichtigungen Ein\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/nav&gt;\n      &lt;/div&gt;\n    &lt;/header&gt;\n    &lt;div class=\"mdl-layout__drawer\"&gt;\n      &lt;span class=\"mdl-layout-title\"&gt;IKT-PWA&lt;/span&gt;\n      &lt;nav class=\"mdl-navigation\"&gt;\n        &lt;a class=\"mdl-navigation__link\" href=\"/\"&gt;Bilder&lt;/a&gt;\n        &lt;a class=\"mdl-navigation__link\" href=\"/help\"&gt;Hilfe&lt;/a&gt;\n        &lt;div class=\"drawer-option\"&gt;\n          &lt;button class=\"enable-notifications mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\"&gt;\n            Benachrichtigungen Ein\n          &lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/nav&gt;\n    &lt;/div&gt;\n    &lt;main class=\"mdl-layout__content mat-typography\"&gt;\n      &lt;div id=\"create-post\"&gt;\n        &lt;form&gt;\n          &lt;div class=\"input-section mdl-textfield mdl-js-textfield mdl-textfield--floating-label\"&gt;\n            &lt;input class=\"mdl-textfield__input\" type=\"text\" id=\"title\"&gt;\n            &lt;label class=\"mdl-textfield__label\" for=\"title\" name=\"title\"&gt;Titel&lt;/label&gt;\n          &lt;/div&gt;\n          &lt;div class=\"input-section mdl-textfield mdl-js-textfield mdl-textfield--floating-label\" id=\"manual-location\"&gt;\n            &lt;input class=\"mdl-textfield__input\" type=\"text\" id=\"location\"&gt;\n            &lt;label class=\"mdl-textfield__label\" for=\"location\" name=\"location\"&gt;Ort&lt;/label&gt;\n          &lt;/div&gt;\n          &lt;br&gt;\n          &lt;div&gt;\n            &lt;button class=\"mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\"\n                    type=\"submit\" id=\"post-btn\"&gt;Speichern\n            &lt;/button&gt;\n          &lt;/div&gt;\n          &lt;br&gt;\n          &lt;div&gt;\n            &lt;button class=\"mdl-button mdl-js-button mdl-button--fab\" id=\"close-create-post-modal-btn\" type=\"button\"&gt;\n              &lt;i class=\"material-icons\"&gt;close&lt;/i&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/form&gt;\n      &lt;/div&gt;\n      &lt;img src=\"/src/images/htw.jpg\"\n           alt=\"HTW Wilhelminenhof\"\n           class=\"main-image\"&gt;\n      &lt;div class=\"page-content\"&gt;\n        &lt;h5 class=\"text-center mdl-color-text--primary\"&gt;HTW-Insta&lt;/h5&gt;\n        &lt;div id=\"shared-moments\"&gt;&lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class=\"floating-button\"&gt;\n        &lt;button class=\"mdl-button mdl-js-button mdl-button--fab mdl-button--colored\"\n                id=\"share-image-button\"&gt;\n          &lt;i class=\"material-icons\"&gt;add&lt;/i&gt;\n        &lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div id=\"confirmation-toast\" aria-live=\"assertive\" aria-atomic=\"true\" aria-relevant=\"text\" class=\"mdl-snackbar mdl-js-snackbar\"&gt;\n        &lt;div class=\"mdl-snackbar__text\"&gt;&lt;/div&gt;\n        &lt;button type=\"button\" class=\"mdl-snackbar__action\"&gt;&lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/main&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;script defer src=\"/src/js/material.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/src/js/app.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/src/js/feed.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Sie sieht recht umfangreich aus. Tats\u00e4chlich ist aber das meiste darin f\u00fcr das Navigationstemplate. Die Zeilen <code>21-36</code> und <code>38-49</code> beschreiben das gleiche, n\u00e4mlich die Navigationsleiste. Der obere Block ist f\u00fcr breite Viewports (Klasse <code>mdl-layout--large-screen-only</code>). Alle <code>mdl</code>-Klassen sind von Material. Einen guten \u00dcberblick \u00fcber die einzelnen Material-Komponenten finden Sie hier. N\u00e4heres zu den Navigationen finden Sie darin z.B. hier. Dann kommt das Bild (Zeilen <code>75-77</code>), dann der Text <code>HTW Insta</code> (Zeilen <code>78-81</code>) und dann der <code>+</code>-Button (Zeilen <code>82-87</code>). In den Zeilen <code>88-91</code> ist bereits eine Best\u00e4tigungsnachricht hinterlegt, derzeit aber noch <code>hidden</code>. </p> <p>In den eingebundenen eigenen Stylesheets <code>app.css</code> und <code>feed.css</code> steht nicht viel: </p> public/src/css/app.csspublic/src/css/feed.css <pre><code>.text-center {\ntext-align: center;\n}\n\n.drawer-option {\npadding: 16px;\n}\n</code></pre> <pre><code>#create-post {\nz-index: 1001;\nposition: fixed;\nwidth: 100%;\nmin-height: 100vh;\noverflow-y: scroll;\nbottom: 0;\ntop: 56px;\nbackground: white;\ntext-align: center;\ndisplay: none;\n}\n\n.main-image {\nmax-width: 100%;\nmargin: auto;\ndisplay: block;\n}\n\n.floating-button {\nz-index: 1000;\nposition: fixed;\nbottom: 0;\nright: 0;\npadding: 30px;\n}\n\n.input-section {\ndisplay: block;\nmargin: 10px auto;\n}\n</code></pre> <p>Kurze Erinnerung an CSS: Punktselektoren beschreiben Klassen (z.B. <code>.input-selection</code>) und #-Selektoren beschreiben Ids (z.B. <code>#create-post</code>). Sie k\u00f6nnen die Anwendung der Klassen und der Ids ja mal in der <code>index.html</code> suchen, wenn Sie m\u00f6chten. </p> <p>Die <code>public/help/index.html</code> enth\u00e4lt noch weniger als die <code>public/index.html</code>. Erw\u00e4hnenswert ist hier, dass wir mit einem Framework wie z.B. Angular nat\u00fcrlich der Navigation eine eigenen Komponente spendiert und diese nicht in beiden Dateien wiederholt h\u00e4tten.</p> public/help/index.html <pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta name=\"viewport\"\n        content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt;\n  &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;\n  &lt;title&gt;Help&lt;/title&gt;\n  &lt;link href=\"https://fonts.googleapis.com/css?family=Roboto:400,700\" rel=\"stylesheet\"&gt;\n  &lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"&gt;\n  &lt;link rel=\"stylesheet\"\n        href=\"https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css\"&gt;\n  &lt;link rel=\"stylesheet\" href=\"/src/css/help.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;div id=\"app\"&gt;\n  &lt;div class=\"mdl-layout mdl-js-layout mdl-layout--fixed-header\"&gt;\n    &lt;header class=\"mdl-layout__header\"&gt;\n      &lt;div class=\"mdl-layout__header-row\"&gt;\n        &lt;!-- Title --&gt;\n        &lt;span class=\"mdl-layout-title\"&gt;IKT-PWA&lt;/span&gt;\n        &lt;!-- Add spacer, to align navigation to the right --&gt;\n        &lt;div class=\"mdl-layout-spacer\"&gt;&lt;/div&gt;\n        &lt;!-- Navigation. We hide it in small screens. --&gt;\n        &lt;nav class=\"mdl-navigation mdl-layout--large-screen-only\"&gt;\n          &lt;a class=\"mdl-navigation__link\" href=\"/\"&gt;Bilder&lt;/a&gt;\n          &lt;a class=\"mdl-navigation__link\" href=\"/settings\"&gt;Einstellungen&lt;/a&gt;\n          &lt;div class=\"drawer-option\"&gt;\n            &lt;button class=\"enable-notifications mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\"&gt;\n              Benachrichtigungen Ein\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/nav&gt;\n      &lt;/div&gt;\n    &lt;/header&gt;\n    &lt;div class=\"mdl-layout__drawer\"&gt;\n      &lt;span class=\"mdl-layout-title\"&gt;IKT-PWA&lt;/span&gt;\n      &lt;nav class=\"mdl-navigation\"&gt;\n        &lt;a class=\"mdl-navigation__link\" href=\"/\"&gt;Feed&lt;/a&gt;\n        &lt;a class=\"mdl-navigation__link\" href=\"/help\"&gt;Help&lt;/a&gt;\n        &lt;div class=\"drawer-option\"&gt;\n          &lt;button class=\"enable-notifications mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\"&gt;\n            Benachrichtigungen Ein\n          &lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/nav&gt;\n    &lt;/div&gt;\n    &lt;main class=\"mdl-layout__content mat-typography\"&gt;\n      &lt;div class=\"mdl-grid\"&gt;\n        &lt;div class=\"mdl-cell mdl-cell--12-col text-center\"&gt;\n         &lt;h3&gt;Brauchst Du Hilfe?&lt;/h3&gt;\n          &lt;p&gt;Hier erf\u00e4hrst Du, wie Du die App benutzen und neue Bildeintr\u00e4ge erstellen kannst.&lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class=\"mdl-grid\"&gt;\n        &lt;div class=\"mdl-cell mdl-cell--12-col text-center\"&gt;\n          &lt;h3&gt;Kontakt&lt;/h3&gt;\n          &lt;div&gt;\n            &lt;button class=\"mdl-button mdl-js-button mdl-button--fab mdl-button--colored\"&gt;\n              &lt;i class=\"material-icons\"&gt;call&lt;/i&gt;\n            &lt;/button&gt;\n            &lt;button class=\"mdl-button mdl-js-button mdl-button--fab mdl-button--colored\"&gt;\n              &lt;i class=\"material-icons\"&gt;email&lt;/i&gt;\n            &lt;/button&gt;\n            &lt;button class=\"mdl-button mdl-js-button mdl-button--fab mdl-button--colored\"&gt;\n              &lt;i class=\"material-icons\"&gt;chat_bubble&lt;/i&gt;\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/main&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;script defer src=\"/src/js/material.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/src/js/app.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Von den beiden JavaScript-Dateien <code>public/src/js/app.js</code> und <code>public/src/js/feed.js</code> steht derzeit nur etwas in der <code>feed.js</code>. Das schauen wir uns aber erst dann an, wenn wir neue Bildeintr\u00e4ge speichern wollen. </p>"},{"location":"grundgeruest/#ngrok","title":"Ngrok","text":"<p>Beachten Sie, dass eine Anforderung an eine PWA ist, dass sie entweder unter <code>localhost</code> oder unter <code>https</code> l\u00e4uft. Das Werkzeug ngrok bietet sichere Tunnel an und simuliert so einen sicheren Webserver. Angenommen, Ihre Anwendung l\u00e4uft unter Port <code>8080</code>, dann geben Sie im Terminal einfach </p> <pre><code>ngrok http 8080\n</code></pre> <p>ein und es erscheint in etwa: </p> <pre><code>ngrok by @inconshreveable                                                                                                          (Ctrl+C to quit)\n\nSession Status                online                                                                                                               \nAccount                       J\u00f6rn Freiheit (Plan: Free)                                                                                           \nVersion                       2.3.40                                                                                                               \nRegion                        United States (us)                                                                                                   \nWeb Interface                 http://127.0.0.1:4040                                                                                                \nForwarding                    http://039a-141-45-155-245.ngrok.io -&gt; http://localhost:8080                                                         \nForwarding                    https://039a-141-45-155-245.ngrok.io -&gt; http://localhost:8080                                                        \n\nConnections                   ttl     opn     rt1     rt5     p50     p90                                                                          \n                              11      0       0.00    0.01    0.33    6.43                                                                         \n\nHTTP Requests                                                                                                                                      \n-------------                                                                                                                                      \n\nGET /favicon.ico                     200 OK                                                                                                        \nGET /src/js/feed.js                  200 OK                                                                                                        \nGET /manifest.json                   200 OK                                                                                                        \nGET /src/js/material.min.js          200 OK                                                                                                        \nGET /src/js/app.js                   200 OK                                                                                                        \nGET /src/images/htw.jpg              200 OK                                                                                                        \nGET /src/css/feed.css                200 OK                                                                                                        \nGET /                                200 OK                                                                                                        \nGET /src/css/app.css                 200 OK                                                                                                        \nGET /src/images/icons/fiw256x256.png 200 OK    \n</code></pre> <p>Sie haben nun unter der Adresse <code>https://039a-141-45-155-245.ngrok.io</code> (bei Ihnen anders!) eine <code>https</code>-Verbindung zum Webserver. Sie k\u00f6nnen die Anwendung somit unter dieser Adresse auch in Ihrem Smartphone aufrufen. Lassen Sie sich dazu am besten von Ihrem Browser einen QR-Code erzeugen und fotografieren ihn mit der Kamera ab.</p> <p>Schauen Sie sich auch ruhig einmal das Web-Interface von ngrok an, das unter <code>http://127.0.0.1:4040</code> verf\u00fcgbar ist. </p> <p>Noch besser ist es (und ngrok empfiehlt das), Sie verwenden</p> <pre><code>ngrok http 8000 --basic-auth 'ngrok:issecure'\n</code></pre> <p>Damit sichern Sie die Seite durch einen <code>account:password</code>-Zugriff. Sie werden beim Starten Seite aufgefordert, einen Nutzerinnennamen und ein Passwort einzugeben. In diesem Fall w\u00e4ren das <code>ngrok</code> und <code>issecure</code>. Nat\u00fcrlich k\u00f6nnen Sie bei Aufruf von <code>ngrok</code> auch eine frei w\u00e4hlbare Kombination <code>'account:password'</code> verwenden (anstelle von <code>'ngrok:issecure'</code>).</p>"},{"location":"images/","title":"Backend-Erweiterung um das Speichern von Bildern","text":"Video zur Vorlesung <p>Bis jetzt haben wir nur Daten im JSON-Format zwischen Frontend und Backend ausgetauscht und auch nur solche Daten in der MongoDB gespeichert. Bilder (und auch andere Dateien) sind FormData-Objects im <code>multipart/form-data</code>-Format. Zur Behandlung solcher Daten verwenden wir ein Middleware f\u00fcr unser Backend, namens Multer. </p> <p>Hint<p>Wenn Sie nur am Code f\u00fcr unser Backend interessiert sind, dann k\u00f6nnen Sie auch direkt zu Zusammenf\u00fchren der Funktionalit\u00e4ten springen. Im Folgenden werden die Entstehung aber n\u00e4her erl\u00e4utert und verschiedene Varianten diskutiert. </p> </p> <p>MongoDB speichert Daten bis zu einer Gr\u00f6\u00dfe von <code>16Mb</code> im Bin\u00e4rformat. Um auch gr\u00f6\u00dfere Dateien (Bilder, Videos, pdf, ...) speichern zu k\u00f6nnen, werden die Dateien in chunks zerlegt und k\u00f6nnen dann aus diesen St\u00fccken wieder zusammengesetzt werden. Daf\u00fcr gibt es in der MongoDB eine GridFS-Spezifikation (siehe auch hier oder hier). Zur Verwendung von GridFS gibt es die beiden Pakte multer-gridfs-storage und gridfs-stream. </p> <p>Wir installieren im Backend-Projekt alle drei Pakete und zeigen im Folgenden deren Verwendung:</p> <pre><code>npm install multer multer-gridfs-storage gridfs-stream\n</code></pre> <p>Die <code>package.json</code> sollte nun ungef\u00e4hr so aussehen:</p> package.json <pre><code>{\n\"name\": \"backend\",\n\"version\": \"1.0.0\",\n\"description\": \"Backend REST-API\",\n\"main\": \"server.js\",\n\"scripts\": {\n\"watch\": \"nodemon ./server.js\",\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n\"keywords\": [\n\"rest\",\n\"api\",\n\"backend\",\n\"mongodb\"\n],\n\"repository\": {\n\"type\": \"git\",\n\"url\": \"https://github.com/jfreiheit/IKT-PWA-Backend.git\"\n},\n\"author\": \"J. Freiheit\",\n\"license\": \"ISC\",\n\"dependencies\": {\n\"cors\": \"^2.8.5\",\n\"dotenv\": \"^16.0.3\",\n\"express\": \"^4.18.2\",\n\"gridfs-stream\": \"^1.1.1\",\n\"mongodb\": \"^5.4.0\",\n\"mongoose\": \"^7.1.1\",\n\"multer\": \"^1.4.4-lts.1\",\n\"multer-gridfs-storage\": \"5.0.2\"\n},\n\"devDependencies\": {\n\"nodemon\": \"^2.0.22\"\n}\n}\n</code></pre> <p>Wir k\u00fcmmern uns nun zun\u00e4chst darum, Bilder in die MongoDB hochzuladen.</p>"},{"location":"images/#upload-von-bildern","title":"Upload von Bildern","text":"<p>F\u00fcr den Upload der Bilder erstellen wir zun\u00e4chst einen Ordner <code>middleware</code> und darin eine Datei <code>upload.js</code>. In dieser Datei wird unter Verwendung von <code>Multer</code> ein <code>GridFsStorage</code> eingerichtet. Die zu verwendende Collection benennen wir hier <code>posts</code> (siehe <code>bucketName</code>). Die Datenbank hei\u00dft <code>image</code> (siehe <code>dbName</code>). Sie k\u00f6nnen diese Namen frei w\u00e4hlen. Beachten Sie dann aber im Folgenden \u00fcberall die Verwendung von <code>posts</code> (in der MongoDB entstehen die Collections <code>posts.files</code> und <code>posts.chunks</code> - siehe z.B. hier oder hier).</p> middleware/upload.js <pre><code>const multer = require(\"multer\");\nconst {\nGridFsStorage\n} = require(\"multer-gridfs-storage\");\nconst mongoose = require('mongoose');\nrequire('dotenv').config();\n\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst storage = new GridFsStorage({\n//db: connection,\nurl: process.env.DB_CONNECTION,\noptions: { sslKey: credentials,        // nur falls ein Zertifikat zur Autorisierung\nsslCert: credentials,       // f\u00fcr MongoDB Atlas verwendet wird\ndbName: \"images\" },\nfile: (req, file) =&gt; {\nconst match = [\"image/png\", \"image/jpeg\"];\n\nif (match.indexOf(file.mimetype) === -1) {\nconsole.log('file.mimetype === -1')\nreturn `${Date.now()}-jf-${file.originalname}`;\n}\nconsole.log('store');\nreturn {\nbucketName: 'posts',\nfilename: `${Date.now()}-jf-${file.originalname}`,\n};\n},\n});\n\nmodule.exports = multer({ storage });\n</code></pre> <p>Beachten Sie, dass wir beim Upload der Bilder f\u00fcr diese Bilder Dateinamen mithilfe von <code>${Date.now()}-jf-${file.originalname}</code> erstellen bzw. festlegen. Damit diese Dateinamen eindeutig sind, wird mithilfe von <code>Date.now()</code> der aktuelle Zeitstempel verwendet. Der String <code>-jf-</code> in der Mitte kann nat\u00fcrlich auch durch Ihre Initialen ersetzt (oder weggelassen) werden. Au\u00dferdem wird auch noch der originale Dateiname verwendet. Insgesamt sollte sichergestellt werden, dass die Dateinamen eindeutig sind (deshalb auch <code>Date.now()</code>). </p> <p>In Zeile <code>19</code> werden die Dateitypen festgelegt, die akzeptiert werden, hier <code>png</code> und <code>jpeg</code>. Diese Liste kann erweitert oder eingegrenzt werden.</p> <p>Diese Middleware nutzen wir nun f\u00fcr den <code>POST</code>-Request des Bildes und erstellen einen Ordner <code>routes</code> und darin eine Datei <code>upload.routes.js</code> mit folgendem Inhalt:</p> routes/upload.route.js <pre><code>const express = require('express');\nconst upload = require('../middleware/upload');\nconst router = express.Router();\n\nrouter.post('/', upload.single('file'), (req, res) =&gt; {\nif (req.file === undefined) {\nreturn res.send({\n\"message\": \"no file selected\"\n});\n} else {\nconsole.log('req.file', req.file);\nconst imgUrl = `http://localhost:3000/download/${req.file.filename}`;\nreturn res.status(201).send({\nurl: imgUrl\n});\n}\n})\n\nmodule.exports = router;\n</code></pre> <p>In Zeile <code>5</code> wird die multer-Middleware mit <code>update.single('file')</code> aufgerufen. Neben der Funktion <code>.single(fieldname)</code> stehen auch die Funktionen <code>.array(fieldname[, maxCount])</code> und <code>.fields(field)</code> zur Verf\u00fcgung, um gleichzeitig mehrere Dateien hochzuladen (siehe multer). </p> <p>Als Response wird die URL zur\u00fcckgegeben, unter der das Bild heruntergeladen werden kann (<code>http://localhost:3000/download/${req.file.filename}</code>). Beachten Sie, dass die Backend-URL und auch der Port hier hart kodiert sind. Das sollte besser in die <code>.env</code>-Datei ausgelagert werden. </p>"},{"location":"images/#routen-andern-und-einbinden","title":"Routen \u00e4ndern und einbinden","text":"<p>In der urspr\u00fcnglichen Implementierung hatten wir die Datei <code>routes.js</code> noch im Projektordner gehabt. Wir benennen diese in <code>posts.routes.js</code> um und schieben sie ebenfalls in den <code>routes</code>-Ordner. Beachten Sie, dass Sie dadurch in der <code>server.js</code> auch den Import auf <code>const routes = require('./routes/posts.routes');</code> \u00e4ndern m\u00fcssen.</p> <p>Da wir nun aber auch die <code>upload</code>-Route einbinden, \u00e4ndern wir gleich mehrere Sachen. Zun\u00e4chst wird der urspr\u00fcngliche <code>routes</code> zu <code>postRoutes</code> und die generelle Route daf\u00fcr wird <code>/posts</code>:</p> server.js <pre><code>const express = require('express')\nconst cors = require('cors')\nconst postsRoutes = require('./routes/posts.routes')\nconst uploadRoutes = require('./routes/upload.routes');\nconst mongoose = require('mongoose');\nrequire('dotenv').config();\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst app = express()\nconst PORT = 3000;\n\napp.use(express.json());\napp.use(cors())\napp.use('/posts', postsRoutes);\napp.use('/upload', uploadRoutes);\n// connect to mongoDB\nmongoose.connect(process.env.DB_CONNECTION, { sslKey: credentials,\nsslCert: credentials,\ndbName: process.env.DATABASE });\n\nconst db = mongoose.connection;\ndb.on('error', err =&gt; {\nconsole.log(err);\n});\ndb.once('open', () =&gt; {\nconsole.log('connected to DB');\n});\n\napp.listen(PORT, (error) =&gt; {\nif(error) {\nconsole.log('error', error)\n} else {\nconsole.log(`server running on http://localhost:${PORT}`)\n}\n})\n</code></pre> <p>In der <code>posts.routes.js</code> kann nun aus den URLs der Endpunkte jeweils das <code>/posts</code> entfernt werden:</p> routes/posts.routes.js <pre><code>const express = require('express');\nconst router = express.Router();\nconst Post = require('../models/posts');\n\n// GET all posts\nrouter.get('/', async(req, res) =&gt; {\nconst allPosts = await Post.find();\nconsole.log(allPosts);\nres.send(allPosts);\n});\n\n// POST one post\nrouter.post('/', async(req, res) =&gt; {\nconst newPost = new Post({\ntitle: req.body.title,\nlocation: req.body.location,\nimage_id: req.body.image_id\n})\nawait newPost.save();\nres.send(newPost);\n});\n\n// POST one post via id\nrouter.get('/:id', async(req, res) =&gt; {\ntry {\nconst post = await Post.findOne({ _id: req.params.id });\nconsole.log(req.params);\nres.send(post);\n} catch {\nres.status(404);\nres.send({\nerror: \"Post does not exist!\"\n});\n}\n});\n\n// PATCH (update) one post\nrouter.patch('/:id', async(req, res) =&gt; {\ntry {\nconst post = await Post.findOne({ _id: req.params.id })\n\nif (req.body.title) {\npost.title = req.body.title\n}\n\nif (req.body.location) {\npost.location = req.body.location\n}\n\nif (req.body.image_id) {\npost.image_id = req.body.image_id\n}\n\nawait Post.updateOne({ _id: req.params.id }, post);\nres.send(post)\n} catch {\nres.status(404)\nres.send({ error: \"Post does not exist!\" })\n}\n});\n\n// DELETE one post via id\nrouter.delete('/:id', async(req, res) =&gt; {\ntry {\nawait Post.deleteOne({ _id: req.params.id })\nres.status(204).send()\n} catch {\nres.status(404)\nres.send({ error: \"Post does not exist!\" })\n}\n});\n\nmodule.exports = router;\n</code></pre>"},{"location":"images/#upload-mithilfe-von-postman","title":"Upload mithilfe von Postman","text":"<p>Das Hochladen der Bilder kann nun bereits getestet werden. Starten Sie das Backend. \u00d6ffnen Sie Postman und geben Sie als URL <code>http://localhost:3000/upload</code> ein und w\u00e4hlen als Anfragemethode <code>POST</code>. Klicken Sie auf <code>Body</code> und markieren dann <code>form-data</code>:</p> <p></p> <p>Geben Sie unter <code>KEY</code> den Schl\u00fcssel <code>file</code> ein (das wird manchmal vergessen und dann bekommen Sie einen <code>multer</code>-Fehler <code>unexpected field</code>!) und w\u00e4hlen Sie aus dem Dropdown-Men\u00fc <code>File</code>. Unter <code>VALUE</code> erscheint der Button <code>Select Files</code>. Klicken Sie darauf und w\u00e4hlen ein <code>png</code>- oder ein <code>jpeg</code>-Bild (kann auch <code>.jpg</code> sein) aus, das Sie hochladen wollen. Klicken Sie dann auf <code>Send</code>. Es erscheint:</p> <p></p> <p>Ich habe in diesem Beispiel die Datei <code>fiw.jpg</code> hochgeladen. </p> <p>Wenn Sie sich die MongoDB anschauen (in Compass), dann finden Sie darin die beiden Collections <code>posts.files</code> und <code>posts.chunks</code>. In <code>posts.files</code> sind die Metadaten des hochgeladenen Bildes zu finden, z.B. </p> <pre><code>{\n\"_id\": {\n\"$oid\": \"646062e135cc14afbf5fd29b\"\n},\n\"length\": 86584,\n\"chunkSize\": 261120,\n\"uploadDate\": {\n\"$date\": \"2023-05-14T04:26:10.472Z\"\n},\n\"filename\": \"1684038369483-jf-fiw.jpg\",\n\"contentType\": \"image/jpeg\"\n}\n</code></pre> <p>Die dazugeh\u00f6rige <code>_id</code> finden Sie auch in <code>posts.chunks</code> (k\u00f6nnen Sie sich in der <code>mongosh</code> mit <code>db.posts.chunks.find({ _id: \"646062e135cc14afbf5fd29b\" })</code> anschauen). Darin ist das Bild im Binary-Format gespeichert. </p>"},{"location":"images/#download-von-bildern","title":"Download von Bildern","text":"<p>F\u00fcr den Download der gespeicherten Bilder gehen wir \u00e4hnlich vor, wie beim Upload, ben\u00f6tigen daf\u00fcr aber nicht mehr die multer-Middleware, daf\u00fcr aber <code>gridfs-stream</code>. Wir erstellen im Ordner <code>routes</code> die Datei <code>download.routes.js</code> mit folgendem Inhalt:</p> routes/download.routes.js <pre><code>const express = require('express');\nconst mongoose = require('mongoose');\nconst Grid = require(\"gridfs-stream\");\nconst router = express.Router();\nrequire('dotenv').config();\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst connection = mongoose.createConnection(process.env.DB_CONNECTION, { sslKey: credentials,\nsslCert: credentials,\ndbName: \"images\" });\n\nlet gfs, gfsb;\nconnection.once('open', () =&gt; {\n// initialize stream\ngfsb = new mongoose.mongo.GridFSBucket(connection.db, {\nbucketName: \"posts\"\n});\n\ngfs = Grid(connection.db, mongoose.mongo);\n});\n\nrouter.get('/:filename', async(req, res) =&gt; {\ntry {\nconst cursor = await gfs.collection('posts').find({ filename: req.params.filename });\ncursor.forEach(doc =&gt; {\nconsole.log('doc', doc);\ngfsb.openDownloadStream(doc._id).pipe(res);\n})\n} catch (error) {\nconsole.log('error', error);\nres.send(\"not found\");\n}\n});\n\nmodule.exports = router;\n</code></pre> <p>GridFSBucket ist eine Klasse aus der Node.js-MongoDB-API. Diese h\u00e4tten wir auch schon f\u00fcr das Upload verwenden k\u00f6nnen (siehe z.B. hier). </p> <p>Da wir \u00fcber den Dateinamen auf die Datei zugreifen wollen, ben\u00f6tigen wir zun\u00e4chst die entsprechende <code>_id</code> der Datei in der <code>posts.chunks</code>-Collection. Dazu greifen wir mithilfe von <code>find()</code> auf die <code>posts.files</code>-Collection zu und ermitteln die <code>_id</code>. Die <code>find()</code>-Funktion gibt einen sogenannten Cursor auf das Array aller gefundenen Datens\u00e4tze zur\u00fcck. Mithilfe von <code>forEach()</code> durchlaufen wir dieses Array (enth\u00e4lt aber nur einen Datensatz) und ermitteln die <code>_id</code>. Mit der <code>openDownloadStream()</code>-Funktion der <code>GridFSBucket()</code>-Klasse \u00f6ffnen wir den Download-Stream des Bildes und geben ihn als response <code>res</code> zur\u00fcck. </p> <p>Wir binden die <code>download</code>-Route nun noch in unsere <code>server.js</code> ein:</p> server.js <pre><code>const express = require('express')\nconst cors = require('cors')\nconst postsRoutes = require('./routes/posts.routes')\nconst uploadRoutes = require('./routes/upload.routes');\nconst downloadRoute = require('./routes/download.routes');\nconst mongoose = require('mongoose');\nrequire('dotenv').config();\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst app = express()\nconst PORT = 3000;\n\napp.use(express.json());\napp.use(cors())\napp.use('/posts', postsRoutes);\napp.use('/upload', uploadRoutes);\napp.use('/download', downloadRoute);\n// connect to mongoDB\nmongoose.connect(process.env.DB_CONNECTION, { sslKey: credentials,\nsslCert: credentials,\ndbName: process.env.DATABASE });\n\nconst db = mongoose.connection;\ndb.on('error', err =&gt; {\nconsole.log(err);\n});\ndb.once('open', () =&gt; {\nconsole.log('connected to DB');\n});\n\napp.listen(PORT, (error) =&gt; {\nif(error) {\nconsole.log('error', error)\n} else {\nconsole.log(`server running on http://localhost:${PORT}`)\n}\n})\n</code></pre>"},{"location":"images/#download-mithilfe-von-postman","title":"Download mithilfe von Postman","text":"<p>Der Test des <code>GET http://localhost:3000/download/:filename</code>-Endpunktes ist einfach. Dazu verwenden wir einfach die URL, die durch den Upload als Response  zur\u00fcckgegeben wurde (im obigen Beispiel also <code>\"http://localhost:3000/download/1684038369483-jf-fiw.jpg\"</code>):</p> <p>Geben Sie in Postman also Ihre URL ein, w\u00e4hlen <code>GET</code> und klicken <code>Send</code>. Es erscheint das Bild:</p> <p></p> <p>Da es sich um die GET-Methode handelt, k\u00f6nnen Sie die URL <code>http://localhost:3000/download/1684038369483-jf-fiw.jpg</code> nat\u00fcrlich auch in den Browser eingeben und das Bild erscheint. </p>"},{"location":"images/#delete-von-bildern","title":"Delete von Bildern","text":"<p>Das L\u00f6schen der Bilder ist ganz \u00e4hnlich zum Download. Erstellen Sie die Datei <code>routes/delete.route.js</code>:</p> routes/delete.routes.js <pre><code>const express = require('express');\nconst mongoose = require('mongoose');\nconst Grid = require(\"gridfs-stream\");\nconst router = express.Router();\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst connection = mongoose.createConnection(process.env.DB_CONNECTION, { sslKey: credentials,\nsslCert: credentials,\ndbName: \"images\" });\n\nlet gfs;\nconnection.once('open', () =&gt; {\ngfs = Grid(connect.db, mongoose.mongo);\ngfs.collection('posts');\n});\n\nrouter.delete('/:filename', async(req, res) =&gt; {\ntry {\nawait gfs.collection('posts').deleteOne({ filename: req.params.filename });\nres.send({\n\"message\": \"deleted\"\n});\n} catch (error) {\nconsole.log('error', error);\nres.send(\"An error occured.\");\n}\n});\n\nmodule.exports = router;\n</code></pre> <p>und binden diese in die <code>server.js</code> ein:</p> server.js <pre><code>const express = require('express');\nconst cors = require('cors');\nconst postsRoutes = require('./routes/posts.routes');\nconst uploadRoutes = require('./routes/upload.routes');\nconst downloadRoute = require('./routes/download.routes');\nconst deleteRoute = require('./routes/delete.routes');\nconst mongoose = require('mongoose');\nrequire('dotenv').config();\n\nconst app = express();\napp.use(express.json());\napp.use(cors());\n\napp.use('/posts', postsRoutes);\napp.use('/image', uploadRoutes);\napp.use('/download', downloadRoute);\napp.use('/delete', deleteRoute);\napp.listen(process.env.PORT, (error) =&gt; {\nif (error) {\nconsole.log(error);\n} else {\nconsole.log(`server running on http://localhost:${process.env.PORT}`);\n}\n});\n\n// connect to mongoDB\nmongoose.connect(process.env.DB_CONNECTION, { useNewUrlParser: true, useUnifiedTopology: true });\nconst db = mongoose.connection;\ndb.on('error', console.error.bind(console, 'connection error:'));\ndb.once('open', () =&gt; {\nconsole.log('connected to DB');\n});\n</code></pre>"},{"location":"images/#delete-mithilfe-von-postman","title":"Delete mithilfe von Postman","text":"<p>Zum Testen verwenden Sie den gleichen Dateinamen wie beim Download und w\u00e4hlen als Anfragemethode <code>DELETE</code>. </p>"},{"location":"images/#zusammenfuhren-der-funktionalitaten","title":"Zusammenf\u00fchren der Funktionalit\u00e4ten","text":"<p>Wir haben nun recht viele Routen und Endpunkte in unserem Backend. Wir wollen aber gerne, dass es nur die f\u00fcnf genannten Endpunkte gibt:</p> \u00a0Methode \u00a0URL \u00a0Bedeutung \u00a0GET \u00a0/posts \u00a0hole alle Datens\u00e4tze \u00a0GET \u00a0/posts/11 hole den Datensatz mit der id=11 \u00a0POST \u00a0/posts \u00a0f\u00fcge einen neuen Datensatz hinzu \u00a0PUT \u00a0/posts/11 \u00a0\u00e4ndere den Datensatz mit der id=11 \u00a0DELETE \u00a0/posts/11 \u00a0l\u00f6sche den Datensatz mit der id=11 <p>Das bedeutet, wir binden den Upload und Download von Bildern nun in unsere <code>posts</code>-Routen ein. Die Funktionen werden dabei \"etwas\" umfangreicher. </p>"},{"location":"images/#zum-verstandnis","title":"Zum Verst\u00e4ndnis","text":"<p>Wir verwenden Multer und GridFs storage. Multer ist eine Middleware f\u00fcr Node.js, um Daten im <code>multipart/form-data</code>-Format zu verwalten. Die grunds\u00e4tzliche Idee ist, dass im Request nicht nur ein <code>body</code>, sondern auch eine <code>file</code>-Eigenschaft enthalten ist (neben dem <code>header</code>). Multer verwendet einen <code>storage</code>, um Bilder (oder andere Dateien) zu speichern. Einen solchen <code>storage</code> bietet <code>GridFs storage</code>. Dieser kann sogar Dateien gr\u00f6\u00dfer als 16 MB speichern und die Idee dabei ist, dass die Datei in zwei Collections gespeichert wird, in der <code>files</code>-Collection, welche die (Meta-)Informationen der Datei speichert und der <code>chunks</code>-Collection, die die eigentliche Datei (als Bin\u00e4rdaten) speichert. Eine Datei kann dabei in mehrere <code>chunks</code> unterteilt werden. Die folgende Abbildung zeigt das Prinzip von <code>GridFS</code>:</p> <p></p> <p>F\u00fcr unser Datenmodell sieht die Aufteilung der Daten somit wie folgt aus:</p> <ul> <li> <p>in der <code>posts</code>-Collection speichern wir</p> <ul> <li>die <code>_id</code> des Posts,</li> <li>den <code>title</code> eines Posts,</li> <li>die <code>location</code> und </li> <li>die <code>image_id</code>. Die <code>image_id</code> enth\u00e4lt den Dateinamen <code>filename</code> des Bildes.</li> </ul> </li> <li> <p>in der <code>posts.files</code>-Collection speichern wir (GridFs)</p> <ul> <li>die <code>_id</code> der Datei,</li> <li>die <code>length</code> der Datei,</li> <li>die <code>chunkSize</code>, </li> <li>das <code>uploadDate</code>, </li> <li>den <code>filename</code> (siehe in <code>posts</code> die <code>image_id</code>) und </li> <li>den <code>contenType</code> (z.B. <code>image/jpeg</code>)</li> </ul> </li> <li> <p>in der <code>posts.chunks</code>-Collection speichern wir (GridFs)</p> <ul> <li>die <code>_id</code> des Chunks,</li> <li>die <code>files_id</code> (diese entspricht der <code>_id</code> der Datei in der <code>posts.files</code>-Collection),</li> <li>ein <code>n</code> (fortlaufende Nummerierung der Chunks einer Datei beginnend mit <code>0</code>),</li> <li>die <code>data</code> der Datei (in diesem Chunk)</li> </ul> </li> </ul> <p>Chunks kann es zu einer Datei mehrere geben. Alle <code>data</code> aller Chunks einer Datei bilden zusammen die Datei als Bin\u00e4r- (bzw. base64-) Daten. Die folgende Abbildung zeigt unser Datenmodell in der Datenbank <code>posts</code>:</p> <p></p> <p>Um z.B. einen Datensatz (einen Post) anzulegen, speichern wir also die zugeh\u00f6rigen Daten in der <code>posts</code>-Collection (inkl. dem <code>filename</code> der Datei), speichern die Meta-Informationen der Datei in der <code>posts.files</code>-Collection und die zugeh\u00f6rigen Bin\u00e4rdaten der Datei in <code>posts.chunks</code>. </p>"},{"location":"images/#post-kompletter-datensatz","title":"POST - kompletter Datensatz","text":"<p>Die <code>POST</code>-Funktion f\u00fcr einen Datensatz ist nicht viel umfangreicher als zuvor:</p> aus routes/posts.routes.js <pre><code>  // POST one post\nrouter.post('/', upload.single('file'), async(req, res) =&gt; {\n// req.file is the `file` file\nif (req.file === undefined) {\nreturn res.send({\n\"message\": \"no file selected\"\n});\n} else {\nconsole.log('req.body', req.body);\nconst newPost = new Post({\ntitle: req.body.title,\nlocation: req.body.location,\nimage_id: req.file.filename\n})\nawait newPost.save();\nreturn res.send(newPost);\n}\n})\n</code></pre> <p>Wichtig ist, dass <code>posts.routes.js</code> nun auch die <code>upload.js</code> einbindet:</p> aus routes/posts.routes.js <p><pre><code>const upload = require('../middleware/upload');\n</code></pre> Achten Sie darauf, dass Sie in <code>upload.js</code> die korrekte Datenbank verwenden (siehe <code>dbName</code>)!</p> <p>Beachten Sie, dass die Daten nun nicht mehr als JSON \u00fcbergeben werden, sondern als <code>form-data</code>. Der Test mithilfe von Postman sieht deshalb nun so aus:</p> <p> </p> <p>Als Response bekommen Sie aber wieder ein JSON zur\u00fcck, z.B.:</p> <pre><code>{\n\"title\": \"HTW Geb\u00e4ude C\",\n\"location\": \"Campus Wilhelminenhof\",\n\"image_id\": \"1652166642127-jf-htwbild5.jpg\",\n\"_id\": \"627a0ff2305433d805b6b437\",\n\"__v\": 0\n}\n</code></pre> <p>Das Bild ist nun in der Collection <code>posts</code> einerseits in <code>posts.files</code> mit den Daten</p> <p> </p> <p>und in <code>posts.chunks</code> mit den Daten</p> <p> </p> <p>gespeichert. Beachten Sie, dass das Bild so klein ist, dass es in nur einem <code>chunk</code> gespeichert werden kann. Gr\u00f6\u00dfere Dateien werden in mehrer <code>chunks</code> aufgeteilt. Alle diese <code>chunks</code>, die zu einem Bild geh\u00f6ren, haben dann dieselbe <code>files_id</code> (aber fortlaufende <code>_id</code>s).</p> <p>In der <code>posts</code>-Collection sieht der Datensatz dann wie folgt aus:</p> <p> </p>"},{"location":"images/#get-ein-kompletter-datensatz","title":"GET - ein kompletter Datensatz","text":"<p>Jetzt den kompletten Datensatz mit einer bestimmten <code>_id</code> zu laden, ist etwas aufwendiger:</p> <ol> <li>Wir laden zun\u00e4chst aus der <code>posts</code>-Collection den Datensatz mit der <code>_id</code>. </li> <li>Aus diesem Datensatz lesen wir die <code>image_id</code> aus. Das ist der <code>filename</code> mit dem wir in der <code>posts.files</code>-Collection suchen. </li> <li>Aus der <code>posts.files</code>-Collection lesen wir den Datensatz mit dem <code>filename</code> aus und identifizieren dessen <code>_id</code>. </li> <li>Nach dieser <code>_id</code> suchen wir unter <code>files_id</code> in der <code>posts.chunks</code>-Collection und lesen alle zugeh\u00f6rigen <code>chunks</code> aus. </li> </ol> <p>Dazu schreiben wir uns zun\u00e4chst eine Funktion <code>getOnePost(id)</code>, die ein <code>Promise</code> zur\u00fcckgibt.</p> aus routes/posts.routes.js <pre><code>require('dotenv').config();\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst connection = mongoose.createConnection(process.env.DB_CONNECTION, { sslKey: credentials,\nsslCert: credentials,\ndbName: \"htwinsta\" });\n\nfunction getOnePost(id) {\n\nreturn new Promise( async(resolve, reject) =&gt; {\ntry {\n\nconst post = await Post.findOne({ _id: id });\nlet fileName = post.image_id;\nconst files = connection.collection('posts.files');\nconst chunks = connection.collection('posts.chunks');\n\nconst cursorFiles = files.find({filename: fileName});\nconst allFiles = await cursorFiles.toArray();\nconst cursorChunks = chunks.find({files_id : allFiles[0]._id});\nconst sortedChunks = cursorChunks.sort({n: 1});\nlet fileData = [];\nfor await (const chunk of sortedChunks) {\nfileData.push(chunk.data.toString('base64'));\n}\nlet base64file = 'data:' + allFiles[0].contentType + ';base64,' + fileData.join('');\nlet getPost = new Post({\n\"title\": post.title,\n\"location\": post.location, \"image_id\": base64file\n});\n//console.log('getPost', getPost)\nresolve(getPost)\n} catch {\nreject(new Error(\"Post does not exist!\"));\n}\n})\n}\n</code></pre> <p>Die Konsolenausgaben k\u00f6nnen nat\u00fcrlich auch alle entfernt werden, aber es lohnt sich vielleicht auch zu sehen, was an den einzelnen Stellen passiert. In Zeile <code>37</code> erfolgt der Zugriff auf die <code>posts</code>-Collection und es wird der Datensatz mit der <code>_id</code> ermittelt, welche als Parameter der URL \u00fcbergeben wurde. Aus dem Ergebnis <code>post</code> wird dann der Dateiname des Bildes in Zeile <code>37</code> mithilfe von <code>post.image_id</code> ermittelt. </p> <p>In der <code>post.files</code>-Collection wird in Zeile <code>42</code> nach dem Datensatz mit dem entsprechenden <code>filename</code> gesucht. Die <code>_id</code> dieses Datensatzes ist der Wert von <code>files_id</code> in der Collection <code>posts.chunks</code>. Nach all diesen Eintr\u00e4gen wird in Zeile <code>44</code> gesucht. Aus allen <code>chunks</code> wird dann der <code>base64</code>-String erzeugt und dem <code>Post</code>-Objekt \u00fcbergeben, welches als <code>resolve</code> der <code>Promise</code> zur\u00fcckgeschickt wird. </p> <p>Diese Funktion k\u00f6nnen wir nun f\u00fcr unseren <code>get('/:id')</code>-Endpunkt verwenden. Die Funktion sieht dann wie folgt aus:</p> aus routes/posts.routes.js <pre><code>// GET one post via id\nrouter.get('/:id', async(req, res) =&gt; {\ngetOnePost(req.params.id)\n.then( (post) =&gt; {\nconsole.log('post', post);\nres.send(post);\n})\n.catch( () =&gt; {\nres.status(404);\nres.send({\nerror: \"Post does not exist!\"\n});\n})\n});\n</code></pre> <p>Wir \u00fcbergeben der <code>getOnePost()</code>-Funktion die als Parameter \u00fcbergebene <code>id</code> und senden den <code>resolve</code>-Wert der <code>Promise</code> als Response zur\u00fcck. </p>"},{"location":"images/#get-alle-datensatze","title":"GET - alle Datens\u00e4tze","text":"<p>Der Ansatz, um alle Datens\u00e4tze aus der MongoDB zu lesen, ist der gleiche, wie f\u00fcr einen Datensatz. Wir ermitteln sukzessive die <code>_id</code> alle Datens\u00e4tze in der <code>posts</code>-Collection. Dazu schreiben wir uns eine Funktion <code>getAllPosts()</code>. In dieser laden wir zun\u00e4chst alle <code>posts</code> und rufen dann f\u00fcr jeden einzelnen die <code>getOnePost(id</code>-Funktion auf:</p> aus routes/posts.routes.js <pre><code>function getAllPosts() {\nreturn new Promise( async(resolve, reject) =&gt; {\nconst sendAllPosts = [];\nconst allPosts = await Post.find();\ntry {\nfor(const post of allPosts) {\nconsole.log('post', post)\nconst onePost = await getOnePost(post._id);\nsendAllPosts.push(onePost);\n}\nconsole.log('sendAllPosts', sendAllPosts)\nresolve(sendAllPosts)\n} catch {\nreject(new Error(\"Posts do not exist!\"));\n}\n});\n}\n</code></pre> <p>Die Verwendung dieser Funktion ist wie oben:</p> aus routes/posts.routes.js <pre><code>// GET all posts\nrouter.get('/', async(req, res) =&gt; {\n\ngetAllPosts()\n.then( (posts) =&gt; {\nres.send(posts);\n})\n.catch( () =&gt; {\nres.status(404);\nres.send({\nerror: \"Post do not exist!\"\n});\n})\n});\n</code></pre>"},{"location":"images/#delete-einen-datensatz","title":"DELETE - einen Datensatz","text":"<p>Wird ein Post gel\u00f6scht, m\u00fcssen wir auch daf\u00fcr sorgen, dass das zugeh\u00f6rige Bild aus der <code>posts.files</code> und der <code>posts.chunks</code> gel\u00f6scht wird. Das L\u00f6schen ist also dreistufig:</p> aus routes/posts.routes.js <pre><code>// DELETE one post via id\nrouter.delete('/:id', async(req, res) =&gt; {\ntry {\nconst post = await Post.findOne({ _id: req.params.id })\nlet fileName = post.image_id;\nawait Post.deleteOne({ _id: req.params.id });\nawait files.find({filename: fileName}).toArray( async(err, docs) =&gt; {\nawait chunks.deleteMany({files_id : docs[0]._id});\n})\nawait files.deleteOne({filename: fileName});\nres.status(204).send()\n} catch {\nres.status(404)\nres.send({ error: \"Post does not exist!\" })\n}\n});\n</code></pre>"},{"location":"images/#zusammenfassung-code-des-backends","title":"Zusammenfassung - Code des Backends","text":"<p>Hier nochmal alle wichtigen Dateien unseres Backends:</p> server.js <pre><code>const express = require('express')\nconst cors = require('cors')\nconst postsRoutes = require('./routes/posts.routes')\nconst uploadRoutes = require('./routes/upload.routes');\nconst downloadRoute = require('./routes/download.routes');\nconst deleteRoute = require('./routes/delete.routes');\nconst mongoose = require('mongoose');\nrequire('dotenv').config();\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst app = express()\nconst PORT = 3000;\n\napp.use(express.json());\napp.use(cors())\napp.use('/posts', postsRoutes);\napp.use('/upload', uploadRoutes);\napp.use('/download', downloadRoute);\napp.use('/delete', deleteRoute);\n\n// connect to mongoDB\nmongoose.connect(process.env.DB_CONNECTION, { sslKey: credentials,\nsslCert: credentials,\ndbName: process.env.DATABASE });\n\nconst db = mongoose.connection;\ndb.on('error', err =&gt; {\nconsole.log(err);\n});\ndb.once('open', () =&gt; {\nconsole.log('connected to DB');\n});\n\napp.listen(PORT, (error) =&gt; {\nif(error) {\nconsole.log('error', error)\n} else {\nconsole.log(`server running on http://localhost:${PORT}`)\n}\n})\n</code></pre> middleware/upload.js <pre><code>const multer = require(\"multer\");\nconst {\nGridFsStorage\n} = require(\"multer-gridfs-storage\");\nconst mongoose = require('mongoose');\nrequire('dotenv').config();\n\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst storage = new GridFsStorage({\n//db: connection,\nurl: process.env.DB_CONNECTION,\noptions: { sslKey: credentials,        // nur falls ein Zertifikat zur Autorisierung\nsslCert: credentials,       // f\u00fcr MongoDB Atlas verwendet wird\ndbName: \"htwinsta\" },\nfile: (req, file) =&gt; {\nconst match = [\"image/png\", \"image/jpeg\"];\n\nif (match.indexOf(file.mimetype) === -1) {\nconsole.log('file.mimetype === -1')\nreturn `${Date.now()}-jf-${file.originalname}`;\n}\nconsole.log('store');\nreturn {\nbucketName: 'posts',\nfilename: `${Date.now()}-jf-${file.originalname}`,\n};\n},\n});\n\nmodule.exports = multer({ storage });\n</code></pre> routes/posts.routes.js <pre><code>const express = require('express')\nconst router = express.Router()\nconst mongoose = require('mongoose');\nconst Post = require('../models/posts');\nconst upload = require('../middleware/upload');\nrequire('dotenv').config();\n\n/* ----------------- POST ---------------------------- */\n\n// POST one post\nrouter.post('/', upload.single('file'), async(req, res) =&gt; {\nconst newPost = new Post({\ntitle: req.body.title,\nlocation: req.body.location,\nimage_id: req.file.filename\n})\nawait newPost.save();\nres.send(newPost);\n});\n\n/* ----------------- GET ---------------------------- */\n\nconst credentials = process.env.PATH_TO_PEM\n\nconst connection = mongoose.createConnection(process.env.DB_CONNECTION, { sslKey: credentials,\nsslCert: credentials,\ndbName: \"htwinsta\" });\n\nfunction getOnePost(id) {\nreturn new Promise( async(resolve, reject) =&gt; {\ntry {\n\nconst post = await Post.findOne({ _id: id });\nlet fileName = post.image_id;\nconst files = connection.collection('posts.files');\nconst chunks = connection.collection('posts.chunks');\n\nconst cursorFiles = files.find({filename: fileName});\nconst allFiles = await cursorFiles.toArray();\nconst cursorChunks = chunks.find({files_id : allFiles[0]._id});\nconst sortedChunks = cursorChunks.sort({n: 1});\nlet fileData = [];\nfor await (const chunk of sortedChunks) {\nfileData.push(chunk.data.toString('base64'));\n}\nlet base64file = 'data:' + allFiles[0].contentType + ';base64,' + fileData.join('');\nlet getPost = new Post({\n\"title\": post.title,\n\"location\": post.location, \"image_id\": base64file\n});\n//console.log('getPost', getPost)\nresolve(getPost)\n} catch {\nreject(new Error(\"Post does not exist!\"));\n}\n})\n}\n\nfunction getAllPosts() {\nreturn new Promise( async(resolve, reject) =&gt; {\nconst sendAllPosts = [];\nconst allPosts = await Post.find();\ntry {\nfor(const post of allPosts) {\nconsole.log('post', post)\nconst onePost = await getOnePost(post._id);\nsendAllPosts.push(onePost);\n}\nconsole.log('sendAllPosts', sendAllPosts)\nresolve(sendAllPosts)\n} catch {\nreject(new Error(\"Posts do not exist!\"));\n}\n});\n}\n\n// GET one post via id\nrouter.get('/:id', async(req, res) =&gt; {\ngetOnePost(req.params.id)\n.then( (post) =&gt; {\nconsole.log('post', post);\nres.send(post);\n})\n.catch( () =&gt; {\nres.status(404);\nres.send({\nerror: \"Post does not exist!\"\n});\n})\n});\n\n// GET all posts\nrouter.get('/', async(req, res) =&gt; {\ngetAllPosts()\n.then( (posts) =&gt; {\nres.send(posts);\n})\n.catch( () =&gt; {\nres.status(404);\nres.send({\nerror: \"Post do not exist!\"\n});\n})\n});\n\n/* ----------------- DELETE ---------------------------- */\n\n// DELETE one post via id\nrouter.delete('/:id', async(req, res) =&gt; {\ntry {\nconst post = await Post.findOne({ _id: req.params.id })\nlet fileName = post.image_id;\nawait Post.deleteOne({ _id: req.params.id });\nawait files.find({filename: fileName}).toArray( async(err, docs) =&gt; {\nawait chunks.deleteMany({files_id : docs[0]._id});\n})\nawait files.deleteOne({filename: fileName});\nres.status(204).send()\n} catch {\nres.status(404)\nres.send({ error: \"Post does not exist!\" })\n}\n});\n\nmodule.exports = router;\n</code></pre> .env <pre><code>DB_CONNECTION = mongodb+srv://ikt-pwa.0elr1ih.mongodb.net/?authSource=%24external&amp;authMechanism=MONGODB-X509&amp;retryWrites=true&amp;w=majority\nDATABASE = htwinsta\nPATH_TO_PEM = assets/X509-cert-3298914405631471913.pem\nPORT = 3000\n</code></pre>"},{"location":"images/#zusammenfassung-die-mongodb-posts","title":"Zusammenfassung - die MongoDB <code>posts</code>","text":"<p>Hier einige Datens\u00e4tze f\u00fcr die Datenbank <code>posts</code>:</p> Collection posts <pre><code>{\"_id\":{\"$oid\":\"6278e79c6664ce70884dd0b0\"},\"title\":\"WH Eingang\",\"location\":\"Campus Wilhelminenhof\",\"image_id\":\"1652090780364-jf-htwbild4.jpg\",\"__v\":0}\n{\"_id\":{\"$oid\":\"627a0ff2305433d805b6b437\"},\"title\":\"HTW Geb\u00e4ude C\",\"location\":\"Campus Wilhelminenhof\",\"image_id\":\"1652166642127-jf-htwbild5.jpg\",\"__v\":0}\n{\"_id\":{\"$oid\":\"627a7cad8ae16b1ba5f62f76\"},\"title\":\"Mensastrand\",\"location\":\"Campus Wilhelminenhof Mensa\",\"image_id\":\"1652194477890-jf-htwbild1.jpg\",\"__v\":0}\n{\"_id\":{\"$oid\":\"627a7cdf8ae16b1ba5f62f80\"},\"title\":\"Wiese Campus WH\",\"location\":\"Campus Wilhelminenhof Geb\u00e4ude C\",\"image_id\":\"1652194527176-jf-htwbild2.jpg\",\"__v\":0}\n{\"_id\":{\"$oid\":\"627a7d0b8ae16b1ba5f62f84\"},\"title\":\"Ber\u00fchmt wegen FIW\",\"location\":\"Campus Wilhelminenhof Geb\u00e4ude C\",\"image_id\":\"1652194571822-jf-htwbild3.jpg\",\"__v\":0}\n{\"_id\":{\"$oid\":\"627a7d398ae16b1ba5f62f8b\"},\"title\":\"Haupttor HTW\",\"location\":\"Wilhelminenhofstra\u00dfe HTW\",\"image_id\":\"1652194617191-jf-htwbild4.jpg\",\"__v\":0}\n{\"_id\":{\"$oid\":\"627a7d608ae16b1ba5f62f8f\"},\"title\":\"Geb\u00e4ude C\",\"location\":\"HTW Berlin\",\"image_id\":\"1652194656102-jf-htwbild5.jpg\",\"__v\":0}\n</code></pre> Collection posts.files <pre><code>{\"_id\":{\"$oid\":\"6278d47e96a41858d66f1621\"},\"length\":984341,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T08:44:46.239Z\"},\"filename\":\"1652085886102-jf-htwbild1.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"6278d5f902370f2c675993e9\"},\"length\":1601800,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T08:51:05.478Z\"},\"filename\":\"1652086265414-jf-htwbild2.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"6278db738d2b5bc5968f453e\"},\"length\":1601800,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T09:14:27.957Z\"},\"filename\":\"1652087667872-jf-htwbild2.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"6278db918d2b5bc5968f4546\"},\"length\":1601800,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T09:14:57.113Z\"},\"filename\":\"1652087697071-jf-htwbild2.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"6278dd057c648b9e8e3bbb74\"},\"length\":117492,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T09:21:09.873Z\"},\"filename\":\"1652088069823-jf-htwbild3.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"6278e74458477bf1223fa286\"},\"length\":1038579,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T10:04:53.07Z\"},\"filename\":\"1652090692995-jf-htwbild4.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"6278e79c6664ce70884dd0ab\"},\"length\":1038579,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-09T10:06:20.437Z\"},\"filename\":\"1652090780364-jf-htwbild4.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"627a0ff2305433d805b6b435\"},\"length\":25449,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-10T07:10:42.191Z\"},\"filename\":\"1652166642127-jf-htwbild5.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"627a7cad8ae16b1ba5f62f71\"},\"length\":984341,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-10T14:54:37.954Z\"},\"filename\":\"1652194477890-jf-htwbild1.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"627a7cdf8ae16b1ba5f62f78\"},\"length\":1601800,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-10T14:55:27.23Z\"},\"filename\":\"1652194527176-jf-htwbild2.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"627a7d0b8ae16b1ba5f62f82\"},\"length\":117492,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-10T14:56:11.84Z\"},\"filename\":\"1652194571822-jf-htwbild3.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"627a7d398ae16b1ba5f62f86\"},\"length\":1038579,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-10T14:56:57.214Z\"},\"filename\":\"1652194617191-jf-htwbild4.jpg\",\"contentType\":\"image/jpeg\"}\n{\"_id\":{\"$oid\":\"627a7d608ae16b1ba5f62f8d\"},\"length\":25449,\"chunkSize\":261120,\"uploadDate\":{\"$date\":\"2022-05-10T14:57:36.11Z\"},\"filename\":\"1652194656102-jf-htwbild5.jpg\",\"contentType\":\"image/jpeg\"}\n</code></pre> <p>Die Collection <code>posts.chunks</code> ist sehr gro\u00df, deshalb hier zum Download.</p>"},{"location":"indexeddb/","title":"IndexedDB","text":"<p>Hint</p> <p>Aktueller Stand vor IndexedDB:</p> <ul> <li>Frontend</li> <li>Backend</li> <li>Collection post</li> <li>Collection post.files</li> <li>Collection post.chunks</li> </ul> <p>Wir haben nun ein funktionierendes Backend (siehe hier) und verschiedene Ressourcen in statischen und dynamischen Caches gespeichert. Unsere HTW-Insta-Anwendung sieht nun so aus. Diese Ressourcen lagen als Dateien vor, die wir \u00fcber eine URL abrufen konnten, also <code>*.html</code>-, <code>*.js</code>-, <code>*.css</code>- Dateien und Bilder. Jetzt wollen wir dynamisch Daten speichern, sogenannten dynamischen Inhalt. Diese Daten k\u00f6nnen ausgelesen und den unterschiedlichen Dateien hinzugef\u00fcgt bzw. durch Dateien hinzugef\u00fcgt werden. Wir k\u00f6nnen uns das wirklich wie eine Datenbank vorstellen, aus der wir diese Daten ziehen, nur dass diese Datenbank nicht extern in einem Datenbankmanagementsystem verwaltet wird, sondern durch den Browser. Wir haben unter den Developer Tools diese \"Datenbank\" vielleicht schon im <code>Application</code>-Reiter auf der linken Seite unter <code>Storage</code> entdeckt. Es handelt sich um die <code>IndexedDB</code>. </p> <p>Bei der <code>IndexedDB</code> handelt es sich um eine transaktionsbasierte Datenbank, die Schl\u00fcssel-Werte-Paare im Browser speichert. Transaktionsbasiert bedeutet dabei, dass ganze Transaktionen ausgef\u00fchrt werden, die aus einzelnen Aktionen bestehen k\u00f6nnen. Wenn nur eine Aktion einer Transaktion fehlschl\u00e4gt, dann wird keine der Aktionen dieser Transaktion ausgef\u00fchrt. Das bedeutet, eine Transaktion  wird entweder ganz oder gar nicht ausgef\u00fchrt. Unsere Transaktionen bestehen aber typischerweise nur aus wenigen Aktionen, das Transaktionskonzept spielt deshalb keine gro\u00dfe Rolle. </p> <p>Wir k\u00f6nnen beliebige Daten in die <code>IndexedDB</code> speichern, also auch Bilder, Dateien, Arrays, Objekte, usw. Ein wichtiger Unterschied zum <code>Lokal Storage</code> ist, dass wir sowohl \u00fcber den \"normalen\" JavaScript-Thread unserer Webanwendung als auch \u00fcber den Service Worker auf die <code>IndexedDB</code> zugreifen k\u00f6nnen. </p>"},{"location":"indexeddb/#das-backend-nutzen","title":"Das Backend nutzen","text":"<p>Ehe wir aber mit der <code>IndexedDB</code> loslegen, wollen wir zun\u00e4chst einige Anpassungen in unserer <code>HTW Insta</code>-Anwendung durchf\u00fchren, damit sich unsere M\u00fchen mit dem Backend und dem Frontend auch gelohnt haben. </p> <p>Wir wollen die Daten f\u00fcr unsere <code>Cards</code> aus der Datenbank holen. Dazu muss das Backend gestartet sein! \u00d6ffnen Sie die <code>feed.js</code>. Die <code>fetch</code>-Funktion passen wir nun so an, dass sie auf unser Backend zugreift (den Zugriff auf <code>httpbin.org</code> ben\u00f6tigen wir nicht mehr):</p> <pre><code>fetch('http://localhost:3000/posts')\n.then((res) =&gt; {\nreturn res.json();\n})\n.then((data) =&gt; {\nupdateUI(data);\n});\n</code></pre> <p>Wir nutzen also den <code>GET http://localhost:3000/posts</code>-Endpunkt, um uns alle Daten aus der Datenbank zu holen. Wir f\u00fcgen einen Funktionsaufruf einer neuen Funktion <code>updateUI(data)</code> ein. Diese Funktion macht nichts weiter, als die <code>createCard()</code>-Funktion f\u00fcr jeden einzelnen Datensatz aufzurufen: </p> <pre><code>function updateUI(data) {\n\nfor(let card of data)\n{\ncreateCard(card);\n}\n\n}\n</code></pre> <p>Die <code>createCard()</code>-Funktion war allerdings bis jetzt parameterlos. Nun \u00fcbergeben wir unseren Datensatz und nutzen die einzelnen Werte daraus f\u00fcr die Erstellung einer <code>Card</code>:</p> <pre><code>function createCard(card) {\nlet cardWrapper = document.createElement('div');\ncardWrapper.className = 'shared-moment-card mdl-card mdl-shadow--2dp';\nlet cardTitle = document.createElement('div');\ncardTitle.className = 'mdl-card__title';\nlet image = new Image();\nimage.src = card.image_id;\ncardTitle.style.backgroundImage = 'url('+ image.src +')';\ncardTitle.style.backgroundSize = 'cover';\ncardTitle.style.height = '180px';\ncardWrapper.appendChild(cardTitle);\nlet cardTitleTextElement = document.createElement('h2');\ncardTitleTextElement.className = 'mdl-card__title-text';\ncardTitleTextElement.textContent = card.title;\ncardTitle.appendChild(cardTitleTextElement);\nlet cardSupportingText = document.createElement('div');\ncardSupportingText.className = 'mdl-card__supporting-text';\ncardSupportingText.textContent = card.location;\ncardSupportingText.style.textAlign = 'center';\ncardWrapper.appendChild(cardSupportingText);\ncomponentHandler.upgradeElement(cardWrapper);\nsharedMomentsArea.appendChild(cardWrapper);\n}\n</code></pre> <p>F\u00fcr das Darstellen der Bilder ben\u00f6tigen wir ein <code>Image</code>-Objekt, dem wir als Wert des <code>src</code>-Attributes den base64-String aus <code>image_id</code> \u00fcbergeben. Dann wird der <code>src</code>-Wert des <code>Image</code>-Objektes als eine <code>URL</code> f\u00fcr das Hintergrundbild einer <code>Card</code> verwendet (Zeilen <code>6-8</code>).</p> <p>Warning</p> <p>Beachten Sie, dass wir alle Ressourcen cachen. Das bedeutet, dass sich \u00c4nderungen an z.B. der <code>feed.js</code> gar nicht automatisch in der Webanwendung auswirken, da ja die <code>feed.js</code> aus dem Cache verwendet wird. Damit wir die \u00c4nderungen auch testen k\u00f6nnen, m\u00fcssen wir den Cache neu bef\u00fcllen. Wir haben dazu Cache-Versionen eingef\u00fchrt: </p> sw.js <p><pre><code>const CACHE_VERSION = 3;\nconst CURRENT_STATIC_CACHE = 'static-v'+CACHE_VERSION;\nconst CURRENT_DYNAMIC_CACHE = 'dynamic-v'+CACHE_VERSION;\nself.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\nevent.waitUntil(\ncaches.open(CURRENT_STATIC_CACHE)\n.then( cache =&gt; {\nconsole.log('Service-Worker-Cache erzeugt und offen');\ncache.addAll([\n'/',\n'/index.html',\n'/src/js/app.js',\n'/src/js/feed.js',\n'/src/js/material.min.js',\n'/src/css/app.css',\n'/src/css/feed.css',\n'/src/images/htw.jpg',\n'https://fonts.googleapis.com/css?family=Roboto:400,700',\n'https://fonts.googleapis.com/icon?family=Material+Icons',\n'https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css'\n]);\n})\n);\n})\n\nself.addEventListener('activate', event =&gt; {\nconsole.log('service worker --&gt; activating ...', event);\nevent.waitUntil(\ncaches.keys()\n.then( keyList =&gt; {\nreturn Promise.all(keyList.map( key =&gt; {\nif(key !== CURRENT_STATIC_CACHE &amp;&amp; key !== CURRENT_DYNAMIC_CACHE) {\nconsole.log('service worker --&gt; old cache removed :', key);\nreturn caches.delete(key);\n}\n}))\n})\n);\nreturn self.clients.claim();\n})\n\nself.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (event.request.url.indexOf('http') !== 0) return; // skip the request. if request is not made with http protocol\n\nevent.respondWith(\ncaches.match(event.request)\n.then( response =&gt; {\nif(response) {\nreturn response;\n} else {\nreturn fetch(event.request)\n.then( res =&gt; {     // nicht erneut response nehmen, haben wir schon\nreturn caches.open(CURRENT_DYNAMIC_CACHE)      // neuer, weiterer Cache namens dynamic\n.then( cache =&gt; {\ncache.put(event.request.url, res.clone());\nreturn res;\n})\n});\n}\n})\n);\n})\n</code></pre> Das Testen der neuen Implementierung erfordert nun also immer das \u00c4ndern der Cache-Versionsnummer (<code>CACHE_VERSION</code>) und dann das Aktivieren des neuen Service Workers! </p> <p>Je nachdem, welche Daten Sie alle in Ihrer Datenbank haben, sieht die Anwendung nun so aus: </p> <p></p> <p>Beachten Sie auch, dass sowohl der statische als auch der dynamische Service-Worker-Cache funktioniert. Das hei\u00dft, wenn Sie Ihre Anwendung offline schalten, dann ist immer noch alles da. </p>"},{"location":"indexeddb/#warum-dynamische-inhalte-cachen","title":"Warum dynamische Inhalte \"cachen\"?","text":"<p>Wenn wir nun bereits alle Ressourcen (html-Dateien, js-Dateien, css-Dateien und Bilddateien) im Service-Worker-Cache gespeichert haben (statisch und oder dynamisch), dann stellt sich nat\u00fcrlich die Frage, warum wir \u00fcberhaupt noch eine In-Browser-Datenbank verwenden sollen und wollen. Die beiden Terme, die dabei unterschieden werden, sind dynamic caching und caching dynamic content, also dynamische Inhalte speichern. Beides hat caching im Namen und dynamic, ist auch nicht so viel anders. </p> <p>Dynamic caching haben wir bis jetzt durchgef\u00fchrt. Die Webanwendung stellt eine Anfrage an den Webserver, der Service Worker schaltet sich jedoch als Proxy dazwischen. Wenn der Service Worker die Anfrage selbst aus dem Cache beantworten kann, wird sie gar nicht erst an den Webserver weitergeleitet. Wenn nicht, dann geht die Anfrage zum Webserver, der schickt eine Antwort zur\u00fcck, die der Service Worker aber auch in seinen dynamischen Cache ablegt, um sie beim n\u00e4chsten Mal aus dem Cache beantworten zu k\u00f6nnen. Beim dynamic caching werden also dynamisch Ressourcen im Cache abgelegt. </p> <p>Beim Speichern von dynamischen Inhalten mithilfe der In-Browser-IndexedDB spielt die Fetch-API keine Rolle. Es geht auch nicht darum, Ressourcen, wie html-, css, oder js-Dateien zu speichern. Vielmehr werden in der Datenbank strukturierte (aber auch unstrukturierte) Daten, wie JSON- oder XML-Daten gespeichert. Prinzipiell geht es um das Speichern von Schl\u00fcssel-Werte-Paaren. Prim\u00e4r handelt es sich bei den Daten in der IndexedDB aber um dynamische, sich h\u00e4ufig \u00e4ndernde Daten - dynamic content. W\u00e4hrend wir beim dynamic caching eher davon ausgehen, Ressourcen zu speichern, die sich nicht h\u00e4ufig \u00e4ndern, ist das bei der IndexedDB anders. Dort gehen wir davon aus, dass sich diese Daten h\u00e4ufig \u00e4ndern. Ein weiterer Unterschied liegt darin, dass wir mit dynamic caching stets nur vollst\u00e4ndige Responses speichern, also eine Ressource ganz oder gar nicht. Das muss in der IndexedDB nicht sein. Wir k\u00f6nnten in der IndexedDB z.B. von einem <code>Post</code> immer nur <code>post.title</code> und <code>post.location</code> speichern, nicht aber <code>post.image_id</code> (oder umgekehrt). Au\u00dferdem lassen sich die Daten in der IndexedDB auch \u00e4ndern oder in ein anderes Format umwandeln. Wir haben in Bezug auf die gespeicherten Ressourcen in der IndexedDB mehr Flexibilit\u00e4t.  </p>"},{"location":"indexeddb/#das-idb-paket","title":"Das idb-Paket","text":"<p>Da die API zur <code>IndexedDB</code> sehr umst\u00e4ndlich zu handhaben ist und viele Callbacks erfordert, wird die Verwendung anderer Pakete empfohlen, die sich als Wrapper um die API legen und die Verwendung von Promises erm\u00f6glichen. Oft wird z.B. Dexie verwendet. Wir verwenden zun\u00e4chst den idb-Wrapper von Jake Archibald. Ich verwende im Folgenden dieses idb.js, das Sie sich hier herunterladen und einfach in Ihren <code>/public/src/js</code>-Ordner kopieren k\u00f6nnen. </p> <p></p> <p>Diese Datei binden wir zun\u00e4chst \u00fcber die <code>index.html</code>-Datei ein:</p> index.html <pre><code>&lt;/div&gt;\n&lt;script defer src=\"/src/js/material.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/src/js/idb.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/src/js/app.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/src/js/feed.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Im Service Worker haben wir normalerweise keinen direkten Zugriff auf die Skripte und Dateien unserer Webanwendung. Daf\u00fcr gibt es jedoch die <code>importScripts()</code>-Anweisung. Wir importieren damit unsere <code>idb.js</code>-Datei in den Service Worker und wir laden diese Datei auch in den Cache:</p> public/sw.js <pre><code>importScripts('/src/js/idb.js');\nconst CACHE_VERSION = 3;\nconst CURRENT_STATIC_CACHE = 'static-v'+CACHE_VERSION;\nconst CURRENT_DYNAMIC_CACHE = 'dynamic-v'+CACHE_VERSION;\n\nself.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\nevent.waitUntil(\ncaches.open(CURRENT_STATIC_CACHE)\n.then(cache =&gt; {\nconsole.log('Service-Worker-Cache erzeugt und offen');\ncache.addAll([\n'/',\n'/index.html',\n'/src/js/app.js',\n'/src/js/feed.js',\n'/src/js/material.min.js',\n'/src/js/idb.js',\n'/src/css/app.css',\n'/src/css/feed.css',\n'/src/images/htw.jpg',\n'https://fonts.googleapis.com/css?family=Roboto:400,700',\n'https://fonts.googleapis.com/icon?family=Material+Icons',\n'https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css'\n]);\n})\n);\n})\n\nself.addEventListener('activate', event =&gt; {\nconsole.log('service worker --&gt; activating ...', event);\nevent.waitUntil(\ncaches.keys()\n.then(keyList =&gt; {\nreturn Promise.all(keyList.map(key =&gt; {\nif (key !== CURRENT_STATIC_CACHE &amp;&amp; key !== CURRENT_DYNAMIC_CACHE) {\nconsole.log('service worker --&gt; old cache removed :', key);\nreturn caches.delete(key);\n}\n}))\n})\n);\nreturn self.clients.claim();\n})\n\nself.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (!(event.request.url.indexOf('http') === 0)) return; // skip the request. if request is not made with http protocol\n\nevent.respondWith(\ncaches.match(event.request)\n.then(response =&gt; {\nif (response) {\nreturn response;\n} else {\nreturn fetch(event.request)\n.then(res =&gt; { // nicht erneut response nehmen, haben wir schon\nreturn caches.open(CURRENT_DYNAMIC_CACHE) // neuer, weiterer Cache namens dynamic\n.then(cache =&gt; {\ncache.put(event.request.url, res.clone());\nreturn res;\n})\n});\n}\n})\n);\n})\n</code></pre> <p>Wir f\u00fchren zun\u00e4chst noch einige \u00c4nderungen in unserer Service Worker Datei <code>sw.js</code> durch. Zun\u00e4chst lagern wir alle Dateien, die wir in dem statischen Cache speichern wollen, in ein eigenes Array <code>STATIC_FILES</code> aus:</p> public/sw.js <pre><code>    importScripts('/src/js/idb.js');\n\nconst CACHE_VERSION = 3;\nconst CURRENT_STATIC_CACHE = 'static-v'+CACHE_VERSION;\nconst CURRENT_DYNAMIC_CACHE = 'dynamic-v'+CACHE_VERSION;\nconst STATIC_FILES = [\n'/',\n'/index.html',\n'/src/js/app.js',\n'/src/js/feed.js',\n'/src/js/material.min.js',\n'/src/js/idb.js',\n'/src/css/app.css',\n'/src/css/feed.css',\n'/src/images/htw.jpg',\n'https://fonts.googleapis.com/css?family=Roboto:400,700',\n'https://fonts.googleapis.com/icon?family=Material+Icons',\n'https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css'\n];\n\nself.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\nevent.waitUntil(\ncaches.open(CURRENT_STATIC_CACHE)\n.then(cache =&gt; {\nconsole.log('Service-Worker-Cache erzeugt und offen');\ncache.addAll(STATIC_FILES);\n})\n);\n})\n\n// hier der Rest\n</code></pre> <p>Das hat keine weitere Bedeutung und strukturiert nur den Code besser. Wichtiger aber ist es, die Behandlung des <code>fetch</code>-Ereignisses zu \u00fcberdenken. Derzeit sieht die Behandlung so aus:</p> <pre><code>self.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (!(event.request.url.indexOf('http') === 0)) return; // skip the request. if request is not made with http protocol\n\nevent.respondWith(\ncaches.match(event.request)\n.then( response =&gt; {\nif(response) {\nreturn response;\n} else {\nreturn fetch(event.request)\n.then( res =&gt; {     // nicht erneut response nehmen, haben wir schon\nreturn caches.open(CURRENT_DYNAMIC_CACHE)      // neuer, weiterer Cache namens dynamic\n.then( cache =&gt; {\ncache.put(event.request.url, res.clone());\nreturn res;\n})\n});\n}\n})\n);\n})\n</code></pre> <p>Das hei\u00dft, dass jeder Request \u00fcberpr\u00fcft wird, ob er aus dem Cache beantwortet werden kann und wenn ja, dann wird die <code>response</code> aus dem Cache zur\u00fcckgegeben (Zeile <code>10</code>). Wenn nicht, dann wird der Request an den Webserver weitergeleitet, die Antwort in den dynamischen Cache gelegt und an die Webanwendung weitergereicht (Zeilen <code>12-20</code>). Das betrifft jeden Request. Wir wollen nun aber die Anfragen, die an <code>http//localhost:3000/posts</code> gestellt werden, anders behandeln. Dazu speichern wir dieses <code>url</code> und pr\u00fcfen, ob diese Anfrage an diese URL geht. Wenn ja, behandeln wir sie anders, wenn nicht, dann so, wie bisher:</p> <pre><code>self.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (!(event.request.url.indexOf('http') === 0)) return; // skip the request. if request is not made with http protocol\n\nconst url = 'http://localhost:3000/posts';\nif(event.request.url.indexOf(url) &gt;= 0) {\nevent.respondWith(\nfetch(event.request)\n.then ( res =&gt; {\n// hier Anfrage an http://localhost:3000/posts behandeln\nreturn res;\n})\n)\n} else {\nevent.respondWith(\ncaches.match(event.request)\n.then( response =&gt; {\nif(response) {\nreturn response;\n} else {\nreturn fetch(event.request)\n.then( res =&gt; {     // nicht erneut response nehmen, haben wir schon\nreturn caches.open(CURRENT_DYNAMIC_CACHE)      // neuer, weiterer Cache namens dynamic\n.then( cache =&gt; {\ncache.put(event.request.url, res.clone());\nreturn res;\n})\n});\n}\n})\n)}\n})\n</code></pre> <p>Wie wir diese Anfragen an <code>http://localhost:3000/posts</code> behandeln, schauen wir uns gleich an. Wir haben jetzt nur eine Unterscheidung hinzugef\u00fcgt, ob die Anfrage an  <code>http://localhost:3000/posts</code> geht oder nicht. Wenn ja, leiten wir die Anfrage an den Webserver weiter (Zeile <code>9</code>) und geben die Response zur\u00fcck (Zeile <code>12</code>). Wenn nicht, dann behandeln wir die Anfrage wir bisher. Zun\u00e4chst erstellen wir aber die IndexedDB. </p>"},{"location":"indexeddb/#erstellen-und-offnen-einer-indexeddb","title":"Erstellen und \u00d6ffnen einer IndexedDB","text":"<p>Nachdem wir f\u00fcr den Service Worker die <code>importScripts()</code>-Anweisung kennengelernt haben, k\u00f6nnten wir nun verschiedene Skripts erstellen und diese in den Service Worker einbinden, also z.B. ein Skript f\u00fcr die Behandlung des <code>fetch</code>-Ereignisses und ein Skript f\u00fcr die Verwaltung der <code>IndexedDB</code>. Wir lassen aber hier alles in der <code>sw.js</code> und erstellen und \u00f6ffnen zun\u00e4chst eine neue IndexedDB, die wir <code>posts-store</code> nennen. Dies geht mit der <code>openDB()</code>-Funktion aus dem <code>idb</code>-Paket (siehe README.md):</p> public/sw.js <pre><code>importScripts('/src/js/idb.js');\n\nconst CACHE_VERSION = 3;\nconst CURRENT_STATIC_CACHE = 'static-v'+CACHE_VERSION;\nconst CURRENT_DYNAMIC_CACHE = 'dynamic-v'+CACHE_VERSION;\n\nself.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\nevent.waitUntil(\ncaches.open(CURRENT_STATIC_CACHE)\n.then(cache =&gt; {\nconsole.log('Service-Worker-Cache erzeugt und offen');\ncache.addAll([\n'/',\n'/index.html',\n'/src/js/app.js',\n'/src/js/feed.js',\n'/src/js/material.min.js',\n'/src/js/idb.js',\n'/src/css/app.css',\n'/src/css/feed.css',\n'/src/images/htw.jpg',\n'https://fonts.googleapis.com/css?family=Roboto:400,700',\n'https://fonts.googleapis.com/icon?family=Material+Icons',\n'https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css'\n]);\n})\n);\n})\n\nconst db = idb.openDB('posts-store', 1, {\nupgrade(db) {\n// Create a store of objects\nconst store = db.createObjectStore('posts', {\n// The '_id' property of the object will be the key.\nkeyPath: '_id',\n// If it isn't explicitly set, create a value by auto incrementing.\nautoIncrement: true,\n});\n// Create an index on the '_id' property of the objects.\nstore.createIndex('_id', '_id');\n},\n});\nself.addEventListener('activate', event =&gt; {\nconsole.log('service worker --&gt; activating ...', event);\nevent.waitUntil(\ncaches.keys()\n.then(keyList =&gt; {\nreturn Promise.all(keyList.map(key =&gt; {\nif (key !== CURRENT_STATIC_CACHE &amp;&amp; key !== CURRENT_DYNAMIC_CACHE) {\nconsole.log('service worker --&gt; old cache removed :', key);\nreturn caches.delete(key);\n}\n}))\n})\n);\nreturn self.clients.claim();\n})\n\nself.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (!(event.request.url.indexOf('http') === 0)) return; // skip the request. if request is not made with http protocol\n\nconst url = 'http://localhost:3000/posts';\nif(event.request.url.indexOf(url) &gt;= 0) {\nevent.respondWith(\nfetch(event.request)\n.then ( res =&gt; {\n// hier Anfrage an http://localhost:3000/posts behandeln\nreturn res;\n})\n)\n} else {\nevent.respondWith(\ncaches.match(event.request)\n.then( response =&gt; {\nif(response) {\nreturn response;\n} else {\nreturn fetch(event.request)\n.then( res =&gt; {     // nicht erneut response nehmen, haben wir schon\nreturn caches.open(CURRENT_DYNAMIC_CACHE)      // neuer, weiterer Cache namens dynamic\n.then( cache =&gt; {\ncache.put(event.request.url, res.clone());\nreturn res;\n})\n});\n}\n})\n)}\n})\n</code></pre> <p>Wir haben nun eine \"eigene\" IndexDB namens <code>post-store</code> erstellt. Der <code>store</code> darin hei\u00dft <code>posts</code>. In diesem <code>store</code> speichern wir alle Daten der Posts. Mit der Eigenschaft <code>keyPath</code> definieren wir den Schl\u00fcssel f\u00fcr diesen <code>store</code>. \u00dcber diesen Schl\u00fcssel gelangen wir an unserer Daten. Mithilfe der Funktion <code>createIndex()</code> verbinden wir das Attribut <code>_id</code> unserer Posts-Datens\u00e4tze mit diesem Schl\u00fcssel. F\u00fcr uns bedeutet das schlicht, dass <code>_id</code> der Schl\u00fcssel sowohl in der IndexedDB als auch in unserer MongoDB f\u00fcr alle Posts ist. Wenn wir die Anwendung nun ausf\u00fchren, dann sehen wir in den Developer Tools im Reiter <code>Application</code> links im Men\u00fc unter <code>Storage --&gt; IndexedDB</code> diese Datenbank.</p> <p></p> <p>Diese ist noch leer, wir machen ja noch nichts damit. </p>"},{"location":"indexeddb/#behandlung-fetch-event-anpassen","title":"Behandlung <code>fetch</code>-Event anpassen","text":"<p>Nun passen wir die Behandlung des <code>fetch</code>-Ereignisses f\u00fcr die Anfragen an <code>http://localhost:3000/posts</code> an. Wir haben derzeit folgende Ausgangssituation (siehe oben):</p> <pre><code>self.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (!(event.request.url.indexOf('http') === 0)) return; // skip the request. if request is not made with http protocol\n\nconst url = 'http://localhost:3000/posts';\nif(event.request.url.indexOf(url) &gt;= 0) {\nevent.respondWith(\nfetch(event.request)\n.then ( res =&gt; {\n// hier Anfrage an http://localhost:3000/posts behandeln\nreturn res;\n})\n)\n} else {\n// dynamischer Cache\n})\n</code></pre> <p>Wir behandeln die Anfrage an das Backend nun wie folgt:</p> <pre><code>self.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (!(event.request.url.indexOf('http') === 0)) return; // skip the request. if request is not made with http protocol\n\nconst url = 'http://localhost:3000/posts';\nif(event.request.url.indexOf(url) &gt;= 0) {\nevent.respondWith(\nfetch(event.request)\n.then ( res =&gt; {\nconst clonedResponse = res.clone();\nclonedResponse.json()\n.then( data =&gt; {\nfor(let key in data)\n{\ndb\n.then( dbPosts =&gt; {\nlet tx = dbPosts.transaction('posts', 'readwrite');\nlet store = tx.objectStore('posts');\nstore.put(data[key]);\nreturn tx.done;\n})\n}\n})\nreturn res;\n})\n)\n} else {\n// dynamischer Cache\n})\n</code></pre> <ul> <li>Wir clonen zun\u00e4chst die Response, da sie nur einmal \"verbraucht\" werden kann (Zeile <code>70</code>).</li> <li>Dann wird diese geclonte Response in ein JSON umgewandelt (Zeile <code>71</code>).</li> <li>Dieses JSON beschreibt ein JavaScript-Objekt mit den Schl\u00fcsseln <code>id</code>, <code>title</code>, <code>location</code> und <code>image</code> - so, wie es unser Backend zur\u00fcckgibt. Wir gehen nun in einer <code>for</code>-Schleife durch alle diese Schl\u00fcssel-Werte-Paare durch (Zeile <code>73</code>). </li> <li>In Zeile <code>75</code> greifen wir auf das Promise-Objekt zu, das die Datenbank verwaltet, die wir zuvor mittels <code>openDB()</code> ge\u00f6ffnet haben. </li> <li>Dieser Promise verwaltet sich selbst. Das bedeutet, dass <code>dbPosts</code> genau f\u00fcr die von uns ge\u00f6ffnete IndexedDB steht. Wir k\u00f6nnen nur nicht erneut <code>db</code> benutzen, deshalb <code>dbPosts</code> (Zeile <code>76</code>). </li> <li>Als erstes erstellen wir eine Transaktion. Wie bereits gesagt, ist die IndexedDB transaktionsbasiert. Jede Operation ist somit eine Transaktion. Wir erstellen eine Transaktion <code>tx</code> (Zeile <code>77</code>). Diese Transaktion wird durch die Funktion <code>transaction()</code> erzeugt. Die Funktion erwartet zwei Parameter:<ul> <li>der erste Parameter beschreibt den <code>store</code>, auf den die Transaktion zugreift (bei uns <code>posts</code>).</li> <li>der zweite Parameter beschreibt, ob wir nur lesend auf diesen <code>store</code> zugreifen wollen (<code>'readonly'</code>) oder auch schreibend (<code>'readwrite'</code>).</li> </ul> </li> <li>Nach der Definition der Transaktion muss f\u00fcr die Transaktion nochmal die Eigenschaft <code>store</code> aufgerufen werden (siehe README.md des idb-Paketes). Darin steht aber auch, dass man <code>tx.objectStore(storeName)</code> aufrufen soll, wenn die Transaktion mehrere Stores verwendet. Deshalb rufen wir einfach immer <code>tx.objectStore(storeName)</code> auf, da das auch funktioniert, wenn nur ein <code>store</code> verwendet wird (Zeile <code>78</code>). </li> <li>In Zeile <code>79</code> werden die einzelnen Schl\u00fcssel-Werte-Paare dann in die IndexedDB gespeichert. </li> </ul> <p>Nach Ausf\u00fchren der Anwendung sieht die IndexedDB nun (je nachdem, welche Daten Sie bereits in Ihrer Datenbank gespeichert haben) so aus:</p> <p></p> <p>Wir haben nun die IndexedDB des Browsers mit unseren Datens\u00e4tzen bef\u00fcllt. Nun \u00fcberlegen wir uns, wie wir diese Datens\u00e4tze aus der IndexedDB auslesen k\u00f6nnen, wenn wir sie dort gespeichert haben und dann gar nicht mehr an das Backend Anfragen schicken m\u00fcssen. </p>"},{"location":"indexeddb/#datensatze-aus-der-indexeddb-auslesen","title":"Datens\u00e4tze aus der IndexedDB auslesen","text":"<p>Zun\u00e4chst einmal stellen wir fest, dass ein geeigneter Ort, die Datens\u00e4tze aus der IndexedDB auszulesen, die <code>feed.js</code> ist, da dort ja die Daten zum Erstellen der <code>Cards</code> verwendet werden. </p> <p>Schauen wir uns deshalb dort die <code>fetch()</code>-Funktion an (siehe auch Das Backend nutzen). </p> <pre><code>fetch('http://localhost:3000/posts')\n.then((res) =&gt; {\nreturn res.json();\n})\n.then((data) =&gt; {\nupdateUI(data);\n});\n</code></pre> <p>Wir stellen dort eine Anfrage an das Backend und verwenden die vom Backend \u00fcbergebenen Daten (<code>data</code>), um die <code>Cards</code> zu erstellen (<code>updateUI(data)</code>). Das hei\u00dft, dass wir nun die IndexedDB auch in <code>feed.js</code> verwenden wollen - also in unserer \"Webanwendung\" (und nicht \"nur\" im Service Worker). Das hei\u00dft aber auch, dass wir nun auch in der Webanwendung die IndexedDB \u00f6ffnen m\u00fcssen usw. und wir dort \u00e4hnlichen Code h\u00e4tten, wie auch bereits im Service Worker. Um doppelten Code zu vermeiden, lagern wir deshalb einigen Code in eine <code>db.js</code> aus. Wir bewegen (move) zun\u00e4chst den Code zum \u00d6ffnen der IndexedDB aus der <code>sw.js</code> nach <code>db.js</code>:</p> /public/src/js/db.js <pre><code>    const db = idb.openDB('posts-store', 1, {\nupgrade(db) {\n// Create a store of objects\nconst store = db.createObjectStore('posts', {\n// The 'id' property of the object will be the key.\nkeyPath: 'id',\n// If it isn't explicitly set, create a value by auto incrementing.\nautoIncrement: true,\n});\n// Create an index on the '_id' property of the objects.\nstore.createIndex('id', '_id');\n},\n});\n</code></pre> <p>Dann erstellen wir uns in der <code>db.js</code> eine Funktion <code>writeData()</code>, die in die IndexedDB die Daten schreibt. Dazu bewegen wir den folgenden Block aus der <code>sw.js</code> nach <code>db.js</code>:</p> sw.js <pre><code>self.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (!(event.request.url.indexOf('http') === 0)) return; // skip the request. if request is not made with http protocol\n\nconst url = 'http://localhost:3000/posts';\nif(event.request.url.indexOf(url) &gt;= 0) {\nevent.respondWith(\nfetch(event.request)\n.then ( res =&gt; {\nconst clonedResponse = res.clone();\nclonedResponse.json()\n.then( data =&gt; {\nfor(let key in data)\n{\ndb\n.then( dbPosts =&gt; {\nlet tx = dbPosts.transaction('posts', 'readwrite');\nlet store = tx.objectStore('posts');\nstore.put(data[key]);\nreturn tx.done;\n})\n}\n})\nreturn res;\n})\n)\n} else {\nevent.respondWith(\ncaches.match(event.request)\n.then( response =&gt; {\nif(response) {\nreturn response;\n} else {\nreturn fetch(event.request)\n.then( res =&gt; {     // nicht erneut response nehmen, haben wir schon\nreturn caches.open(CURRENT_DYNAMIC_CACHE)      // neuer, weiterer Cache namens dynamic\n.then( cache =&gt; {\ncache.put(event.request.url, res.clone());\nreturn res;\n})\n});\n}\n})\n)}\n})\n</code></pre> <p>Die <code>db.js</code> sieht dann so aus:</p> /public/src/js/db.js <pre><code>    const db = idb.openDB('posts-store', 1, {\nupgrade(db) {\n// Create a store of objects\nconst store = db.createObjectStore('posts', {\n// The 'id' property of the object will be the key.\nkeyPath: 'id',\n// If it isn't explicitly set, create a value by auto incrementing.\nautoIncrement: true,\n});\n// Create an index on the 'id' property of the objects.\nstore.createIndex('id', 'id');\n},\n});\n\nfunction writeData() {\ndb\n.then( dbPosts =&gt; {\nlet tx = dbPosts.transaction('posts', 'readwrite');\nlet store = tx.objectStore('posts');\nstore.put(data);\nreturn tx.done;\n})\n}\n</code></pre> <p>Beachten Sie, dass aus <code>store.put(data[key])</code> nun <code>store.put(data)</code> wurde, da wir hier keinen <code>key</code> verwalten. Damit die <code>writeData()</code>-Funktion m\u00f6glichst generisch ist, \u00fcbergeben wir als Parameter den <code>store</code> (<code>posts</code>) und wir m\u00fcssen nat\u00fcrlich auch <code>data</code> \u00fcbergeben:</p> /public/src/js/db.js <pre><code>    const db = idb.openDB('posts-store', 1, {\nupgrade(db) {\n// Create a store of objects\nconst store = db.createObjectStore('posts', {\n// The 'id' property of the object will be the key.\nkeyPath: 'id',\n// If it isn't explicitly set, create a value by auto incrementing.\nautoIncrement: true,\n});\n// Create an index on the 'id' property of the objects.\nstore.createIndex('id', 'id');\n},\n});\n\nfunction writeData(st, data) {\nreturn db\n.then( dbPosts =&gt; {\nlet tx = dbPosts.transaction(st, 'readwrite');\nlet store = tx.objectStore(st);\nstore.put(data);\nreturn tx.done;\n})\n}\n</code></pre> <p>Wichtig ist, dass wir das <code>db</code>-Promise-Objekt in <code>writeData()</code> nun zur\u00fcckgeben m\u00fcssen, d.h. wir ben\u00f6tigen ein <code>return</code> in Zeile <code>16</code>. Nun m\u00fcssen wir diese <code>db.js</code> nat\u00fcrlich importieren, sowohl in den Service Worker als auch in die Webanwendung (da sie ja <code>feed.js</code> zur Verf\u00fcgung stehen soll). Beide Importe m\u00fcssen hinter dem Import der <code>idb.js</code> stehen, da die <code>db.js</code> Funktionen der <code>idb.js</code> verwendet.</p> sw.js <pre><code>importScripts('/src/js/idb.js');\nimportScripts('/src/js/db.js');\nconst CACHE_VERSION = 1;\nconst CURRENT_STATIC_CACHE = 'static-v'+CACHE_VERSION;\nconst CURRENT_DYNAMIC_CACHE = 'dynamic-v'+CACHE_VERSION;\n\n// ... und hier der Rest\n</code></pre> <p>sowie f\u00fcr die <code>/public/src/js/*.js</code>-Datein in der <code>index.html</code>:</p> index.html <pre><code>&lt;/div&gt;\n&lt;script defer src=\"/src/js/material.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/src/js/idb.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/src/js/db.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/src/js/app.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/src/js/feed.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>In die <code>sw.js</code> setzen wir noch den Aufruf von <code>writeData('posts', data[key])</code> an der richtigen Stelle ein (jetzt wieder <code>data[key]</code>, da das hier f\u00fcr einen Post steht):</p> sw.js <pre><code>self.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (!(event.request.url.indexOf('http') === 0)) return; // skip the request. if request is not made with http protocol\n\nconst url = 'http://localhost:3000/posts';\nif(event.request.url.indexOf(url) &gt;= 0) {\nevent.respondWith(\nfetch(event.request)\n.then ( res =&gt; {\nconst clonedResponse = res.clone();\nclonedResponse.json()\n.then( data =&gt; {\nfor(let key in data)\n{\nwriteData('posts', data[key]);\n}\n})\nreturn res;\n})\n)\n} else {\n</code></pre> <p>\u00dcbrigens: Da wir f\u00fcr die Behandlung des <code>fetch</code>-Events nun zwischen den Aufrufen an den Webserver und an das Backend unterscheiden, werden die Requests der Backend-Aufrufe nun nicht mehr im (dynamischen) Cache gespeichert. Das bedeutet, dass unsere Anwendung in dem derzeitigen Zustand offline nicht funktioniert, da dann die <code>Cards</code> nicht angezeigt werden. Deshalb wollen wir ja in die <code>feed.js</code> nun die Abfrage an die IndexedDB einbauen, damit die Daten von dort geholt werden k\u00f6nnen. </p> <p>Dazu erweitern wir die <code>db.js</code> zun\u00e4chst um eine <code>readAllData(store)</code>-Funktion, in der wir alle Daten aus der IndexedDB auslesen.</p> /public/src/js/db.js <pre><code>    const db = idb.openDB('posts-store', 1, {\nupgrade(db) {\n// Create a store of objects\nconst store = db.createObjectStore('posts', {\n// The '_id' property of the object will be the key.\nkeyPath: '_id',\n// If it isn't explicitly set, create a value by auto incrementing.\nautoIncrement: true,\n});\n// Create an index on the '_id' property of the objects.\nstore.createIndex('_id', '_id');\n},\n});\n\nfunction writeData(st, data) {\nreturn db\n.then( dbPosts =&gt; {\nlet tx = dbPosts.transaction(st, 'readwrite');\nlet store = tx.objectStore(st);\nstore.put(data);\nreturn tx.done;\n})\n}\n\n\nfunction readAllData(st) {\nreturn db\n.then( dbPosts =&gt; {\nlet tx = dbPosts.transaction(st, 'readonly');\nlet store = tx.objectStore(st);\nreturn store.getAll();\n})\n}\n</code></pre> <p>Im Gegensatz zur <code>writeData()</code>-Funktion m\u00fcssen wir beim Lesen der Daten (<code>readonly</code>) nicht darauf warten, dass die Transaktion vollst\u00e4ndig abgearbeitet ist (<code>tx.done</code>), sondern wir k\u00f6nnen die Funktion mit dem Promise verlassen, in dem alle Daten zur Verf\u00fcgung gestellt sind. Rein lesende Transaktionen k\u00f6nnen auf der Datenbank keinen \"Schaden\" anrichten. Deshalb k\u00f6nnen wir auf das <code>tx.done</code> verzichten. Alles andere ist im Prinzip wie bei <code>writeData()</code>, nur dass wir nun nur <code>readonly</code> Zugriff haben und die <code>getAll()</code>-Funktion aufrufen. </p> <p>Diese <code>readAllData()</code>-Funktion bauen wir nun in die <code>feed.js</code> ein. Dazu betrachten wir die <code>fetch</code>-Funktion darin zun\u00e4chst noch einmal:</p> /public/src/js/feed.js <pre><code>fetch('http://localhost:3000/posts')\n.then((res) =&gt; {\nreturn res.json();\n})\n.then((data) =&gt; {\nconsole.log(data);\nupdateUI(data);\n});\n</code></pre> <p>Diese Funktion f\u00fchrt ein <code>GET</code> auf das Backend durch und holt sich von dort alle Daten. Wir \u00e4ndern diese Funktion zun\u00e4chst leicht, um zu erkennen, wann die Daten tats\u00e4chlich vom Backend geholt wurden. </p> /public/src/js/feed.js <pre><code>let networkDataReceived = false;\nfetch('http://localhost:3000/posts')\n.then((res) =&gt; {\nreturn res.json();\n})\n.then((data) =&gt; {\nnetworkDataReceived = true;\nconsole.log('From backend ...', data);\nupdateUI(data);\n});\n</code></pre> <p>Dazu erstellen wir uns eine Variable <code>networkDataReceived</code>, die auf <code>true</code> gesetzt wird, falls wir die Daten vom Backend holen. Dazu eine passende Ausgabe auf die Konsole. </p> <p>Nun erweiteren wir die <code>feed.js</code> um das Lesen der Daten aus der IndexedDB. Dazu f\u00fcgen wir folgende Anweisung hinzu:</p> /public/src/js/feed.js <pre><code>let networkDataReceived = false;\n\nfetch('http://localhost:3000/posts')\n.then((res) =&gt; {\nreturn res.json();\n})\n.then((data) =&gt; {\nnetworkDataReceived = true;\nconsole.log('From backend ...', data);\nupdateUI(data);\n});\n\nif('indexedDB' in window) {\nreadAllData('posts')\n.then( data =&gt; {\nif(!networkDataReceived) {\nconsole.log('From cache ...', data);\nupdateUI(data);\n}\n})\n}\n</code></pre> <p>In Zeile <code>67</code> \u00fcberpr\u00fcfen wir zun\u00e4chst, ob der Browser \u00fcberhaupt die IndexedDB-API unterst\u00fctzt. Wenn ja, dann lesen wir mithilfe der <code>readAllData()</code>-Funktion aus der <code>db.js</code> alle Daten aus dem <code>posts</code>-Store. Sollten die Daten nicht vom Backend geholt worden sein (sonst w\u00e4re <code>networkDataReceived === true</code>), dann werden die aus der IndexedDB geholten Daten verwendet, um die <code>Cards</code> zu erstellen (<code>updateUI(data)</code> in Zeile <code>72</code>). </p> <p>Das hei\u00dft, wir haben hier eine network first-Strategie implemntiert. Wenn der Zugriff auf das Backend m\u00f6glich ist, dann werden die Daten von dort geholt und auch dazu verwendet, um die <code>Cards</code> zu erstellen. Nur f\u00fcr den Fall, dass das Netzwerk nicht verf\u00fcgbar ist, werden die aus der IndexedDB geholten Daten verwendet, um die <code>Cards</code> zu erstellen. </p> <p>Wir testen diese Implementierung. Achten Sie darauf, die Versionsnummern der Caches in der <code>sw.js</code> zu \u00e4ndern, denn wir haben ja die <code>index.html</code> und die <code>feed.js</code> ge\u00e4ndert. Diese \u00c4nderungen w\u00fcrden nicht wirksam sein, ohne Versions\u00e4nderungen der Caches, da ansonsten die Dateien aus dem statischen Cache und nicht vom Webserver gelesen w\u00fcrden. </p> <ol> <li>Stellen Sie auch sicher, dass Ihr Backend gestartet ist.</li> <li>Reloaden Sie die Anwendung im Browser. </li> <li><code>skipWaiting</code> den neuen Service Worker</li> <li>checken, ob der neuen statische Cache unter <code>Cache --&gt; Cache-Storage</code> verwendet wird</li> <li>checken, ob die IndexedDB bef\u00fcllt ist (sollte durch <code>writeData()</code> im Service Worker passieren)</li> <li>In der Console steht <code>From backend ...</code> mit dem dazugeh\u00f6rigen Data-Array</li> <li>Schalten Sie im Service Worker die Anwendung nun offline und reloaden Sie die Anwendung</li> <li>In der Console erscheint <code>Fetch failed loading GET http://localhost:3000/posts</code> mit dem dazugeh\u00f6rigen Fehler, aber es erscheint auch <code>From cache ...</code> mit dem dazugeh\u00f6rigen Daten-Array. Es werden alle <code>cards</code> erstellt und angezeigt.</li> </ol> <p>Die Anwendung ist nun auch insofern offline-f\u00e4hig geworden, dass nun die dynamischen Daten in die IndexedDB geschrieben und aus der IndexedDB gelesen werden. </p>"},{"location":"indexeddb/#loschen-der-indexeddb","title":"L\u00f6schen der IndexedDB","text":"<p>Wir schreiben unsere Daten in die IndexedDB mithilfe der <code>put()</code>-Funktion (siehe Funktion <code>writeDate()</code> in der <code>db.js</code> und darin <code>store.put(data)</code>). Diese Funktion schreibt ein Schl\u00fcssel-Werte-Paar in den entsprechenden <code>store</code>. Existiert der \u00fcbergebene Schl\u00fcssel noch nicht, wird das Schl\u00fcssel-Werte-Paar der IndexedDB hinzugef\u00fcgt. Existiert der Schl\u00fcssel bereits, wird der alte Wert mit dem neuen Wert \u00fcberschrieben. Dadurch, dass es sich um lauter Schl\u00fcssel-Werte-Paare in der IndexedDB handelt, werden \"alte\" Schl\u00fcssel-Werte-Paare jedoch nicht gel\u00f6scht. Angenommen, wir rufen die <code>writeData()</code>-Funktion f\u00fcr alle Datens\u00e4tze auf, die in unserer Datenbank gespeichert haben und angenommen, wir haben aus dieser Datenbank einen Datensatz gel\u00f6scht, der aber noch in der IndexedDB gespeichert ist. Dann w\u00fcrde dieser Datensatz auch in der IndexedDB verbleiben.</p> <p>Wir schreiben uns deshalb eine Funktion, die zun\u00e4chst alle Daten in der Datenbank l\u00f6scht. Diese f\u00fchren wir dann immer aus, bevor wir die neuen Daten hinzuf\u00fcgen. In der <code>db.js</code> f\u00fcgen wir dazu die Funktion <code>clearAllData()</code> hinzu:</p> /public/src/js/db.js <pre><code>    const db = idb.openDB('posts-store', 1, {\nupgrade(db) {\n// Create a store of objects\nconst store = db.createObjectStore('posts', {\n// The '_id' property of the object will be the key.\nkeyPath: '_id',\n// If it isn't explicitly set, create a value by auto incrementing.\nautoIncrement: true,\n});\n// Create an index on the '_id' property of the objects.\nstore.createIndex('_id', '_id');\n},\n});\n\nfunction writeData(st, data) {\nreturn db\n.then( dbPosts =&gt; {\nlet tx = dbPosts.transaction(st, 'readwrite');\nlet store = tx.objectStore(st);\nstore.put(data);\nreturn tx.done;\n})\n}\n\n\nfunction readAllData(st) {\nreturn db\n.then( dbPosts =&gt; {\nlet tx = dbPosts.transaction(st, 'readonly');\nlet store = tx.objectStore(st);\nreturn store.getAll();\n})\n}\n\nfunction clearAllData(st) {\nreturn db\n.then( dbPosts =&gt; {\nlet tx = dbPosts.transaction(st, 'readwrite');\nlet store = tx.objectStore(st);\nstore.clear();\nreturn tx.done;\n})\n}\n</code></pre> <p>Diese rufen wir nun in der <code>sw.js</code> auf, bevor wir die neuen Daten in die IndexedDB schreiben:</p> sw.js <pre><code>self.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (!(event.request.url.indexOf('http') === 0)) return; // skip the request. if request is not made with http protocol\n\nconst url = 'http://localhost:3000/posts';\nif(event.request.url.indexOf(url) &gt;= 0) {\nevent.respondWith(\nfetch(event.request)\n.then ( res =&gt; {\nconst clonedResponse = res.clone();\nclearAllData('posts')\n.then( () =&gt; {\nclonedResponse.json()\n.then( data =&gt; {\nfor(let key in data)\n{\nconsole.log('write data', data[key]);\nwriteData('posts', data[key]);\n}\n})\n});\nreturn res;\n})\n)\n} else {\n</code></pre> <p>Die Funktion <code>clearAllData()</code> gibt ein Promise-Objekt zur\u00fcck. Nach dem erfolgreichen L\u00f6schen der Datenbank, k\u00f6nnen die neuen Daten hinzugef\u00fcgt werden. Deshalb wird das komplette <code>clonedResponse</code>-Promise-Objekt in die <code>then()</code>-Funktion des <code>clearAllData()</code>-Promise-Objektes geschoben. Aus dieser Verschachtelung k\u00f6nnen wir aber auch eine <code>.then()</code>-Verkettung machen, die vielleicht besser zu lesen ist (dann aber nicht das <code>return</code> vor <code>clonedResponse.json();</code> vergessen):</p> sw.js <pre><code>self.addEventListener('fetch', event =&gt; {\n// check if request is made by chrome extensions or web page\n// if request is made for web page url must contains http.\nif (!(event.request.url.indexOf('http') === 0)) return; // skip the request. if request is not made with http protocol\n\nconst url = 'http://localhost:3000/posts';\nif(event.request.url.indexOf(url) &gt;= 0) {\nevent.respondWith(\nfetch(event.request)\n.then ( res =&gt; {\nconst clonedResponse = res.clone();\nclearAllData('posts')\n.then( () =&gt; {\nreturn clonedResponse.json();\n})\n.then( data =&gt; {\nfor(let key in data)\n{\nconsole.log('write data', data[key]);\nwriteData('posts', data[key]);\n}\n});\nreturn res;\n})\n)\n} else {\n</code></pre>"},{"location":"indexeddb/#loschen-einzelner-eintrage","title":"L\u00f6schen einzelner Eintr\u00e4ge","text":"<p>Es k\u00f6nnen auch einzelne Eintr\u00e4ge aus der IndexedDb gel\u00f6scht werden. Der Zugriff auf die Datens\u00e4tze erfolgt \u00fcber den <code>keyPath</code> <code>_id</code> (siehe Erstellen der Datenbank und dort <code>openDB()</code>). Wir f\u00fcgen der <code>db.js</code> eine weitere Funktion <code>deleteOneData()</code> hinzu. Diese Funktion ben\u00f6tigt als Parameter neben dem <code>store</code> auch die <code>_id</code> des Datensatzes, den wir l\u00f6schen wollen. </p> /public/src/js/db.js <pre><code>function deleteOneData(st, id) {\ndb\n.then( dbPosts =&gt; {\nlet tx = dbPosts.transaction(st, 'readwrite');\nlet store = tx.objectStore(st);\nstore.delete(id);\nreturn tx.done;\n})\n.then( () =&gt; {\nconsole.log('Data deleted ...');\n});\n}\n</code></pre> <p>Wir geben das promise-Objekt <code>db</code> nicht zur\u00fcck, sondern \"verwerten\" es gleich hier, indem wir nach dem L\u00f6schen eine Ausgabe auf die Konsole erzeugen. </p> <p>Das Testen dieser Funktion in unserer Anwendnung ist derzeit nur \"Spielerei\". Wir werden diese Funktion aber sp\u00e4ter noch sinnvoll einsetzen. Beachten Sie, dass Sie nach \u00c4nderungen an der IndexedDB diese zun\u00e4chst \"refreshen\" m\u00fcssen (Button <code>Refresh database</code> - siehe Abbildung).</p> <p></p> <p>Success</p> <p>Wir k\u00f6nnen nun die In-Browser-Datenbank IndexedDB verwenden, um dynamische Daten zu speichern, auszulesen und zu l\u00f6schen. Somit bleibt unsere Anwendung auch dann noch aktiv, auch wenn das Backend (und/oder die Datenbank) nicht erreichbar ist. Die IndexedDB kann f\u00fcr alle Arten von Schl\u00fcssel-Werte-Paaren verwendet werden. Weitere Informationen finden Sie unter IndexedDB API.</p>"},{"location":"kamera/","title":"Ger\u00e4tezugriffe - Kamera","text":"<p>Hint</p> <p>Aktueller Stand vor Ger\u00e4tezugriffe:</p> <ul> <li>Frontend</li> <li>Backend</li> <li>Collection post</li> <li>Collection post.files</li> <li>Collection post.chunks</li> </ul> <p>Nun wollen wir noch auf Ger\u00e4teschnittstellen zugreifen. Dazu geh\u00f6ren die Kamera und auch die Geolocation-API, um unseren Standort zu ermitteln. Fr\u00fcher war JavaScript eine \"SandBox\", d.h. JavaScript-Code war vollst\u00e4ndig innerhalb des Browsers gekapselt und hatte keinerlei Zugriff nach au\u00dfen. Das \u00e4nderte sich mit dem <code>Upload File</code>-Button. JavaScript bekam (sehr eingeschr\u00e4nkten) Zugriff auf das Dateisystem (nur lesend). In der Zwischenzeit hat sich das komplett gewandelt. JavaScript l\u00e4uft erstens auch auf Servern und hat zweitens \u00fcber eine Vielzahl von APIs Zugriff auf unterschiedlichste Schnittstellen zum System. Wir wollen hier zun\u00e4chst betrachten, wie JavaScript auf die Kamera zugreifen kann. Sp\u00e4ter ermitteln wir auch noch den eigenen Standort. </p>"},{"location":"kamera/#zunachst-ein-bisschen-mehr-responsive","title":"Zun\u00e4chst ein bisschen mehr responsive","text":"<p>Unser HTW Insta entwickelt sich langsam. Deshalb ist hier vielleicht ein guter Zeitpunkt, um die Anwendung noch etwas mehr responsive zu gestalten. </p>"},{"location":"kamera/#media-queries","title":"Media Queries","text":"<p>Zum Beispiel sind die <code>Cards</code> stets in fester Gr\u00f6\u00dfe, unabh\u00e4ngig davon, ob wir die Anwendung am Desktop betrachten oder am Mobilger\u00e4t. </p> <p>Dazu k\u00f6nnen wir in unsere <code>feed.css</code> ein paar Media queries einf\u00fcgen:</p> /src/css/feed.css <pre><code>#create-post {\nz-index: 1001;\nposition: fixed;\nwidth: 100%;\nmin-height: 100vh;\noverflow-y: scroll;\nbottom: 0;\ntop: 56px;\nbackground: white;\ntext-align: center;\nvisibility: hidden;\n}\n\n.main-image {\nmax-width: 100%;\nmargin: auto;\ndisplay: block;\n}\n\n.whiteText {\ncolor: white;\n}\n\n.floating-button {\nz-index: 1000;\nposition: fixed;\nbottom: 0;\nright: 0;\npadding: 30px;\n}\n\n.input-section {\ndisplay: block;\nmargin: 10px auto;\n}\n\n.shared-moment-card.mdl-card {\nmargin: 10px auto;\nwidth: 80%;\n}\n\n@media (min-width: 600px) {\n.shared-moment-card.mdl-card {\nwidth: 60%;\n}\n}\n\n@media (min-width: 1200px) {\n.shared-moment-card.mdl-card {\nwidth: 45%;\n}\n}\n\n.shared-moment-card .mdl-card__title {\nheight: 250px;\n}\n\n@media (min-height: 600px) {\n.shared-moment-card .mdl-card__title {\nheight: 300px;\n}\n}\n\n@media (min-height: 1200px) {\n.shared-moment-card .mdl-card__title {\nheight: 380px;\n}\n}       </code></pre> <p>Wir haben sowohl f\u00fcr die Viewport-H\u00f6he als auch f\u00fcr die Viewport-Breite zwei Breakpoints eingebaut. Bei jeweils <code>600px</code> bzw. <code>1200px</code> \u00e4ndern sich die Angaben zur H\u00f6he bzw. Breite der Bilder in den <code>Cards</code>. Achtung: In <code>feed.js</code> muss dazu die Zeile </p> <pre><code>cardTitle.style.height = '180px';\n</code></pre> <p>gel\u00f6scht werden! Die H\u00f6he und Breite der Bilder in den <code>Cards</code> passt sich jetzt (besser)  der Viewport-Breite und -H\u00f6he an. Bei den Breiten haben wir sogar %-Angaben verwendet (gut), bei den H\u00f6hen nur feste Pixel-Werte (nicht so gut). Sie k\u00f6nnen gerne damit herumspielen und es an Ihre Bed\u00fcrfnisse anpassen. Mehr zu Media Queries finden Sie z.B. hier und hierhttps://wiki.selfhtml.org/wiki/CSS/Media_Queries.</p>"},{"location":"kamera/#srcset-attribut-fur-img","title":"srcset-Attribut f\u00fcr img","text":"<p>Die Verwendung der Bilder k\u00f6nnen wir noch auf eine andere Art responsive gestalten. Je nach Viewport-Gr\u00f6\u00dfe k\u00f6nnen die Bilder eingebunden werden, deren Aufl\u00f6sung \"ausreicht\". In dem <code>/public/src/images/</code>-Ordner haben wir f\u00fcr unser Hauptbild oben drei verschiedene Versionen:</p> <ul> <li><code>htw.jpg</code>, mit der Aufl\u00f6sung <code>898 x 343</code> Pixel,</li> <li><code>htw-lg.jpg</code>, mit der Aufl\u00f6sung <code>1199 x 457</code> Pixel und</li> <li><code>htw-sm.jpg</code>, mit der Aufl\u00f6sung <code>480 x 183</code> Pixel.</li> </ul> <p>Es w\u00e4re unsinnig, beisielsweise das <code>htw-lg.jp</code> auf einem schmalen Viewport anzuzeigen, da daf\u00fcr die Aufl\u00f6sung des <code>htw-sm.lpg</code> v\u00f6llig gen\u00fcgt. Da Letzteres auch noch deutlich kleiner ist (<code>43 KB</code>), als das <code>htw-lg.jpg</code>-Bild (<code>170 KB</code>), lie\u00dfe sich auch die Ladezeit verringern, wenn f\u00fcr mobile Ger\u00e4te das kleiner Bild verwendet w\u00fcrde. Auf der anderen Seite sieht dieses Bild aufgrund seiner niedrigen Aufl\u00f6sung in gro\u00dfen Viewports (also am Desktop-Monitor) nicht gut aus. Dort ben\u00f6tigen wir das <code>htw-lg.jpg</code>. Um diesen Wechsel der Bilder je nach Viewport-Gr\u00f6\u00dfe zu vereinfachen, wurde in HTML5 f\u00fcr das <code>img</code>-Element das Attribut <code>srcset</code> hinzugef\u00fcgt (siehe z.B. hier  oder hier). In unserer <code>index.html</code> k\u00f6nnen wir also das Einbinden des <code>img</code>-Elementes wie folgt erweitern:</p> /index.html <pre><code>&lt;img srcset=\"/src/images/htw-lg.jpg 1200w, \n             /src/images/htw.jpg 900w,\n             /src/images/htw-sm.jpg 480w\" \n     src=\"/src/images/htw.jpg\" alt=\"HTW Wilhelminenhof\" class=\"main-image\"&gt;\n</code></pre> <p>Zuvor stand dort einfach nur: <code>&lt;img src=\"/src/images/htw.jpg\" alt=\"HTW Wilhelminenhof\" class=\"main-image\"&gt;</code>. Wir haben also das <code>srcset</code>-Attribut hinzugef\u00fcgt. Das generelle Template daf\u00fcr sieht so aus:</p> <pre><code>&lt;img srcset=\"url size, \n             url size,\n             url size\" \n     src=\"default url\" &gt;\n</code></pre> <p>Das hei\u00dft, nach den URLs auf die jeweiligen Bilder schreiben wir noch die Gr\u00f6\u00dfe des Viewports, ab denen die Bilder verwendet werden sollen, also <code>1200w, 900w, 480w</code>. Dabei steht <code>w</code> f\u00fcr <code>width</code>. M\u00f6glich w\u00e4re auch noch, dass man statt <code>w</code> ein <code>x</code> angibt und dann die Anzahl der Pixel verwendet f\u00fcr die Viewportgr\u00f6\u00dfe. Das Laden der unterschiedlichen Images kann in den DeveloperTools unter <code>Network</code> beobachtet werden. </p>"},{"location":"kamera/#animationen","title":"Animationen","text":"<p>Wenn wir auf der Hauptseite auf den <code>+</code>-Button klicken, dann \"erscheint\" das Formular zur Dateneingabe einfach. Das liegt daran, dass wir in der <code>feed.js</code> bei den Funktionen <code>openCreatePostModal()</code> und <code>closeCreatePostModal()</code> die Sichtbarkeit einfach an- und ausschalten. Wir k\u00f6nnten das aber auch etwas \"netter\" durch eine Animation gestalten. Dazu verwenden wir translateY und transition. <code>translateY()</code> verschiebt ein Element in <code>y</code>-Richtung (also rauf oder runter) und <code>transition</code> kann eine Zeit \u00fcbergeben werden, die angibt, wie lange der Wechsel von Werten einer Eigenschaft dauern soll - also eine Animation. </p> <p>In der <code>feed.ccs</code> \u00e4ndern wir f\u00fcr die <code>id=create-post</code>:</p> <pre><code>#create-post {\nz-index: 1001;\nposition: fixed;\nwidth: 100%;\nmin-height: 100vh;\noverflow-y: scroll;\nbottom: 0;\ntop: 56px;\nbackground: white;\ntext-align: center;\n/* visibility: hidden; */\ntransform: translateY(100vH);\ntransition: transform 0.3s;\n}\n</code></pre> <p>Die Zeile <code>11</code> kann nat\u00fcrlich ganz raus. In der <code>feed.js</code> \u00e4ndern wir f\u00fcr die beiden Methoden:</p> <pre><code>function openCreatePostModal() {\ncreatePostArea.style.transform = 'translateY(0)';\n}\n\nfunction closeCreatePostModal() {\ncreatePostArea.style.transform = 'translateY(100vH)';\n}\n</code></pre> <p>und danach \"slided\" das Formular von unten nach oben ein. <code>vH</code> ist eine Einheit in Relation zum Viewport. <code>100vH</code> ist die gesamte Viewporth\u00f6he, <code>1vH</code> ist der 100te Teil der Viewporth\u00f6he (siehe z.B. hier).</p> <p>Wir wollen nun die Kamera verwenden, um Bilder aufzunehmen. Au\u00dferdem wollen wir einen <code>titel</code> und eine <code>location</code> eingeben k\u00f6nnen und alles zusammen als Post versenden.  </p>"},{"location":"kamera/#einen-post-an-das-backend-senden","title":"Einen Post an das Backend senden","text":"<p>Um die eingegebenen Daten zu senden, wollen wir den <code>Speichern</code>-Button aus der <code>index.html</code> </p> <pre><code>&lt;button class=\"mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\"\n        type=\"submit\" id=\"post-btn\"&gt;Speichern\n&lt;/button&gt;\n</code></pre> <p>mit der <code>feed.js</code> verbinden. Dazu definieren wir uns zun\u00e4chst mithilfe von jQuery weitere Variablen f\u00fcr den direkten Zugriff auf Stuerelemente. Wir erweiteren die <code>feed.js</code> um die hervorgehobenen Zeilen:</p> /src/js/feed.js <pre><code>let shareImageButton = document.querySelector('#share-image-button');\nlet createPostArea = document.querySelector('#create-post');\nlet closeCreatePostModalButton = document.querySelector('#close-create-post-modal-btn');\nlet sharedMomentsArea = document.querySelector('#shared-moments');\nlet form = document.querySelector('form');\nlet titleInput = document.querySelector('#title');\nlet locationInput = document.querySelector('#location');\n</code></pre> <p>Nun k\u00f6nnen wir einfacher auf das <code>submit</code>-Ereignis des <code>Speichern</code>-Buttons reagieren. Wir melden dazu das Formular an den Ereignislistener f\u00fcr das <code>submit</code>-Ereignis in der <code>feed.js</code> an:</p> /src/js/feed.js <pre><code>form.addEventListener('submit', event =&gt; {\nevent.preventDefault(); // nicht absenden und neu laden\n\nif (titleInput.value.trim() === '' || locationInput.value.trim() === '') {\nalert('Bitte Titel und Location angeben!')\nreturn;\n}\n\ncloseCreatePostModal();\n});\n</code></pre> <p>Wir verhindern zun\u00e4chst das Standardverhalten beim <code>submit</code>-Ereignis, n\u00e4mlich das Absenden der Daten und das Neuladen der Seite (Zeile <code>80</code>). In Zeile <code>82</code> pr\u00fcfen wir, ob beide <code>input</code>-Elemente, also sowohl f\u00fcr <code>title</code>, als auch f\u00fcr <code>location</code> einen Wert enthalten. Die JavaScript-<code>trim()</code>-Funktionen entfernt \"Leerzeichen\" aller Art am Ende des Strings (auch Tabs, Zeilenumbr\u00fcche etc.). Sollte eines der beiden (oder beide) Eingabefelder leer sein, beenden wir die Funktion mit einem <code>alert</code> und bleiben in dem Formular. <code>alert</code> ist nat\u00fcrlich nicht so toll, ein <code>toast</code> w\u00e4re viel besser, aber wir haben in unserer <code>index.html</code> nur einen <code>toast</code> f\u00fcr das erfolgreiche Speichern vordefiniert. Wenn beide Eingabefelder bef\u00fcllt sind, wird das Formularfenster verlassen. </p> <p>Um die Daten an das Backend zu senden, verwenden wir die <code>fetch()</code>-Funktion und die <code>POST</code>-Methode. H\u00e4tten wir nur Textdaten, die wir \u00fcbertragen wollen, k\u00f6nnten wir ein einfaches JSON senden (und wieder empfangen). Die <code>fetch()</code>-Funktion k\u00f6nnte dann so aussehen:</p> Beispiel fetch f\u00fcr POST <pre><code>fetch('http://localhost:3000/posts', {\nmethod: 'POST',\nheaders: {\n'Content-Type': 'application/json',\n'Accept': 'application/json',\n},\nbody: JSON.stringify({\ntitle: titleInput.value,\nlocation: locationInput.value,\nimage_id: '',\n})\n})\n.then( response =&gt; {\nconsole.log('Data sent to backend ...', response);\nreturn response.json();\n})\n.then( data =&gt; {\nconsole.log('data ...', data);\nupdateUI(Object.entries(data));\n});\n</code></pre> <p>Wir versenden jedoch <code>form-data</code>. Dazu erstellen wir ein <code>FormData</code>-Objekt (siehe FormData). Wir f\u00fcgen dazu eine Funktion <code>sendDataToBackend()</code> in die <code>feed.js</code> ein und rufen diese f\u00fcr die Behandlung des <code>submit</code>-Ereignisses auf:</p> /src/js/feed.js <pre><code>function sendDataToBackend() {\nconst formData = new FormData();\nformData.append('title', titleValue);\nformData.append('location', locationValue);\nformData.append('file', file);\n\nconsole.log('formData', formData)\n\nfetch('http://localhost:3000/posts', {\nmethod: 'POST',\nbody: formData\n})\n.then( response =&gt; {\nconsole.log('Data sent to backend ...', response);\nreturn response.json();\n})\n.then( data =&gt; {\nconsole.log('data ...', data);\nconst newPost = {\ntitle: data.title,\nlocation: data.location,\nimage_id: imageURI\n}\nupdateUI([newPost]);\n});\n}\n\nform.addEventListener('submit', event =&gt; {\nevent.preventDefault(); // nicht absenden und neu laden\n\nif (file == null) {\nalert('Erst Foto aufnehmen!')\nreturn;\n}\nif (titleInput.value.trim() === '' || locationInput.value.trim() === '') {\nalert('Bitte Titel und Location angeben!')\nreturn;\n}\n\ncloseCreatePostModal();\n\ntitleValue = titleInput.value;\nlocationValue = locationInput.value;\n\nsendDataToBackend();\n});\n</code></pre> <p>In dieser Funktion werden mehrere Variablen verwendet, die in der <code>feed.js</code> deklariert werden m\u00fcssen:</p> /src/js/feed.js <pre><code>let file = null;\nlet titleValue = '';\nlet locationValue = '';\nlet imageURI = '';\n</code></pre> <p>Wir sehen, dass die Werte der Variablen <code>titleValue</code> und <code>locationValue</code> durch das <code>submit</code>-Ereignisses des Eingabeformulars (des <code>Speichern</code>-Buttons) gesetzt werden (siehe oben <code>feed.js</code> Zeilen <code>120</code> und <code>121</code>). Die Werte der Variablen <code>file</code> und <code>imageURI</code> erhalten wir jedoch erst, wenn wir ein Foto mit der Kamera aufnehmen. Das schauen wir uns im Folgenden an:</p>"},{"location":"kamera/#aufnehmen-von-fotos","title":"Aufnehmen von Fotos","text":"<p>In der <code>feed.js</code> haben wir den Wert von <code>image_id</code> zun\u00e4chst noch leer gelassen. Wir wollen nun die Kamera anbinden und damit ein Foto aufnehmen, das wir mitversenden. Dazu erweiteren wir die Anwendung zun\u00e4chst, um neben <code>title</code> und <code>location</code> auch noch ein drittes Eingabefeld f\u00fcr die Bilder zu erhalten. </p> <p>Dazu erweiteren wir zun\u00e4chst die <code>public/index.html</code>: </p> public/index.html <pre><code>&lt;form&gt;\n  &lt;div id=\"create-post\"&gt;\n&lt;video id=\"player\" autoplay&gt;&lt;/video&gt;\n&lt;canvas id=\"canvas\" width=\"320px\" height=\"240px\"&gt;&lt;/canvas&gt;\n&lt;button class=\"mdl-button mdl-js-button mdl-button--raised mdl-button--colored\" id=\"capture-btn\"&gt;Foto&lt;/button&gt;\n&lt;div id=\"pick-image\"&gt;\n&lt;h6&gt;Bild ausw\u00e4hlen&lt;/h6&gt;\n&lt;input type=\"file\" accept=\"image/*\" id=\"image-picker\"&gt;\n&lt;/div&gt;\n&lt;div class=\"input-section mdl-textfield mdl-js-textfield mdl-textfield--floating-label\"&gt;\n        &lt;input class=\"mdl-textfield__input\" type=\"text\" id=\"title\"&gt;\n        &lt;label class=\"mdl-textfield__label\" for=\"title\" name=\"title\"&gt;Titel&lt;/label&gt;\n      &lt;/div&gt;\n      &lt;div class=\"input-section mdl-textfield mdl-js-textfield mdl-textfield--floating-label\" id=\"manual-location\"&gt;\n        &lt;input class=\"mdl-textfield__input\" type=\"text\" id=\"location\"&gt;\n        &lt;label class=\"mdl-textfield__label\" for=\"location\" name=\"location\"&gt;Ort&lt;/label&gt;\n      &lt;/div&gt;\n      &lt;!-- \n      &lt;div class=\"input-section\"&gt;\n        &lt;button class=\"mdl-button mdl-js-button mdl-button--colored\" type=\"button\" id=\"location-btn\"&gt;Location&lt;/button&gt;\n        &lt;div class=\"mdl-spinner mdl-js-spinner is-active\" id=\"location-loader\"&gt;&lt;/div&gt;\n      &lt;/div&gt;\n      --&gt;\n      &lt;br&gt;\n      &lt;div&gt;\n        &lt;button class=\"mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\"\n                type=\"submit\" id=\"post-btn\"&gt;Speichern\n        &lt;/button&gt;\n      &lt;/div&gt;\n      &lt;br&gt;\n      &lt;div&gt;\n        &lt;button class=\"mdl-button mdl-js-button mdl-button--fab\" id=\"close-create-post-modal-btn\" type=\"button\"&gt;\n          &lt;i class=\"material-icons\"&gt;close&lt;/i&gt;\n        &lt;/button&gt;\n      &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/form&gt;\n</code></pre> <p>Das <code>&lt;video&gt;</code>- (Zeile <code>67</code>) und das <code>&lt;canvas&gt;</code>-Element (Zeile <code>68</code>) werden verwendet, um mit der Kamera Bilder aufzunehmen, die mit dem <code>&lt;button&gt;</code> (Zeile <code>69</code>) gespeichert werden. Der <code>image-picker</code> (Zeilen <code>70-73</code>) wird ben\u00f6tigt, falls das Ger\u00e4t \u00fcber keine Kamera (oder keinen Kamerazugriff) verf\u00fcgt. Au\u00dferdem f\u00fcgen wir noch eine weitere Eingabesection f\u00fcr die <code>Location</code> hinzu mit einem Button und einem <code>spinner</code>, der anzeigen soll, dass etwas passiert. Diese Eingabesection haben wir aber zun\u00e4chst auskommentiert, da wir diese erst beim Thema Geo-Location verwenden. </p> <p>Wir verwenden die CSS-Klassen und -Ids auch noch, um die Eingabe etwas \"sch\u00f6ner\" aussehen zu lassen und erweiteren dazu die <code>feed.css</code>:</p> public/src/css/feed.css <pre><code>#create-post {\nz-index: 1001;\nposition: fixed;\nwidth: 100%;\nmin-height: calc(100vh - 56px);\noverflow-y: scroll;\nbottom: 0;\ntop: 56px;\nbackground: white;\ntext-align: center;\n/* visibility: hidden; */\ntransform: translateY(100vH);\ntransition: transform 0.3s;\n}\n\n#create-post video, #create-post canvas {\nwidth: 512px;\nmax-width: 100%;\ndisplay: none;\nmargin: auto;\n}\n#create-post #pick-image {\ndisplay: none;\n}\n#create-post #capture-btn {\nmargin: 10px auto;\n}\n.mdl-spinner {\nmargin: auto;\n}\n/* hier der Rest */\n</code></pre> <p>Die CSS-Definitionen sorgen insbesondere daf\u00fcr, dass das Video- , Canvas- und File-Picker-Element zun\u00e4chst versteckt ist. </p> <p>Wir wollen uns zun\u00e4chst darum k\u00fcmmern, ein Live-Bild der Kamera in das Canvas-Element zu integrieren, d.h. wir k\u00fcmmern uns zun\u00e4chst um den Kamerazugriff. </p>"},{"location":"kamera/#kamera-zugriff","title":"Kamera-Zugriff","text":"<p>F\u00fcr den Kamerazugriff ben\u00f6tigen wir etwas JavaScript-Code. Wir erweitern die <code>feed.js</code>. Zun\u00e4chst vereinfachen wir die Zugriffe auf die einzelnen Elemente und f\u00fcgen eine Funktion hinzu, mit der wir den Zugriff auf die Kamera pr\u00fcfen und herstellen wollen:</p> public/src/js/feed.js <pre><code>let shareImageButton = document.querySelector('#share-image-button');\nlet createPostArea = document.querySelector('#create-post');\nlet closeCreatePostModalButton = document.querySelector('#close-create-post-modal-btn');\nlet sharedMomentsArea = document.querySelector('#shared-moments');\nlet form = document.querySelector('form');\nlet titleInput = document.querySelector('#title');\nlet locationInput = document.querySelector('#location');\nlet videoPlayer = document.querySelector('#player');\nlet canvasElement = document.querySelector('#canvas');\nlet captureButton = document.querySelector('#capture-btn');\nlet imagePicker = document.querySelector('#image-picker');\nlet imagePickerArea = document.querySelector('#pick-image');\nlet file = null;\nlet titleValue = '';\nlet locationValue = '';\nlet imageURI = '';\n\nfunction initializeMedia() {\n}\nfunction openCreatePostModal() {\ncreatePostArea.style.transform = 'translateY(0)';\ninitializeMedia();\n}\n</code></pre> <p>In der neuen Funktion <code>initializeMedia()</code> wollen wir die MediaDevices-API verwenden. Ein Blick in die Dokumentation dieser API zeigt, dass die Browser-Unterst\u00fctzung noch nicht besonders gut ist, zumindest f\u00fcr einige der Methoden darin. Wir wollen aber insbesondere die <code>getUserMedia()</code>-Funktion verwenden und daf\u00fcr ist die Browser-Unterst\u00fctzung wiederum doch sehr gut (Chrom, Firefox, Edge und alle mobilen Ger\u00e4te). </p> <p>F\u00fcr den Fall, dass die <code>MediaDevices</code>-API nicht unterst\u00fctzt werden, erstellen wir uns im <code>navigator</code> ein eigenes <code>mediaDevices</code>-Objekt und pr\u00fcfen, ob die <code>getUserMedia()</code>-Funktion unterst\u00fctzt wird. Wenn dies nicht der Fall ist, erstellen wir uns f\u00fcr das neue <code>mediaDevices</code>-Objekt eine neue Eigenschaft <code>getUserDevices</code> und definieren es als eine Funktion. Diese Funktion nutzt dann alte Funktionen, die in den jeweiligen Browsern angeboten wurden (und werden). Wie gesagt, das ist nur ein Fallback f\u00fcr den Fall, dass ein Browser verwendet wird, der die <code>getUserMedia()</code>-Funktion in der <code>MediaDevices</code>-API nicht unterst\u00fctzt (was, wie wir oben erl\u00e4utert haben, nur noch selten der Fall ist). Wir erweitern f\u00fcr diesen seltenen Fall die <code>initializeMedia()</code>-Funktion:  </p> public/src/js/feed.js <pre><code>function initializeMedia() {\nif(!('mediaDevices' in navigator)) {\nnavigator.mediaDevices = {};\n}\n\nif(!('getUserMedia' in navigator.mediaDevices)) {\nnavigator.mediaDevices.getUserMedia = function(constraints) {\nlet getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\n\nif(!getUserMedia) {\nreturn Promise.reject(new Error('getUserMedia is not implemented'));\n}\n\nreturn new Promise( (resolve, reject) =&gt; {\ngetUserMedia.call(navigator, constraints, resolve, reject);\n})\n}\n}\n}\n</code></pre> <p>Wenn also die <code>MediaDevices</code>-API nicht unterst\u00fctzt wird (Zeile <code>15</code>), dann erstellen wir einen eigenes <code>MediaDevices</code>-Objekt (Zeile <code>16</code>). F\u00fcr dieses eigene <code>MediaDevices</code>-Objekt erstellen wir eine <code>getUserMedia()</code>-Funktion (Zeile <code>20</code>). Diese Funktion gibt eine <code>Promise</code> zur\u00fcck. Entweder, eine Promise mit dem Zustand <code>rejected</code> (Zeile <code>24</code>), n\u00e4mlich genau dann, wenn der Browser auch nicht die alten Funktionen <code>webkitUserMedia</code> und <code>mozGetUserMedia</code> unterst\u00fctzt. Dann k\u00f6nnen wir wirklich nichts mehr machen. Oder die Promise verwendet eine der beiden Funktionen und gibt die Promise nach Anwendung zur\u00fcck - kann nat\u00fcrlich trotzdem noch sein, dass sie <code>rejected</code> wird, aber vielleicht auch <code>resolved</code>. Jedenfalls bezieht sich dieser gesamte Code auf den Fall, dass <code>getUserMedia()</code> in <code>navigator.mediaDevices</code> nicht unterst\u00fctzt wird. Es handelt sich bei diesem Code um ein sogenanntes Polyfill.</p> <p>Wir k\u00fcmmern uns jetzt darum, tats\u00e4chlich Zugriff zur Kamera zu bekommen. Das kann nun entweder \u00fcber die moderne <code>getUserMedia()</code>-Funktion aus <code>navigator.mediaDevices</code> geschehen oder \u00fcber das Polyfill unter Verwendung von <code>webkitGetUserMedia()</code> oder <code>mozGetUserMedia()</code>. Nur f\u00fcr den Fall, dass wir keinen Zugriff auf die Kamera erhalten, wollen wir den <code>File-Picker</code> verwenden, um eine Bilddatei hochzuladen. </p> public/src/js/feed.js <pre><code>function initializeMedia() {\nif(!('mediaDevices' in navigator)) {\nnavigator.mediaDevices = {};\n}\n\nif(!('getUserMedia' in navigator.mediaDevices)) {\nnavigator.mediaDevices.getUserMedia = function(constraints) {\nlet getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\n\nif(!getUserMedia) {\nreturn Promise.reject(new Error('getUserMedia is not implemented'));\n}\n\nreturn new Promise( (resolve, reject) =&gt; {\ngetUserMedia.call(navigator, constraints, resolve, reject);\n})\n}\n}\n\nnavigator.mediaDevices.getUserMedia({video: true})\n.then( stream =&gt; {\nvideoPlayer.srcObject = stream;\nvideoPlayer.style.display = 'block';\n})\n.catch( err =&gt; {\nimagePickerArea.style.display = 'block';\n});\n}\n</code></pre> <p>Ab Zeile <code>32</code> k\u00f6nnen wir auf jeden Fall auf die <code>getUserMedia()</code>-Funktion zugreifen und genau das tun wir auch in Zeile <code>33</code>. Dieser Funktion wird ein JavaScript-Objekt \u00fcbergeben. Dieses Objekt hat zwei Eigenschaften: <code>video</code> und <code>audio</code>. Beide sind auf <code>false</code> gesetzt, wir k\u00f6nnen sie jedoch mit <code>true</code> einschalten und erledigen das f\u00fcr <code>video</code> ebefalls in Zeile <code>33</code>. Diese Funktion gibt eine <code>promise</code> zur\u00fcck. Im <code>resolve</code>-Fall erhalten wir einen Video- und/oder Audio-<code>Stream</code>. Wir verwenden diesen <code>stream</code> als Quelle f\u00fcr unseren Videplayer (der aufgrund der Funktion <code>autoplay</code> den Stream sofort anzeigt). Wir setzen daf\u00fcr den Videoplayer auf sichtbar - <code>display: 'block'</code>. </p> <p>Der <code>reject</code>-Fall der Promise kann verschiedene Gr\u00fcnde haben. Ein Grund w\u00e4re, wie oben erl\u00e4utert, dass wir selbst mit dem Polyfill keinen Zugriff auf die Kamera bekommen. Ein anderer w\u00e4re, dass unser Ger\u00e4t gar nicht mit einer Kamera verbunden ist und ein dritter Fall w\u00e4re, dass der Zugriff auf die Kamera von der Nutzerin blockiert wird. Wenn die <code>getUserMedia()</code>-Funktion das erste Mal aufgerufen wird, erfolgt eine Abfrage, ob der Zugriff auf die Kamera zugelassen oder blockiert wird:</p> <p></p> <p>Die Entscheidung l\u00e4sst sich auch nachtr\u00e4glich \u00e4ndern, indem man auf das <code>i</code> links neben der URL klickt. Wenn Sie die Anwendung ausf\u00fchren und den Zugriff auf die Kamera erlauben, wird das Video sofort angezeigt.</p> <p></p> <p>Wird die Promise <code>rejected</code>, soll die gesamte <code>imagePickerArea</code> (wieder) auf <code>display: 'block'</code> gesetzt werden. In der Funktion <code>closeCreatePostModal()</code> setzen wir die Video- und File-Picker-Elemente ebenaflls alle (wieder) auf <code>display: 'block'</code>. </p> public/src/js/feed.js <pre><code>function closeCreatePostModal() {\ncreatePostArea.style.transform = 'translateY(100vH)';\nimagePickerArea.style.display = 'none';\nvideoPlayer.style.display = 'none';\ncanvasElement.style.display = 'none';\n}\n</code></pre> <p>Wird der Zugriff auf die Kamera blockiert, wird stattdessen der File-Picker angezeigt: </p> <p></p>"},{"location":"kamera/#das-click-ereignis-des-foto-buttons-behandeln","title":"Das Click-Ereignis des Foto-Buttons behandeln","text":"<p>Nun wollen wir den <code>Foto</code>-Button implementieren, damit wir ein Foto von dem Kamerastream erzeugen k\u00f6nnen. Dazu implementieren wir f\u00fcr diesen Button die Behandlung des <code>click</code>-Ereignisses:</p> public/src/js/feed.js <pre><code>captureButton.addEventListener('click', event =&gt; {\nevent.preventDefault(); // nicht absenden und neu laden\ncanvasElement.style.display = 'block';\nvideoPlayer.style.display = 'none';\ncaptureButton.style.display = 'none';\nlet context = canvasElement.getContext('2d');\ncontext.drawImage(videoPlayer, 0, 0, canvas.width, videoPlayer.videoHeight / (videoPlayer.videoWidth / canvas.width));\nvideoPlayer.srcObject.getVideoTracks().forEach( track =&gt; {\ntrack.stop();\n})\nimageURI = canvas.toDataURL(\"image/jpeg\");\n// console.log('imageURI', imageURI)       // base64-String des Bildes\n\nfetch(imageURI)\n.then(res =&gt; {\nreturn res.blob()\n})\n.then(blob =&gt; {\nfile = new File([blob], \"myFile.jpeg\", { type: \"image/jpeg\" })\nconsole.log('file', file)\n})\n});\n</code></pre> <p>Die Grundidee dabei ist die, dass wir das aktuelle Bild des <code>videoPlayers</code> in unser <code>canvasElement</code> einf\u00fcgen, das <code>canvasElement</code> sichtbar gestalten, den <code>videoPlayer</code> unsichtbar (und den Button dann auch gleich noch) und au\u00dferdem den Videoplayer stoppen. </p> <p>Das <code>Canvas</code>-Element verf\u00fcgt \u00fcber einen Grafikkontext, den wir in Zeile <code>48</code> als <code>2d</code> ausw\u00e4hlen. Siehe dazu auch HTMLCanvasElement.getContext(). F\u00fcr diesen <code>context</code> rufen wir die <code>drawImage()</code>-Funktion auf (siehe CanvasRenderingContext2D.drawImage()). </p> <ul> <li>der erste Parameter der <code>drawImage()</code>-Funktion ist das Bild. Wir \u00fcbergeben dazu den <code>videoPlayer</code>. </li> <li>der zweite und dritte Parameter ist die Koordinate des linken oberen Punktes innerhalb des Canvas-Elementes, hier <code>x=0</code> und <code>y= 0</code>.</li> <li>der dritte Parameter gibt die Breite des Bildes an. Wir nehmen hier die gesamte Breite des Canvas-Elementes.</li> <li>der vierte Parameter gibt die H\u00f6he des Bildes an. Da wir der Breite einen festen Wert zugewiesen haben (die Canvas-Breite), m\u00fcssen wir die H\u00f6he in Abh\u00e4ngigkeit der Relation des Videos berechnen. </li> </ul> <p>Wenn wir dieses Bild erstellt haben, k\u00f6nnen wir den Videoplayer stoppen. Die Funktion <code>getVideoTracks()</code> gibt ein Array allerlaufenden Streams auf der Webseite zur\u00fcck. Wir laufen durch dieses Array mithilfe der <code>forEach</code>-Schleife (Zeile <code>50</code>) und stoppen alle laufenden Streams (Zeile <code>51</code>). </p> <p>Wenn wir nun den <code>Foto</code>-Button klicken, sehen wir das (Stand-)Bild im <code>canvasElement</code>, der <code>videoPlayer</code> und der Button sind unsichtbar und der <code>videoPlayer</code> ist gestoppt. </p>"},{"location":"kamera/#bild-in-base64-umwandeln","title":"Bild in base64 umwandeln","text":"<p>Das <code>canvas</code>-Element (siehe HTMLCanvasElement aus der Canvas-API) besitzt eine Funktion <code>toDataURL()</code>, die ein Bild im angegebenen Format zur\u00fcckgibt (siehe HTMLCanvasElement.toDataURL()). Wir geben an, dass das Bild im <code>image/jpg</code>-Format zur\u00fcckgegeben werden soll (siehe Zeile <code>53</code>). Es wird ein <code>base64</code>-String erzeugt, den wir in der globalen Variablen <code>imageURI</code> speichern. </p>"},{"location":"kamera/#file-objekt-erzeugen","title":"File-Objekt erzeugen","text":"<p>Wir verf\u00fcgen nun \u00fcber eine <code>Data-URL</code> (siehe Data URLs) unseres Bildes. Mit dieser <code>Data-URL</code> k\u00f6nnen wir mithilfe der <code>fetch()</code>-Funktion ein <code>File</code>-Objekt erzeugen. Wir weisen unserem <code>File</code>-Objekt den Dateinamen <code>myFile.jpg</code> zu. Die Referenz auf dieses <code>File</code>-Objekt speichern wir in der globalen Variablen <code>file</code> (siehe Zeilen <code>56-63</code>). </p>"},{"location":"kamera/#speichern-des-bildes-im-backend","title":"Speichern des Bildes im Backend","text":"<p>Nun k\u00f6nnen wir bereits Fotos aufnehmen und diese speichern. Wenn wir nun die Funktion <code>sendDataToBackend()</code> aufrufen, werden die <code>title</code>-, <code>location</code>- und <code>file</code>-Werte als <code>FormData</code> an das Backend gesendet. Schauen wir uns dazu die <code>sendDataToBackend()</code>-Funktion nochmals genauer an:</p> <pre><code>function sendDataToBackend() {\nconst formData = new FormData();\nformData.append('title', titleValue);\nformData.append('location', locationValue);\nformData.append('file', file);\n\nconsole.log('formData', formData)\n\nfetch('http://localhost:3000/posts', {\nmethod: 'POST',\nbody: formData\n})\n.then( response =&gt; {\nconsole.log('Data sent to backend ...', response);\nreturn response.json();\n})\n.then( data =&gt; {\nconsole.log('data ...', data);\nconst newPost = {\ntitle: data.title,\nlocation: data.location,\nimage_id: imageURI\n}\nupdateUI([newPost]);\n});\n}\n</code></pre> <p>Mithilfe der <code>fetch()</code>-Funktion werden die <code>formData</code> an das Backend gesendet. Wir erhalten den neu angelegten Datensatz zur\u00fcck, z.B.:</p> <pre><code>{\n\"title\": \"Eingang\",\n\"location\": \"Tor WH\",\n\"image_id\": \"1652973765918-jf-htwbild4.jpg\",\n\"_id\": \"628660c55619a5a107acb19d\",\n\"__v\": 0\n}\n</code></pre> <p>Wir wollen den neuen Post sofort in unserer Anwendung anzeigen. Dazu rufen wir die <code>updateUI()</code>-Funktion auf und \u00fcbergeben den neuen Datensatz als Array (die Funktion <code>updateUI()</code> erwartet ein Array). Allerdings erwarten wir ja eigentlich f\u00fcr die Eigenschaft <code>image_id</code> einen <code>base64</code>-String. Allerdings gibt uns die POST-Anfrage an das Backend nicht diesen String zur\u00fcck, sondern den Dateinamen des Bildes in der Datenbank. Dazu haben wir uns aber den <code>base64</code>-String in <code>imageURI</code> gespeichert und verwenden ihn nun bei dem Datensatz, der an die <code>updateUI()</code>-Funktion \u00fcbergeben wird. </p> <p>Das war es schon, wir k\u00f6nnen nun die Daten an das Backend senden. Zum Testen nehmen Sie ein Foto auf, geben einen Titel und eine Location ein und klicken den <code>Speichern</code>-Button. Dann landnet - hoffentlich - alles im Backend. </p> <p>F\u00fcr den Fall, dass die Kamera nicht zur Verf\u00fcgung steht oder die <code>MediaDevices</code>-API oder der Kamerazugriff blockiert wurde, muss das Hochladen einer Bilddatei \u00fcber das <code>input</code>-Element vom Typ <code>file</code> implementiert werden. Dazu wird das <code>change</code>-Event des <code>Upload</code>-Buttons behandelt:</p>"},{"location":"kamera/#bilddatei-hochladen","title":"Bilddatei hochladen","text":"<p>Das Hochladen einer Bilddatei kennen wir ja bereits von unserem anderen Frontend. Hier ist nun auch schon alles vorbereitet und wir m\u00fcssen in der <code>feed.js</code> nur noch das <code>change</code>-Event f\u00fcr den <code>upload</code>-Button behandeln. Das sieht im Prinzip genau so aus, wie die Umwandlung des Canvas-Bildes, nur dass <code>picture</code> hier die hochgeladene Datei ist: </p> public/src/js/feed.js <pre><code>imagePicker.addEventListener('change', event =&gt; {\nfile = event.target.files[0];\n});\n</code></pre>"},{"location":"kamera/#letzte-verbesserungen","title":"Letzte Verbesserungen","text":"<p>Ein Nachteil in unserer Anwendung ist noch, dass die Kamera die ganze Zeit l\u00e4uft, wenn wir einmal den modalen Dialog zur Eingabe von daten ge\u00f6ffnet hatten. Wir sollten sie beim Ausschalten des modalen Dialoges schlie\u00dfen. Das Stoppen aller Videostreams hatten wir bereits f\u00fcr die Aufnahme des Fotos gemacht. Weil jedoch das Schlie\u00dfen und erneutes \u00d6ffnen der Kamera sehr ressourcenverbrauchend ist, laufen die Animationen f\u00fcr das \u00d6ffnen und Schlie\u00dfen des modalen Dialogs nicht mehr fl\u00fcssig. Wir lagern diese Animationen deshalb in einen asynchronen \"Thread\" aus (ist nicht wirklich ein neuer Thread): </p> public/src/js/feed.js <pre><code>function openCreatePostModal() {\nsetTimeout( () =&gt; {\ncreatePostArea.style.transform = 'translateY(0)';\n}, 1);\ninitializeMedia();\n}\n\nfunction closeCreatePostModal() {\nimagePickerArea.style.display = 'none';\nvideoPlayer.style.display = 'none';\ncanvasElement.style.display = 'none';\nif(videoPlayer.srcObject) {\nvideoPlayer.srcObject.getVideoTracks().forEach( track =&gt; track.stop());\n}\nsetTimeout( () =&gt; {\ncreatePostArea.style.transform = 'translateY(100vH)';\n}, 1);\n}\n</code></pre> <p>Mithilfe des <code>timeout</code>-\"Tricks\" wird der modale Dialog flie\u00dfend geschlossen und das Kamerazeichen im Tab des Browsers schlie\u00dft asynchron etwas sp\u00e4ter. </p> <p>Success</p> <p>Wir k\u00f6nnen nun Fotos mit der Kamera aufnehmen und die Bilder als Post an das Backend senden, wo es in die Datenbank gespeichert wird!</p>"},{"location":"manifest/","title":"Web-App-Manifest","text":"<p>Das Web-App-Manifest ist zun\u00e4chst einmal eine Datei, n\u00e4mlich <code>manifest.json</code>. Sie wird also in der JavaScript Object Notation (JSON) geschrieben. Diese Datei dient als Information f\u00fcr den Browser. Sie wird also vom Browser ausgelesen. Beispielsweise kann in der <code>manifest.json</code> vereinbart werden, dass sich die Webanwendung selbst auf dem Startbildschirm Ihres Mobilger\u00e4tes installiert. Dann gen\u00fcgt ein Klick auf das Icon auf dem Startbildschirm und die Webanwendung wird durch den Browser ge\u00f6ffnet. Somit h\u00e4tten wir schonmal eine wesentliche Gemeinsamkeit zu einer nativen App geschaffen, welche ja auch durch ein Klick auf ein Icon auf dem Startbildschirm gestartet werden k\u00f6nnen. </p> <p>Wir lernen kennen, wie wir ein solches Manifest unserer PWA hinzuf\u00fcgen, wie es konfiguriert werden kann und wie wir die Auswirkungen eines solchen Manifestes auf mobilen Ger\u00e4ten sehen k\u00f6nnen. </p>"},{"location":"manifest/#installierbar","title":"Installierbar","text":"<p>Mithilfe eines Web-App-Manifestes machen wir unsere Webanwendung installierbar auf einem mobilen Ger\u00e4t. Die Anwendung muss nicht einem App-Store hinzugef\u00fcgt werden, sondern wird einfach \u00fcber das Web durch einen Browser geladen. Normalerweise kann eine Webanwendung ja nur dadurch gestartet werden, dass ihre URL in den Browser eingetragen wird (oder Sie haben ein lesezeichen auf die Webanwendung in Ihrem Browser gesetzt). Nun wollen wir auf den Startbildschirm des Smartphones ein Icon setzen (genau wie f\u00fcr native Apps) und dar\u00fcber die Anwendung starten. </p> <p>Daf\u00fcr f\u00fcgen wir im Projektordner in dem Ordner <code>/public</code> die Datei <code>manifest.json</code> hinzu:</p> <p></p> <p>Diese Datei sollte genau so hei\u00dfen und es ist g\u00fcnstig, sie in den <code>/public</code>-Ordner zu legen. Achten Sie darauf, wohin Sie die Datei legen. Wenn Sie sie direkt in den Projektordner legen, dann gelten alle Pfadangaben in dieser Datei ausgehend von dieser Position. Wenn Sie sie in den <code>public</code>-Ordner legen, so wie wir, dann betrachten Sie die relativen Pfade, die Sie angeben, immer von diesem Ordner aus. </p> <p>Nun m\u00fcssen wir diese Datei jeder HTML-Seite unserer Anwendung bekannt machen. In unserer Anwendung existieren zwei <code>*.html</code>-Dateien, die <code>public/index.html</code> und die <code>public/help/index.html</code>. In beide Datein tragen wir im <code>&lt;head&gt;</code> folgenden Eintrag ein:</p> <pre><code>  &lt;link rel=\"manifest\" href=\"/manifest.json\"&gt;\n</code></pre> <p>Aber Achtung! : Die <code>public/help/index.html</code> liegt ja im Unterordner <code>/help</code>. Das bedeutet, dass von der Datei <code>public/help/index.html</code> aus gesehen, muss der <code>help</code>-Ordner erst verlassen werden, um die <code>manifest.json</code>-Datei zu erreichen. In die <code>public/help/index.html</code> schreiben wir also </p> <pre><code>  &lt;link rel=\"manifest\" href=\"../manifest.json\"&gt;\n</code></pre> <p>Das hei\u00dft, der <code>&lt;head&gt;</code>-Bereich der <code>public/index.html</code> sieht dann wie folgt aus (und der von <code>public/help/index.html</code> sehr \u00e4hnlich - achten Sie auf den korrekten relativen Pfad!):</p> <pre><code>&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta name=\"viewport\"\n        content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt;\n  &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;\n  &lt;title&gt;IKT-PWA&lt;/title&gt;\n  &lt;link href=\"https://fonts.googleapis.com/css?family=Roboto:400,700\" rel=\"stylesheet\"&gt;\n  &lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"&gt;\n  &lt;link rel=\"stylesheet\"\n        href=\"https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css\"&gt;\n  &lt;link rel=\"stylesheet\" href=\"/src/css/app.css\"&gt;\n  &lt;link rel=\"stylesheet\" href=\"/src/css/feed.css\"&gt;\n&lt;link rel=\"manifest\" href=\"/manifest.json\"&gt;\n&lt;/head&gt;\n</code></pre> <p>In einer Single Page Application muss der Eintrag nur einmal erfolgen - in der single page, der <code>index.html</code>. </p>"},{"location":"manifest/#mogliche-eigenschaften-in-der-manifestjson","title":"M\u00f6gliche Eigenschaften in der <code>manifest.json</code>","text":"<p>Eintr\u00e4ge in einer JSON-Datei sind key-value-Paare, d.h. ein Eintrag hat die folgende Form:</p> <pre><code>\"property\": value\n</code></pre> <p>oder auf Deutsch <code>\"eigenschaft\": wert</code>. JSON-Dateien beginnen und enden immer mit einer geschweiften Klammer und die einzelnen key-value-Paare sind durch Komma getrennt. <code>value</code> kann selbst ein JSON sein oder ein Array oder ein String oder eine Zahl. </p> <p>Wir betrachten nun einige ausgew\u00e4hlte properties, die in einer <code>manifest.json</code> definiert werden k\u00f6nnen. Einen vollst\u00e4ndigen \u00dcberblick \u00fcber alle m\u00f6glichen Eigenschaften und deren Umsetzung in den einzelnen Browsern finden Sie hier. Eine kurze Einf\u00fchrung zu <code>manifest.json</code> finden Sie auch hier. Die Spezifikation f\u00fcr das Web-App-Manifest vom W3C finden Sie hier.</p>"},{"location":"manifest/#name","title":"<code>name</code>","text":"<p>Mit der Eigenschaft <code>name</code> geben wir unserer Webanwendung eine Beschreibung. In der <code>package.json</code> haben wir unserer Anwendung bereits einen Namen gegeben, aber <code>name</code> aus der <code>manifest.json</code> beschreibt zum Beispiel den Namen der App auf dem Begr\u00fc\u00dfungsschrim, wie wir gleich sehen werden. Es ist ratsam, den Namen nicht l\u00e4nger als 45 Zeichen zu w\u00e4hlen (das ist die Begrenzung, die Google Chrome und Microsoft Edge f\u00fcr sich festgelegt haben). Wir sagen mal:</p> <pre><code>\"name\": \"HTW-Insta Erweiterung\"\n</code></pre> <p>Die Eigenschaft <code>name</code> ist in der <code>manifest.json</code> verpflichtend, d.h. sie muss angegeben werden (au\u00dferdem noch <code>version</code> und <code>manifest_version</code>, alle anderen Eigenschaften sind optional.)</p>"},{"location":"manifest/#short_name","title":"<code>short_name</code>","text":"<p>Der Wert von <code>short_name</code> wird z.B. verwendet als Name unserer App unter dem Icon auf dem Startbildschirm (falls der Name dort mit erscheint). Der <code>short_name</code> sollte nicht l\u00e4nger als 12 Zeichen sein. Ist kein <code>short_name</code> in der <code>manifest.json</code> angegeben, wird der Wert von <code>name</code> verwendet und, falls n\u00f6tig, einfach gek\u00fcrzt. </p> <pre><code>\"short_name\": \"HTW-Insta\"\n</code></pre>"},{"location":"manifest/#start_url","title":"<code>start_url</code>","text":"<p>Der Wert von <code>start_url</code> gibt den Pfad und die Datei an, die beim Starten unserer Anwendung geladen werden soll. In unserem Fall soll die <code>/public/index.html</code> geladen werden. Die <code>manifest.json</code>-Datei befindet sich im <code>/public</code>-ordner, also ist der Pfad zur Datei nur <code>/</code>.:</p> <pre><code>\"start_url\": \"/index.html\"\n</code></pre> <p>Beachten Sie (nochmal): der Pfad ist immer relativ zur <code>manifest.json</code>. Anegenommen, der Wert von <code>start_url</code> ist <code>../start_point.html</code> und die URL der <code>manifest.json</code> ist <code>https://example.com/resources/manifest.json</code>, dann w\u00fcrde die Anwendung unter <code>https://example.com/start_point.html</code> starten.</p>"},{"location":"manifest/#display","title":"<code>display</code>","text":"<p>Der Wert von <code>display</code> gibt an, wie die Anwendung beim Start aussehen soll. Wir haben die Auswahl zwischen den folgenden Werten:</p> <ul> <li><code>\"fullscreen\"</code>,</li> <li><code>\"standalone\"</code>,</li> <li><code>\"minimal-ui\"</code></li> </ul> <p>N\u00e4here Erl\u00e4uterungen zu den einzelnen Werten finden Sie hier, aber am besten ist, Sie probieren die unterschiedlichen Werte einfach mal aus. </p> <pre><code>\"display\": \"standalone\"\n</code></pre> <p>Bei <code>\"standalone\"</code> wird das Browser-fenster ausgeblendet, d.h. wir sehen die URL-Leiste nicht und auch nicht die Steuerelemente des Browsers. Die Anwendung wirkt wie eine native App. </p>"},{"location":"manifest/#background_color","title":"<code>background_color</code>","text":"<p>Der Wert von <code>background_color</code> ist eine Farbe, die wir typischerweise in hexadezimaler Schreibweise angeben. Ob wir diese Farbe \u00fcberhaupt sehen, h\u00e4ngt davon ab, wie lange unsere Anwendung zum Laden bracuht, denn mit <code>background_color</code> geben wir die Hintergrundfarbe des Bildschirms an, der gezeigt wird, w\u00e4hrend die Anwendung l\u00e4dt. Meistens sieht man das nicht, weil der Ladevorgang so schnell ist. </p> <pre><code>\"background_color\": \"#76B900\"\n</code></pre> <p>Wir w\u00e4hlen nat\u00fcrlich das HTW-Gr\u00fcn.  </p>"},{"location":"manifest/#theme_color","title":"<code>theme_color</code>","text":"<p>Der Wert von <code>theme_color</code> ist eine Farbe, die z.B. die Farbe der Werkzeugleiste auf dem Smartphone bestimmt.  <pre><code>\"theme_color\": \"#FF5F00\"\n</code></pre></p> <p>Wir w\u00e4hlen mal das HTW-Orange.  </p>"},{"location":"manifest/#description","title":"<code>description</code>","text":"<p>Wenn der Browser eine Beschreibung der App speichert, dann nutzt er den Wert von <code>description</code>, z.B. wenn Sie die App als Lesezeichen speichern.</p> <pre><code>\"description\": \"Eine tolle HTW-Insta-PWA\"\n</code></pre>"},{"location":"manifest/#lang","title":"<code>lang</code>","text":"<p>Mit der <code>lang</code>uage-Eigeneschaft definieren Sie die Sprache Ihrer App. Der Wert ist der 4-buchstabige L\u00e4ndercode, z.B. \"en-US\", \"en-UK\" oder \"de-DE\". </p> <pre><code>\"lang\": \"de-DE\"\n</code></pre> <p>Diese Eigenschaft wird vom Browser als Meta-Eigenschaft verwendet, kennen Sie schon aus den HTML-Dokumenten.</p>"},{"location":"manifest/#dir","title":"<code>dir</code>","text":"<p>Mit der <code>dir</code>ection-Eigeneschaft definieren Sie die Textrichtung Ihrer App. Die Werte sind einer der drei:</p> <ul> <li><code>\"ltr\"</code> (left to right)</li> <li><code>\"rtl\"</code> (right to left)</li> <li><code>\"auto\"</code></li> </ul> <p>Der Wert ist der 4-buchstabige L\u00e4ndercode, z.B. \"en-US\", \"en-UK\" oder \"de-DE\". </p> <pre><code>\"dir\": \"ltr\"\n</code></pre>"},{"location":"manifest/#orientation","title":"<code>orientation</code>","text":"<p>Mit der <code>orientation</code>-Eigeneschaft definieren Sie, in welchem Bildschirmmodus die App betrieben (geffnet) werden soll. Bei den Werten haben Sie die Wahl zwischen:</p> <ul> <li><code>\"any\"</code> </li> <li><code>\"natural\"</code> </li> <li><code>\"landscape\"</code></li> <li><code>\"landscape-primary\"</code></li> <li><code>\"landscape-secondary\"</code></li> <li><code>\"portrait\"</code> </li> <li><code>\"portrait-primary\"</code></li> <li><code>\"portrait-secondary\"</code> </li> </ul> <p>Die Angaben <code>primary</code> und <code>secondary</code> beziehen sich jeweils auf eine 180-Grad-Dreheung des Ger\u00e4tes. <code>secondary</code> \u00f6ffnet es also jeweils \"auf dem Kopf\". </p> <pre><code>\"orientation\": \"portrait-primary\"\n</code></pre> <p>Die Web-App sollte aber so gebaut werden, dass sie sowohl im Portrait- als auch im Landscape-Modus gut bedient werden kann (responsive). </p>"},{"location":"manifest/#icons","title":"<code>icons</code>","text":"<p>Die <code>icons</code>-Eigenschaft enth\u00e4lt ein Array aus Icons, die als das Icon der App auf dem Startbildschirm verwendet werden k\u00f6nnen. Typischerweise gibt man hier mehrere an, die sich in ihrer Aufl\u00f6sung unterscheiden, um das geeignete Icon ausw\u00e4hlen zu k\u00f6nnen, das zur Aufl\u00f6sung des Ausgabeger\u00e4tes passt. Gute Dimensionen sind z.B. 48X48 Pixel bis hin zu 512x512 Pixel.</p> <p>Die Beschreibung eines Icons ist selbst ein JSON und enth\u00e4lt drei Eigenschaften:</p> <ul> <li><code>\"src\"</code> (der Pafd zum Icon und die Datei)</li> <li><code>\"type\"</code> (der Typ des Bildes, z.B. <code>image/png</code>)</li> <li><code>\"sizes\"</code> (die Gr\u00f6\u00dfe des Bildes in Pixeln)</li> </ul> <p>Der Browser sucht sich in Abh\u00e4ngigkeit von der Aufl\u00f6sung des Ausgabeger\u00e4tes das am besten geeignete Icon selbst\u00e4ndig aus. </p> <pre><code>  \"icons\": [\n{\n\"src\": \"/src/images/icons/fiw48x48.png\",\n\"type\": \"image/png\",\n\"sizes\": \"48x48\"\n},\n{\n\"src\": \"/src/images/icons/fiw72x72.png\",\n\"type\": \"image/png\",\n\"sizes\": \"72x72\"\n},\n{\n\"src\": \"/src/images/icons/fiw96x96.png\",\n\"type\": \"image/png\",\n\"sizes\": \"96x96\"\n},\n{\n\"src\": \"/src/images/icons/fiw128x128.png\",\n\"type\": \"image/png\",\n\"sizes\": \"128x128\"\n},\n{\n\"src\": \"/src/images/icons/fiw256x256.png\",\n\"type\": \"image/png\",\n\"sizes\": \"256x256\"\n},\n{\n\"src\": \"/src/images/icons/fiw484x484.png\",\n\"type\": \"image/png\",\n\"sizes\": \"484x484\"\n}\n]\n</code></pre> <p>Auch hier sind wieder die korrekten relativen Pfade zu beachten.</p> <p>Es ist ziemlich m\u00fchsam, alle ben\u00f6tigten Icons und auch die obige JSON zu erzeugen. Zum Gl\u00fcck gibt es aber ein Werkzeug, das das f\u00fcr uns \u00fcbernimmt: pwa-asset-generator. Sie ben\u00f6tigen nur das Ausgangsicon in Originalgr\u00f6\u00dfe und alles andere wird f\u00fcr Sie erledgt. Bitte unbedingt verwenden, um sich m\u00fchsame Arbeit zu sparen!</p>"},{"location":"manifest/#testen-der-manifestjson","title":"Testen der <code>manifest.json</code>","text":"<p>Insgesamt sieht unsere <code>manifest.json</code> nun so aus:</p> public/manifest.json <pre><code>{\n\"name\": \"HTW-Insta Erweiterung\",\n\"short_name\": \"HTW-Insta\",\n\"start_url\": \"/index.html\",\n\"id\": \"/index.html\",\n\"display\": \"standalone\",\n\"background_color\": \"#76B900\",\n\"description\": \"Eine tolle HTW-Insta-PWA\",\n\"lang\": \"de-DE\",\n\"dir\": \"ltr\",\n\"orientation\": \"portrait-primary\",\n\"icons\": [\n{\n\"src\": \"/src/images/icons/fiw48x48.png\",\n\"type\": \"image/png\",\n\"sizes\": \"48x48\"\n},\n{\n\"src\": \"/src/images/icons/fiw72x72.png\",\n\"type\": \"image/png\",\n\"sizes\": \"72x72\"\n},\n{\n\"src\": \"/src/images/icons/fiw96x96.png\",\n\"type\": \"image/png\",\n\"sizes\": \"96x96\"\n},\n{\n\"src\": \"/src/images/icons/fiw128x128.png\",\n\"type\": \"image/png\",\n\"sizes\": \"128x128\"\n},\n{\n\"src\": \"/src/images/icons/fiw256x256.png\",\n\"type\": \"image/png\",\n\"sizes\": \"256x256\"\n},\n{\n\"src\": \"/src/images/icons/fiw484x484.png\",\n\"type\": \"image/png\",\n\"sizes\": \"484x484\"\n}\n]\n}\n</code></pre> <p>Wir rufen unsere Anwendung im Browser (Verwenden Sie Google Chrome!) auf und \u00f6ffnen au\u00dferdem die DevTools:</p> <p></p> <p>W\u00e4hlen Sie f\u00fcr die Darstellung der App eine Mobilansicht aus () und klicken Sie auf den Reiter <code>Application</code> in den DevTools. Klicken Sie in den DevTools unter dem Reiter <code>Application</code> im linken <code>Application</code>-Men\u00fc auf <code>Manifest</code>. Dort sehen Sie, dass Ihre Konfiguration korrekt eingelesen wird. Es sollte nur eine einzige Warnung erscheinen, dass wir (noch) keine service worker eingerichtet haben. </p> <p>Mit dem Web-Manifest ist unsere Anwendung installierbar - leider noch nicht ganz, da wir noch keinen Service worker haben und die Anwendung nicht offline verwendbar ist. Die Installierbarkeit l\u00e4sst sich aber trotzdem testen, dazu m\u00fcssen wir die Anwendung jedoch simulieren. Diese Schritte sind unter Optional - f\u00fcr Interessierte beschrieben. Sie m\u00fcssen das aber nicht machen, Sie k\u00f6nnen stattdessen auch einfach einen ganz einfachen Service worker implementieren. </p> <p>Dazu erstellen wir eine <code>public/sw.js</code> und binden diese wie folgt in die <code>public/index.html</code> ein (siehe auch Einf\u00fchrung):</p> <pre><code>&lt;script&gt;\n// Check that service workers are supported\nif ('serviceWorker' in navigator) {\n// Use the window load event to keep the page load performant\nwindow.addEventListener('load', () =&gt; {\nnavigator.serviceWorker.register('/sw.js');\n});\n}\n&lt;/script&gt;\n</code></pre> <p>und in die <code>public/sw.js</code> schreiben wir:</p> <pre><code>importScripts(\n'https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js'\n);\n\nworkbox.routing.registerRoute(\n({request}) =&gt; request.destination === 'image',\nnew workbox.strategies.NetworkFirst()     // NetworkFirst() vs CacheFirst()\n)\n</code></pre> <p>Unsere Anwendung simuliert nun eine Offline-F\u00e4higkeit und ist nun installierbar. Wenn wir die Anwendung mit <code>npm start</code> starten, dann erscheint:</p> <p></p> <p>Sie k\u00f6nnen die Anwendung \u00fcber das Icon installieren oder auch \u00fcber das Options-Men\u00fc (die drei vertikalen Punkte neben der URL-Leiste). Es erscheint ein Confirmation-Men\u00fc:</p> <p></p> <p>Nach der Installation der App ist diese (unter Mac) einerseits unter <code>Programme/Chrome-Apps</code>zu finden, aber z.B. auch im Launchpad. </p>"},{"location":"manifest/#das-beforeinstallprompt-ereignis","title":"Das <code>beforeinstallprompt</code>-Ereignis","text":"<p>Das BeforeInstallPromptEvent wird ausgel\u00f6st, wenn Ihre Anwendung installierbar ist und Sie diese das erste Mal ausf\u00fchren. Es wird ausgel\u00f6st, um Ihre Anwendung zu installieren. Ein typisches Vorgehen f\u00fcr die Behandlung des Ereignisses schl\u00e4gt vor, die Anwendung nicht sofort, d.h. nicht durch die Behandlung des <code>beforeinstallprompt</code>-Ereignisses, zu installieren, sondern zun\u00e4chst abzuwarten, ob die Anwendung auch tats\u00e4chlich so genutzt wird, dass sich eine Installation lohnt. </p> <p>F\u00fcr unsere Anwendung k\u00f6nnte das z.B. bedeuten, dass diese nicht beim ersten Aufruf installiert wird, sondern dass gewartet wird, bis die Nutzerin zum ersten Mal den <code>+</code>-Button klickt.  Ein solches typisches Vorgehen ist z.B. hier beschrieben oder hier. </p> <p>Wir zeigen hier einmal die Auswertung dieses Ereignisses, indem wir das Installieren durch einen Klick auf einen Installationsbutton erledigen lassen. Wie gesagt, die Behandlung des Klick-Ereignisses dieses Installationsbuttons geh\u00f6rt eigentlich woanders hin, je nachdem, was in der Anwendung gew\u00fcnscht ist, also wann die Anwendung tats\u00e4chlich installiert werden soll. </p> <p>Wir f\u00fcgen zun\u00e4chst den Button in die <code>index.html</code> ein:</p> <pre><code>&lt;button id=\"install\" style=\"display:none;\" class=\"mdl-button mdl-js-button mdl-button--raised mdl-button--accent\"&gt;\n  Installieren\n&lt;/button&gt;\n</code></pre> <p>Au\u00dferdem f\u00fcgen wir folgendes Script in die <code>index.html</code> hinzu:</p> <pre><code>&lt;script&gt;\nconst installButton = document.getElementById('install');\nconsole.log('installButton', installButton)\nlet deferredPrompt;\n\nwindow.addEventListener('beforeinstallprompt', evt =&gt; {\nconsole.log(evt.platforms); // e.g., [\"web\", \"android\", \"windows\"]\nevt.preventDefault();\ndeferredPrompt = evt;\ninstallButton.style.display = 'block';\n})\n\ninstallButton.addEventListener('click', async () =&gt; {\nawait deferredPrompt.prompt();\nconst choiceResult = await deferredPrompt.userChoice;\nconsole.log(choiceResult.outcome);\n});\n\nwindow.addEventListener('appinstalled', () =&gt; {\ninstallButton.style.display = 'none';\n})\n\n&lt;/script&gt;\n</code></pre> <p>Der Button ist zun\u00e4chst auf <code>display:none</code> gestellt, also nicht sichtbar. Wird das <code>beforeinstallprompt</code>-Ereignis ausgel\u00f6st, wird zun\u00e4chst der \"normale\" Ablauf der Ereignisbehandlung ausgesetzt (<code>preventDefault()</code>). Stattdessen wird diese Aufforderung in <code>deferredPrompt</code> zwischengespeichert. Der Button wird auf sichtbar gesetzt (<code>style.display = 'block'</code>). Durch Klick auf den Button wird nun die Aufforderung, die in <code>deferredPrompt</code> zwischengespeichert ist, mithilfe von <code>prompt()</code> angezeigt. </p> <p>Klicken wir nun auf den Button, erscheint die Aufforderung. Entscheiden wir uns daf\u00fcr, die App zu installieren, wird diese installiert, was wiederum das Ereignis <code>appinstalled</code> aufruft. Als Ereignisnehandlung dieses Ereignisses k\u00f6nnen wir den Button wieder auf unsichtbar setzen. </p> <p>Beachten Sie, dass das <code>BeforeInstallPromptEvent</code> nicht von allen Browsern unterst\u00fctzt wird. Hier die aktuelle \u00dcbersicht aus BeforeInstallPromptEvent:</p> <p></p>"},{"location":"manifest/#optional-fur-interessierte","title":"Optional - f\u00fcr Interessierte","text":"<p>Um die Funktionsweise des Web-App-Manifestes tats\u00e4chlich zu testen, ben\u00f6tigen wir jedoch ein Smartphone (oder Tablet). Wir wollen ein solches emulieren (ein Android-Smartphone) und starten dazu Android Studio. Wenn wir Android Studio \u00f6ffnen, w\u00e4hlen wir zun\u00e4chst <code>+ Create New Project</code>. Durch die folgenden Vorschl\u00e4ge k\u00f6nnen wir einfach stets mit <code>Next</code> und dann mit <code>Finish</code> navigieren, ohne irgendetwas zu \u00e4ndern. Wir sind gar nicht am Projekt interessiert, sondern nur am <code>AVD Manager</code> (Android Virtual Device Manaager), den wir unter dem Men\u00fcpunkt <code>Tools</code> finden. </p> <p>Nach dem \u00d6ffnen des AVD-Managers haben Sie die M\u00f6glichkeit, weitere Android-Phones zur Liste Ihrer virtuellen Ger\u00e4te hinzuzuf\u00fcgen. </p> <p></p> <p>Das k\u00f6nnen Sie ruhig machen, um ger\u00e4te mit verschiedenen Aufl\u00f6sungen ausprobieren zu k\u00f6nnen. W\u00e4hlen Sie dann ein Ger\u00e4t Ihrer Wahl und klicken Sie f\u00fcr das Ger\u00e4t unter der Spalte <code>Actions</code> auf den Play-Button:</p> <p></p> <p>Das dauert dann eine ganze Weile, aber am Ende erscheint ein Smartphone auf Ihrem Bildschirm:</p> <p></p> <p>Auf diesem Android-Ger\u00e4t ist Google Chrome verf\u00fcgbar. Starten Sie Google Chrome dort durch Mausklick und geben Sie als URL <code>10.0.2.2.:8080</code> ein. Unsere Webanwendung wird ge\u00f6ffnet:</p> <p></p> <p>Klicken Sie jetzt auf die drei vertikalen Punkte neben der URL-Leiste und w\u00e4hlen Sie <code>Add to Home screen</code>:</p> <p></p> <p>Es wird uns eines unserer Icons angeboten und der unter <code>name</code> gew\u00e4hlte Name:</p> <p></p> <p>Klicken Sie <code>Add</code> und dann <code>Add automatically</code>. Das Icon erscheint auf dem Homescreen (Startbildschirm). Eventuell m\u00fcssen Sie den Browser zuvor schlie\u00dfen. Klicken Sie auf das Icon, um unsere Anwendung zu starten. Sie sehen kurz den Splashscreen mit der von uns gew\u00e4hlten Hintergrundfarbe HTW-Gr\u00fcn. </p> <p>Beachten Sie auch, dass um unsere Anwendung herum kein Browser-Fenster zu sehen ist. Sie l\u00e4uft standalone (nat\u00fcrlich im Browser, aber der ist nicht zu sehen).  Das sieht man insbesondere, wenn man sich alle ge\u00f6ffneten Anwendungen anschaut:</p> <p></p> <p>Sobald wir f\u00fcr unserer PWA auch noch einen service worker registriert haben, kommen wir nochmal hierher zur\u00fcck und werden daf\u00fcr sorgen, dass der Browser uns sogar fragt, ob wir ein Icon auf dem Startbildschirm ablegen wollen.</p>"},{"location":"manifest/#erstaz-fur-manifestjson-fur-safari","title":"Erstaz f\u00fcr <code>manifest.json</code> f\u00fcr Safari","text":"<p>Leider unterst\u00fctzt Safari (Apple) das <code>manifest.json</code> (noch) nicht, obwohl es eine Spezifikation des W3C ist. \u00dcber die Browser-Untert\u00fctzung f\u00fcr das Web-App-Manifest k\u00f6nnen Sie sich z.B. hier informieren. Die Seite enth\u00e4lt auch eine gute Zusammenfassung aller Eigenschaften des Web-App-Manifestes. Es lohnt sich auch ein Blick hierauf.</p> <p>Um f\u00fcr Safari eine \u00e4hnliche Funktionalit\u00e4t zur Verf\u00fcgung zu stellen, wie das Web-App-Manifest, m\u00fcssen in den HTML-Dateien unserer Anwendung ein paar Meta-Angaben erfolgen:</p> <pre><code>&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt;\n&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"&gt;\n&lt;meta name=\"apple-mobile-web-app-title\" content=\"HTW-Insta\"&gt;\n&lt;link rel=\"apple-touch-icon\" href=\"/src/images/icons/ios-fiw57x57.png\" sizes=\"57x57\"&gt;\n&lt;link rel=\"apple-touch-icon\" href=\"/src/images/icons/ios-fiw60x60.png\" sizes=\"60x60\"&gt;\n&lt;link rel=\"apple-touch-icon\" href=\"/src/images/icons/ios-fiw72x72.png\" sizes=\"72x72\"&gt;\n&lt;link rel=\"apple-touch-icon\" href=\"/src/images/icons/ios-fiw76x76.png\" sizes=\"76x76\"&gt;\n&lt;link rel=\"apple-touch-icon\" href=\"/src/images/icons/ios-fiw114x114.png\" sizes=\"114x114\"&gt;\n&lt;link rel=\"apple-touch-icon\" href=\"/src/images/icons/ios-fiw120x120.png\" sizes=\"120x120\"&gt;\n&lt;link rel=\"apple-touch-icon\" href=\"/src/images/icons/ios-fiw144x144.png\" sizes=\"144x144\"&gt;\n&lt;link rel=\"apple-touch-icon\" href=\"/src/images/icons/ios-fiw152x152.png\" sizes=\"152x152\"&gt;\n&lt;link rel=\"apple-touch-icon\" href=\"/src/images/icons/ios-fiw180x180.png\" sizes=\"180x180\"&gt;\n</code></pre> <p>So wirklich klar ist es allerdings nicht, inwieweit Apple tats\u00e4chlich PWAs unterst\u00fctzt und unterst\u00fctzen m\u00f6chte. Es scheint eher so, dass Apple volle Kontrolle dar\u00fcber behalten m\u00f6chte, welche Apps auf iPhones oder iOS-Tablets laufen d\u00fcrfen, n\u00e4mlich solche, die (nur) \u00fcber den App-Store verf\u00fcgbar sind. Siehe dazu z.B. hier und hier. Sollten Sie ein iPhone haben und sollte Ihre Anwendung mithilfe von <code>npm start</code> ausgef\u00fchrt sein, so k\u00f6nnen Sie allerdings mal <code>http://141.45.57.28:8080</code> in Ihren Browser im Handy eingeben. Es muss nichts weiter installiert werden. Sie k\u00f6nnen aber kein Icon auf den Startbildschirm ablegen :-(.</p> <p>Eine weitere Unterst\u00fctzung f\u00fcr iOS Safari bietet PWACompat. Sie m\u00fcssten dann entweder in die <code>index.html</code> unterhalb des Einbindens der <code>manifest.json</code> noch </p> <pre><code>&lt;script async src=\"https://unpkg.com/pwacompat\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;\n</code></pre> <p>statisch hinzuf\u00fcgen oder dynamisch f\u00fcr den folgenden Fall:</p> <pre><code>&lt;script type=\"module\"&gt;\n// detect iOS Safari\nif (('standalone' in navigator) &amp;&amp; (!navigator.standalone)) {\nimport('https://unpkg.com/pwacompat');\n}\n&lt;/script&gt;\n</code></pre> <p>Success</p> <p>Wir haben unsere Webanwendung installierbar gemacht. Zumindest auf Android-Ger\u00e4ten. Dies geschieht mithilfe der Datei <code>manifest.json</code>, die wir in alle <code>html</code>-Seiten unserer Anwendung einbinden. Wir haben viele Eigenschaften kennengelernt, die wir in diesem Web-App-Manifest definieren k\u00f6nnen. Mithilfe des Emulators von Android Studio k\u00f6nnen wir die Anwendung des Web-App-Manifestes auf Android-Ger\u00e4ten ausprobieren. Wir schauen uns nun einen weiteren zentralen Funktionsblock an, n\u00e4mlich Service Worker. </p>"},{"location":"openapi/","title":"OpenAPI","text":"<p>Folgende Endpunkte:</p> <ul> <li><code>GET /posts</code>  (lade alle Posts)</li> <li><code>GET /posts/:id</code>  (lade einen Post mit der entsprechenden <code>id</code>)</li> <li><code>POST /posts</code> (erstelle einen neuen Post)</li> <li><code>PUT /posts/:id</code> (\u00e4ndere den Post mit der entsprechenden <code>id</code>)</li> <li><code>DELETE /posts/:id</code> ( l\u00f6sche den Post mit der entsprechenden <code>id</code>)</li> </ul> <p>Unser Datenmodell ( Typ <code>Post</code>) soll zun\u00e4chst so aussehen:</p> <pre><code>    title: String,\nlocation: String,\nimage_id: String\n</code></pre> <ul> <li>\u00f6ffne https://app.swaggerhub.com/home</li> <li>registrieren und einloggen</li> <li><code>Create New</code></li> </ul> <p> </p> Eingabemaske f\u00fcr neue REST-API <p>Es wird automatisch erstellt:</p> Simple Inventory API <pre><code>openapi: 3.0.0\nservers:\n# Added by API Auto Mocking Plugin\n- description: SwaggerHub API Auto Mocking\nurl: https://virtserver.swaggerhub.com/jfreiheit/Posts-API/1.0.0\ninfo:\ndescription: This is a simple API\nversion: \"1.0.0\"\ntitle: Simple Inventory API\ncontact:\nemail: you@your-company.com\nlicense:\nname: Apache 2.0\nurl: 'http://www.apache.org/licenses/LICENSE-2.0.html'\ntags:\n- name: admins\ndescription: Secured Admin-only calls\n- name: developers\ndescription: Operations available to regular developers\npaths:\n/inventory:\nget:\ntags:\n- developers\nsummary: searches inventory\noperationId: searchInventory\ndescription: |\nBy passing in the appropriate options, you can search for\navailable inventory in the system\nparameters:\n- in: query\nname: searchString\ndescription: pass an optional search string for looking up inventory\nrequired: false\nschema:\ntype: string\n- in: query\nname: skip\ndescription: number of records to skip for pagination\nschema:\ntype: integer\nformat: int32\nminimum: 0\n- in: query\nname: limit\ndescription: maximum number of records to return\nschema:\ntype: integer\nformat: int32\nminimum: 0\nmaximum: 50\nresponses:\n'200':\ndescription: search results matching criteria\ncontent:\napplication/json:\nschema:\ntype: array\nitems:\n$ref: '#/components/schemas/InventoryItem'\n'400':\ndescription: bad input parameter\npost:\ntags:\n- admins\nsummary: adds an inventory item\noperationId: addInventory\ndescription: Adds an item to the system\nresponses:\n'201':\ndescription: item created\n'400':\ndescription: 'invalid input, object invalid'\n'409':\ndescription: an existing item already exists\nrequestBody:\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/InventoryItem'\ndescription: Inventory item to add\ncomponents:\nschemas:\nInventoryItem:\ntype: object\nrequired:\n- id\n- name\n- manufacturer\n- releaseDate\nproperties:\nid:\ntype: string\nformat: uuid\nexample: d290f1ee-6c54-4b01-90e6-d701748f0851\nname:\ntype: string\nexample: Widget Adapter\nreleaseDate:\ntype: string\nformat: date-time\nexample: '2016-08-29T09:12:33.001Z'\nmanufacturer:\n$ref: '#/components/schemas/Manufacturer'\nManufacturer:\nrequired:\n- name\nproperties:\nname:\ntype: string\nexample: ACME Corporation\nhomePage:\ntype: string\nformat: url\nexample: 'https://www.acme-corp.com'\nphone:\ntype: string\nexample: 408-867-5309\ntype: object\n</code></pre> <p>Zur Erl\u00e4uterung:</p> <ul> <li>Unter dem Schl\u00fcssel <code>paths</code> (Zeile <code>20</code>) ist ein Pfad (eine Route) definiert, n\u00e4mlich <code>/inventory</code>. Bei diesem Pfad handelt es sich um ein sogenanntes Path Item Object</li> <li> <p>Der Pfad <code>/inventory</code> enth\u00e4lt zwei sogenannte Operation Objects, n\u00e4mlich <code>GET</code> (Zeile <code>22</code>) und <code>POST</code> (Zeile <code>63</code>). Ein Operation Object kann verschiedene Eigenschaften beinhalten:</p> <ul> <li><code>tags</code>: Schl\u00fcsselw\u00f6rter, um die API-Dokumentation zu gruppieren (siehe unten im Bild <code>Dokumentation der REST-API</code> die Gruppen <code>admins</code> und <code>developers</code>)</li> <li><code>summary</code>: dient der Erl\u00e4uterung eines Endpunktes (siehe unten im Bild <code>Dokumentation der REST-API</code> die Erl\u00e4uterungen <code>searches inventory</code> und <code>adds an inventory item</code>)</li> <li><code>description</code>: beschreibt die Funktionalit\u00e4t des Endpunktes detaillierter. Erscheint in der Dokumentation bei den Details eines Endpunktes (siehe unten im Bild <code>Get /inventroy-Endpunkt im Detail</code>)</li> <li><code>responses</code>: beschreibt die R\u00fcckgabe des Endpunktes. Es handelt sich um ein Responses Object. Diese k\u00f6nnen nach HTTP-Statuscodes unterteilt werden. Neben der <code>description</code> f\u00fcr den Statuscode kann dabei insbesondere der Typ der <code>responses</code> definiert werden. In der <code>content</code>-Eigenschaft wird zun\u00e4chst der Typ der akzeptierten Response definiert, z.B. <code>application/json</code> oder <code>image/png</code>. Dann wird spezifiziert, welcher Datentyp zur\u00fcckgeben wird. Die Zeilen <code>57-60</code> beschrieben bspw., dass ein Array von <code>InventoryItems</code> zur\u00fcckgegeben wird. Ein solches <code>InventoryItem</code> ist unter der Eigenschaft <code>schemas</code> definiert. Mithilfe von <code>$ref: '#/components/schemas/InventoryItem'</code> wird auf dieses Schema referenziert. </li> <li>Unter dem Schl\u00fcssel <code>components</code> k\u00f6nnen <code>schemas</code>, <code>responses</code>, <code>parameters</code>, <code>examples</code>, <code>requestBodies</code>, <code>headers</code> usw. spezifiziert werden. Mithilfe von <code>$ref</code> kann dann auf jede dieser Komponenten referenziert werden. In obigem Beispiel wurde das Schema <code>InventoryItem</code> und das Schema <code>Manufacturer</code> definiert. Diese Schemen entsprechen den verwendeten Datenmodellen. </li> </ul> </li> </ul> <p> </p> Dokumentation der REST-API <p> </p> GET /inventory-Endpunkt im Detail"},{"location":"openapi/#yaml","title":"YAML","text":"<p>Die obige Beschreibung ist \u00fcbrigens in YAML. Urspr\u00fcnglich stand YAML f\u00fcr Yet Anaother Markup Language. Jetzt sagt die Spezifikation von YAML aber YAML Ain't Markup Language. Es hat \u00c4hnlichkeiten zu JSON, kommt allerdings ohne Klammerung aus. Daf\u00fcr spielt das Einr\u00fccken eine Rolle. OpenAPI unterst\u00fctzt sowohl JSON als auch YAML. </p>"},{"location":"openapi/#die-posts-routen","title":"Die '/posts'-Routen","text":"<p>Wir spezifizieren zun\u00e4chst die <code>/posts</code>-Routen, also <code>GET /posts</code> und <code>POST /posts</code>.</p> Posts-API <pre><code>openapi: 3.0.0\nservers:\n# Added by API Auto Mocking Plugin\n- description: SwaggerHub Server\nurl: https://virtserver.swaggerhub.com/jfreiheit/Posts-API/1.0.0\ninfo:\ndescription: REST-API f\u00fcr IKT-PWA HTWInsta\nversion: \"1.0.0\"\ntitle: Posts-API\ncontact:\nemail: freiheit@htw-berlin.de\nlicense:\nname: Apache 2.0\nurl: 'http://www.apache.org/licenses/LICENSE-2.0.html'\ntags:\n- name: Posts\ndescription: CRUD f\u00fcr Posts\n- name: Images\ndescription: CRUD f\u00fcr Bilder\npaths:\n/posts:\nget:\ntags:\n- Posts\nsummary: lese alle Posts\noperationId: getAllPosts\ndescription: download Array aller verf\u00fcgbaren Posts\nresponses:\n'200':\ndescription: alle verf\u00fcgbaren Posts geladen\ncontent:\napplication/json:\nschema:\ntype: array\nitems:\n$ref: '#/components/schemas/Post'\npost:\ntags:\n- Posts\nsummary: f\u00fcge einen neuen Post hinzu\noperationId: createNewPost\ndescription: neuen Post erzeugen und speichern\nresponses:\n'201':\ndescription: Post created\n'409':\ndescription: Post existiert bereits\nrequestBody:\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/Post'\ndescription: neuer Post\ncomponents:\nschemas:\nPost:\ntype: object\nrequired:\n- title\n- location\n- image_id\nproperties:\ntitle:\ntype: string\nexample: H-Geb\u00e4ude\nlocation:\ntype: string\nexample: Campus Wilhelminenhof\nimage_id:\ntype: string\nexample: Campus Wilhelminenhof\n</code></pre>"},{"location":"openapi/#die-postsid-routen","title":"Die '/posts/{id}'-Routen","text":"<p>Nun f\u00fcgen wir noch die <code>/posts/{id}</code>-Routen hinzu, also <code>GET /posts/{id}</code>, <code>PUT /posts/{id}</code> und <code>DELETE /posts/{id}</code>.</p> Posts-API <pre><code>  /posts/{id}:\nget:\ntags:\n- Posts\nsummary: lese einen Post mit der passenden id\noperationId: getOnePost\ndescription: download entsprechenden Post\nparameters:\n- name: id\nin: path\nrequired: true\ndescription: Post-ID\nschema:\ntype : string\nresponses:\n'200':\ndescription: Post mit entsprechender id geladen\ncontent:\napplication/json:\nschema:\ntype: object\nitems:\n$ref: '#/components/schemas/Post'\n'404':\ndescription: Post bzw. id nicht gefunden\nput:\ntags:\n- Posts\nsummary: \u00e4ndere einen Post mit der passenden id\noperationId: updateOnePost\ndescription: aktualisiere entsprechenden Post\nparameters:\n- name: id\nin: path\nrequired: true\ndescription: Post-ID\nschema:\ntype : string\nresponses:\n'200':\ndescription: Post mit entsprechender id aktualisiert\ncontent:\napplication/json:\nschema:\ntype: object\nitems:\n$ref: '#/components/schemas/Post'\n'404':\ndescription: Post bzw. id nicht gefunden\nrequestBody:\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/Post'\ndescription: zu aktualisierender Post\ndelete:\ntags:\n- Posts\nsummary: l\u00f6sche einen Post mit der passenden id\noperationId: deleteOnePost\ndescription: l\u00f6sche entsprechenden Post\nparameters:\n- name: id\nin: path\nrequired: true\ndescription: Post-ID\nschema:\ntype : string\nresponses:\n'200':\ndescription: Post mit entsprechender id gel\u00f6scht\ncontent:\napplication/json:\nschema:\ntype: object\nitems:\n$ref: '#/components/schemas/Post'\n'404':\ndescription: Post bzw. id nicht gefunden\n</code></pre>"},{"location":"openapi/#codegenerierung","title":"Codegenerierung","text":"Dokumentation der REST-API GET /inventory-Endpunkt im Detail"},{"location":"promises/","title":"Promises und die Fetch-API","text":"<p>Wir haben es bereits eingangs des Abschnitts \u00fcber Service Workers angesprochen: JavaScript ist sinhle threaded, d.h. JavaScript l\u00e4uft auf einem einzelnen Thread. Das bedeutet im Prinzip, dass drei Funktionen <code>functionA()</code>, <code>functionB()</code>, <code>functionC()</code> nacheinander auf dem einzelnen Thread ausgef\u00fchrt werden w\u00fcrden, wenn sie nacheinander aufgerufen werden:</p> <p></p> <p>Das zieht nat\u00fcrlich nach sich, dass sich diese Funktionen in ihrer Ausf\u00fchrung blockieren. Wenn also <code>functionB()</code>bspw. sehr lange braucht, um ausgef\u00fchrt werden zu k\u00f6nnen, dann blockiert diese Funktion die Ausf\u00fchrung von <code>functionC()</code>. Um dies zu vermeiden, wurden in JavaScript sogenannte Callbacks eingef\u00fchrt. </p>"},{"location":"promises/#callbacks","title":"Callbacks","text":"<p>Zun\u00e4chst einmal sind Callbacks Funktionen, die anderen Funktionen als Parameter \u00fcbergeben werden. Wir betrachten folgendes Beispiel:</p> <pre><code>let x = function () {\nconsole.log (\"Ausgabe der Funktion x\");\n}\n\nlet y = function () {\nconsole.log (\"Ausgabe der Funktion y\");\n}\n\nlet z = function (callback) {\nconsole.log(\"Ausgabe der Funktion z - vor Aufruf von callback\");\ncallback();\nconsole.log(\"Ausgabe der Funktion z - vor Aufruf von callback\");\n}\n</code></pre> <p>Wir haben drei Funktionen. Diese werden als anonyme Funktionen definiert, aber die Funktionsdefinitionen werden sofort einer Variablen zugewiesen. Das bedeutet, dass z.B. der Wert der Variablen <code>x</code> die Funktionsdefinition  <pre><code>function () {\nconsole.log (\"Ausgabe der Funktion x\");\n}\n</code></pre> ist. Wenn wir nun z.B. <code>console.log(x)</code> aufrufen, dann erhalten wir folgende Ausgabe auf der Konsole: <pre><code>\u0192 () {\nconsole.log (\"Ausgabe der Funktion x\");\n}\n</code></pre> Wenn wir aber <code>x();</code>, also sozusagen, die Variable als Funktion aufrufen, dann wird die Funktion ausgef\u00fchrt und wir erhalten auf der Konsole die Ausgabe <pre><code>Ausgabe der Funktion x\n</code></pre></p> <p>Wenn wir nun <code>z(x);</code> aufrufen, dann wird die in den Zeilen <code>9-12</code> definierte Funktion aufgerufen, wobei der Parameter <code>callback</code> als Wert die Funktionsdefinition von <code>x</code> \u00fcbergeben wird. In Zeile <code>11</code> erfolgt dann mithilfe von <code>callback();</code> eigentlich der Aufruf <code>x();</code>. </p> <p>Wir k\u00f6nnen aber auch z.B. <code>z(y);</code> aufrufen. Dann wird <code>z</code> nicht die Funktion <code>x</code>, sondern die Funktion <code>y</code> \u00fcbergeben und der Aufruf <code>callback();</code> in Zeile <code>11</code> entspricht somit dem Aufruf <code>y();</code>. </p> <p>Ein gro\u00dfer Vorteil dieser Callbacks  bestehen darin, dass der Aufruf asynchron erfolgt. Schauen wir uns z.B. einmal an, wie die m\u00f6gliche Ausgabe der Aufrufe  <pre><code>z(x);\nz(y);\n</code></pre> aussehen k\u00f6nnte: <pre><code>Ausgabe der Funktion z - vor Aufruf von callback\nAusgabe der Funktion x\nAusgabe der Funktion z - vor Aufruf von callback\nAusgabe der Funktion z - vor Aufruf von callback\nAusgabe der Funktion y\nAusgabe der Funktion z - vor Aufruf von callback\n</code></pre></p> <p>Wichtig ist, dass Callbacks die aufrufende Funktion nicht blockieren, sondern asynchron ausgef\u00fchrt werden. Dieses einfache Beispiel soll das demonstrieren: <pre><code>setTimeout( function() {\nconsole.log('Ausgabe A');\n}, 3000);\n\nconsole.log('Ausgabe B');\n</code></pre> Wir haben zwei Anweisungen: eine <code>setTimeout()</code>-Anweisung und eine <code>console.log('Ausgabe B');</code>-Anweisung, die nacheinander aufgerufen werden (<code>setTimeout()</code> vor <code>console.log()</code>). Innerhalb der <code>setTimeout()</code>-Anweisung wird eine Funktion als Callback \u00fcbergeben. Innerhalb dieser Funktion erfolgt der Aufruf von <code>console.log('Ausgabe A');</code>.</p> <p>Das Ausf\u00fchren des Programms ergibt folgende Ausgabe: <pre><code>Ausgabe B\nAusgabe A\n</code></pre></p> <p>Die Ausgabe von <code>Ausgabe A</code> erfolgt ca. 3 Sekunden nach <code>Ausgabe B</code>. Das liegt daran, dass die Callback-Funktion asynchron ausgef\u00fchrt wird und alle weiteren Ausf\u00fchrungen nicht blockiert. Das bedeutet, dass wir mithilfe von Callbacks eine asynchrone Ausf\u00fchrung unseres JavaScript-Codes erreichen. Der einzelne JavaScript-Thread wird also f\u00fcr den Aufruf der Callbacks verwendet und irgendwann sind diese Callback-Aufrufe beendet. Ein gegenseitiges Blockieren findet nicht statt, sondern es bleibt sogar noch Platz f\u00fcr weitere Aufrufe (hellgr\u00fcne Bereiche im folgenden Bild):</p> <p></p> <p>Das problem mit diesen Callback ist, dass sie sehr schnell sehr un\u00fcbersichtlich werden. Man spricht von der Callback-H\u00f6lle, in der man sehr schnell ist, sobald gen\u00fcgend viele Callbacks asynchron (nebenl\u00e4ufig) ausgef\u00fchrt werden, diese sogar ineinander verschachtelt sind (Callbacks in Callbacks) und man gar nicht wei\u00df, wann welche Callbacks beendet sind. Sobald man aber erst die Ausf\u00fchrung eines Callbacks abwarten muss, weil man die Resultate dieses Callbacks weiterverarbeiten m\u00f6chte, entstehen wieder synchrone Aufrufe und der Vorteil der asynchronen Abarbeitung ist dahin. Um dieses Problem zu l\u00f6sen, wurden Promises entwickelt. </p>"},{"location":"promises/#promises","title":"Promises","text":"<p>Ein Promise ist zun\u00e4chst einmal ein JavaScript-Objekt. Es enth\u00e4lt einerseits den Code zum Erzeugen eines Promise-Objektes (producing code) und anderseits auch den Code zum Verarbeiten eines solchen Promise-Objektes (consuming code). Dabei k\u00f6nnen zwei Sachen verarbeitet werden:</p> <ul> <li>entweder das <code>Promise</code>-Objekt wurde erfolgreich abgearbeitet (<code>resolve</code>) oder</li> <li>das <code>Promise</code>-Objekt wurde nicht erfolgreich abgearbeitet (<code>reject</code>). </li> </ul> <p>Die allgemeine Syntax eines solchen <code>Promise</code>-Objektes sieht so aus (siehe z.B. w3scool):</p> <pre><code>let myPromise = new Promise(function(myResolve, myReject) {\n// \"Producing Code\" (May take some time)\n\nmyResolve(); // when successful\nmyReject();  // when error\n});\n\n// \"Consuming Code\" (Must wait for a fulfilled Promise)\nmyPromise.then(\nfunction(value) { /* code if successful */ },\nfunction(error) { /* code if some error */ }\n);\n</code></pre> <p>Betrachten wir das obere Beispiel genauer:</p> <ul> <li>in Zeile <code>1</code> erstellen wir eine Variable <code>myPromise</code>, die wir nat\u00fcrlich nennen k\u00f6nnen, wie wir m\u00f6chten</li> <li>diese Variable zeigt auf ein <code>Promise</code>-Objekt, das ebenfalls in Zeile <code>1</code> mithilfe von <code>new</code> und dem Aufruf des Konstruktors erzeugt wird</li> <li>einem <code>Promise</code>-Objekt (dem Konstruktor) wird immer eine Funktion \u00fcbergeben, der wiederum zwei Callback-Funktionen als Parameter \u00fcbergeben werden</li> <li>die erste Callback-Funktion, die hier <code>myResolve</code> hei\u00dft (aber meistens nur <code>resolve</code>), wird aufgerufen, wenn das <code>Promise</code>-Objekt erfolgreich abgearbeitet wurde (Zeile <code>4</code>)</li> <li>die zweite Callback-Funktion, die hier <code>myReject</code> hei\u00dft (aber meistens nur <code>reject</code>), wird aufgerufen, wenn das <code>Promise</code>-Objekt nicht erfolgreich abgearbeitet wurde (Zeile <code>5</code>)</li> <li> <p>den Aufruf des <code>promise</code>-Objektes sehen wir in Zeile <code>9</code>. Ein <code>Promise</code>-Objekt durchl\u00e4uft durch den Aufruf 2 der folgenden 3 Zust\u00e4nde:</p> <ul> <li><code>pending</code>: das <code>Promise</code>-Objekt wird abgearbeitet und hat noch kein Resultat (<code>undefined</code>),</li> <li><code>fulfilled</code>: das <code>Promise</code>-Objekt wurde erfolgreich abgearbeitet und liefert den entsprechenden Resultatwert zur\u00fcck oder</li> <li><code>rejected</code>: das <code>Promise</code>-Objekt wurde nicht erfolgreich abgearbeitet und liefert ein <code>Error</code>-Objekt zur\u00fcck</li> </ul> </li> <li> <p>es gibt aber keine M\u00f6glichkeiten, auf diese Zust\u00e4nde eines <code>Promise</code>-Objektes zuzugreifen und auch nicht direkt auf den Resultatwert oder das Fehlerobjekt; stattdessen muss eine entsprechende Funktion des <code>Promise</code>-Objektes aufgerufen werden, die selbst wieder ein <code>Promise</code>-Objekt zur\u00fcckgibt, n\u00e4mlich <code>then()</code></p> </li> <li>der Aufruf von <code>then()</code> ist ebenfalls in Zeile <code>9</code> gezeigt; diese Funktion hat zwei Parameter: dem ersten Parameter wird der Resultatwert \u00fcbergeben (wenn das <code>Promise</code>-Objekt den <code>fulfilled</code>-Zustand erreicht hat) und dem zweiten Parameter wird das Fehlerobjekt \u00fcbergeben (wenn das <code>Promise</code>-Objekt den <code>rejected</code>-Zustand erreicht hat). Beide Parameter sind wiederum Callbacks.</li> </ul> <p>Wir werden sehen, dass wir den <code>rejected</code>-Zustand auch mit <code>catch()</code> abfangen k\u00f6nnen, aber dazu kommen wir sp\u00e4ter. Zun\u00e4chst noch einmal zur Vertiefung unser obiges Callback-Beispiel mit <code>setTimeout()</code> als Promise:</p> <pre><code>let promise = new Promise(function(resolve, reject) {\nsetTimeout( function() {\nresolve('resolve -- Ausgabe A');\n}, 3000);\n});\n\npromise.then(\nfunction(value) {\nconsole.log(value);\n}\n// (noch) keine Funktion f\u00fcr error\n);\n\nconsole.log('Ausgabe B');\n</code></pre> <p>Die Ausgabe in Zeile <code>14</code> hat nichts mit dem <code>Promise</code> zu tun, aber wir lassen sie mal im Code, um das gleiche Beispiel wie oben zu haben. Es erfolgt zun\u00e4chst die Ausgabe <code>Ausgabe B</code> auf der Konsole und 3 Sekunden sp\u00e4ter die Ausgabe <code>resolve -- Ausgabe A</code>. Rein funktional hat sich also nichts ge\u00e4ndert. Wie Sie den Parameter f\u00fcr den <code>resolve</code>-Fall (und dann auch f\u00fcr den <code>reject</code>-Fall) nennen, bleibt ganz Ihnen \u00fcberlassen; hier <code>value</code> (Zeile <code>8</code>).</p> <p>Dieses Mal hei\u00dft unser <code>Promise</code>-Objekt <code>promise</code> und die beiden Callback -Funktionen <code>resolve</code> und <code>reject</code> (Zeile <code>1</code>). Der producing code  enth\u00e4lt nur die Implementierung von <code>resolve</code>. In dem Beispiel gibt es also (noch) kein <code>reject</code>. In den Zeilen <code>7</code>-<code>12</code> sehen wir den consuming code der Promise, auch hier wieder nur f\u00fcr <code>resolve</code>. Es erfolgt die Ausgabe des Wertes, den <code>resolve</code> \u00fcbergeben hat. </p>"},{"location":"promises/#promises-in-arrow-notation","title":"Promises in Arrow-Notation","text":"<p>Weil wir es mitlerweile h\u00e4ufig sehen und weil wir uns auch angew\u00f6hnen wollen, diese selbst zu benutzen, hier das gleiche Beispiel nochmal in Arrow-Notation:</p> <pre><code>let promise = new Promise((resolve, reject) =&gt; {\nsetTimeout( () =&gt; {\nresolve('resolve -- Ausgabe A');\n}, 3000);\n});\n\npromise.then(\nvalue =&gt; {\nconsole.log(value);\n}\n// (noch) keine Funktion f\u00fcr error\n);\n\nconsole.log('Ausgabe B');\n</code></pre> <p>Es ist auch noch zu erw\u00e4hnen, dass Sie nur selten selbst Promises erstellen, sondern diese viel h\u00e4ufiger nutzen werden. Das hei\u00dft, Sie werden nicht so h\u00e4ufig producing code, sondern viel h\u00e4ufiger consuming code schreiben. Beispielsweise gibt die Registrierung eines service workers ein Promise zur\u00fcck:</p> <pre><code>// scope defaults to the path the script sits in\n// \"/\" in this example\nnavigator.serviceWorker.register(\"/serviceworker.js\").then(registration =&gt; {\nconsole.log(\"success!\");\nif (registration.installing) {\nregistration.installing.postMessage(\"Howdy from your installing page.\");\n}\n}, err =&gt; {\nconsole.error(\"Installing the worker failed!\", err);\n});\n</code></pre> <p>Ein gro\u00dfer Vorteil von Promises ist, dass Sie die Verarbeitung verketten k\u00f6nnen. Die <code>then()</code>-Funktion liefert selbst wieder ein <code>Promise</code> zur\u00fcck, so dass Sie erneut dieses <code>Promise</code> mit <code>then()</code> behandeln k\u00f6nnen. Wir kommen darauf in den Anwendungen nochmal zur\u00fcck. </p>"},{"location":"promises/#der-reject-fall","title":"Der <code>reject</code>-Fall","text":"<p>Wir schauen uns jetzt an, wie wir den Fall am besten behandeln, wenn das <code>Promise</code> nicht in den <code>fulfilled</code>, sondern in den <code>rejected</code>-Zustand \u00fcbergeht, wenn also nicht <code>resolve</code>, sondern <code>reject</code> ausgef\u00fchrt wird. Wir \u00e4ndern unser Beispiel einmal entsprechend:</p> <pre><code>let promise = new Promise((resolve, reject) =&gt; {\nsetTimeout( () =&gt; {\n// resolve('resolve -- Ausgabe A');\nreject({code: 500, message: 'An error occurred'});\n}, 3000);\n});\n\npromise.then(\nvalue =&gt; {\nconsole.log(value);\n}\n// (noch) keine Funktion f\u00fcr error\n);\n\nconsole.log('Ausgabe B');\n</code></pre> <p>Wir haben also Zeile <code>3</code> auskommentiert (<code>resolve</code>) und stattdessen <code>reject</code> eingef\u00fcgt (Zeile <code>4</code>). Im Gegensatz zu <code>resolve</code> geben wir jetzt mal keinen einfachen <code>string</code>, sondern ein JavaScript-Objekt zur\u00fcck (erkennbar an <code>{ }</code>). Wir sind darin v\u00f6llig frei, was zur\u00fcckgegeben wird, aber es bietet sich an, ein Error-Objekt zu erzeugen. Die <code>then()</code>-Behandlung des <code>Promise</code>-Objekt lassen wir zun\u00e4chst unver\u00e4ndert (Zeilen <code>8-13</code>). </p> <p>Wenn wir diesen Code ausf\u00fchren, dann wird erneut <code>Ausgabe B</code> ausgegeben (Zeile <code>15</code> - hat nichts mit dem <code>Promise</code> zu tun), aber nach 3 Sekunden erfolgt keine Ausgabe auf der Konsole, sondern stattdessen erscheint auf der Konsole: </p>"},{"location":"promises/#error-behandlung-in-der-then-funktion","title":"Error-Behandlung in der <code>then()</code>-Funktion","text":"<p>Wir behandeln den geworfenen Fehler nicht, da wir in unserer <code>then()</code>-Behandlung bis jetzt nur den <code>resolve</code>-Fall behandeln (Zeilen <code>9-11</code>). Das \u00e4ndern wir nun:</p> <pre><code>let promise = new Promise((resolve, reject) =&gt; {\nsetTimeout( () =&gt; {\n// resolve('resolve -- Ausgabe A');\nreject({code: 500, message: 'An error occurred'});\n}, 3000);\n});\n\npromise.then(\nvalue =&gt; {\nconsole.log(value);\n},\nerr =&gt; {\nconsole.log(err.code, err.message);\n}\n);\n\nconsole.log('Ausgabe B');\n</code></pre> <p>In den Zeilen <code>12-14</code> wurde die Behandlung des Fehlerfalls hinzugef\u00fcgt (beachten Sie auch das zus\u00e4tzliche Komma in Zeile <code>11</code>). Wie Sie die Variable <code>err</code> nennen, bleibt Ihnen \u00fcberlassen. Sie bekommt den Wert, den das <code>Promise</code> f\u00fcr den <code>reject</code>-Fall \u00fcbergibt, in unserem Beispiel also ein JavaScript-Objekt:</p> <pre><code>{\ncode: 500, message: 'An error occurred'\n}\n</code></pre> <p>weil wir das in Zeile <code>4</code> so definiert haben. Wir greifen also auf die Werte der Schl\u00fcssel <code>code</code> und <code>message</code> zu und lassen diese auf die Konsole ausgeben (Zeile <code>13</code>). Auf der Konsole erscheint 3 Sekunden nach der Ausgabe <code>Ausgabe B</code> die Ausgabe <code>500 An error occurred</code>. </p>"},{"location":"promises/#error-behandlung-im-catch-block","title":"Error-Behandlung im <code>catch()</code>-Block","text":"<p>Es ist ungew\u00f6hnlich, den Fehlerfall in der <code>then()</code>-Funktion zu behandeln, obwohl es, wie wir gesehen haben, m\u00f6glich ist. Stattdessen verwendet man f\u00fcr den Fehlerfall besser <code>catch()</code>:</p> <pre><code>let promise = new Promise((resolve, reject) =&gt; {\nsetTimeout( () =&gt; {\n// resolve('resolve -- Ausgabe A');\nreject({code: 500, message: 'An error occurred'});\n}, 3000);\n});\n\npromise\n.then(\nvalue =&gt; {\nconsole.log(value);\n}\n)\n.catch(\nerr =&gt; {\nconsole.log(err.code, err.message);\n}\n);\nconsole.log('Ausgabe B');\n</code></pre> <p>Mit diesen Wissen k\u00f6nnen wir jetzt auch unsere Registrierung eines service workers etwas zuverl\u00e4ssiger gestalten und f\u00fcgen dort ebenfalls einen <code>catch()</code>-Block ein, auch wenn der Fehlerfall nicht all zu h\u00e4ufig eintreffen d\u00fcrfte:</p> <pre><code>if ('serviceWorker' in navigator) {\nnavigator.serviceWorker\n.register('/sw.js')\n.then(() =&gt; {\nconsole.log('service worker registriert')\n})\n.catch(\nerr =&gt; { console.log(err); }\n);\n}\n</code></pre>"},{"location":"promises/#fetch-api","title":"Fetch API","text":"<p>Die Fetch API bietet einen bequemeren und leistungsf\u00e4higeren Ersatz f\u00fcr XMLHttpRequest. Es geht also darum, Ressourcen vom Web-Server zu holen (to fetch). Die Fetch API ist vollst\u00e4ndig auf Promises aufgebaut. Die zentrale Methode der Fetch API ist <code>fetch()</code>. Das Gute an dieser Methode ist, dass sie gloabl ist im Sinne, dass sie nicht nur von einer Webanwendung selbst, sondern auch z.B. von einem Service Worker verwendet werden kann (sie ist im WindowOrWorkerGlobalScope). Einf\u00fchrungen zu <code>fetch()</code> finden Sie z.B. hier, hier oder hier.</p>"},{"location":"promises/#get-anfragen-mit-fetch","title":"GET-Anfragen mit fetch()","text":"<p>Wir starten mit einem einfachen Beispiel und nutzen daf\u00fcr https://httpbin.org, eine Webseite, die viele REST-Endpunkte zum Ausprobieren anbietet. Nach dem \u00d6ffnen dieser Seite im Browser, k\u00f6nnen Sie z.B. mal auf <code>Request inspection</code> klicken - dort sehen wir den Endpunkt <code>/ip</code>, den wir \u00fcber ein <code>GET</code> abfragen werden:</p> <pre><code>fetch('https://httpbin.org/ip')\n.then(\nresponse =&gt; {\nconsole.log(response);\n}\n);\n</code></pre> <p>Wir rufen also einmal <code>fetch()</code> auf und \u00fcbergeben dieser Funktion den Endpunkt, von dem eine Ressource geholt werden soll. Die <code>fetch()</code>-Funktion liefert ein <code>Promise</code>-Objekt zur\u00fcck. Deshalb k\u00f6nnen wir auch direkt die <code>then()</code>-Funktion aufrufen und die <code>response</code> (ist egal, wie Sie diesen Parameter nennen) auf die Konsole ausgeben. Wenn wir diesen Code ausf\u00fchren, erscheint in der Konsole:</p> <p></p> <p>Wir bekommen also ein JavaScript-Objekt zur\u00fcck. Wirklich interessiert sind wir aber haupts\u00e4chlich an dem <code>body</code> dieses Objektes. Um darauf geeignet zuzugreifen, konvertieren wir das Objekt zun\u00e4chst in das JSON-Format mithilfe der Anweisung <code>response.json();</code>. Die <code>json()</code>-Funktion ist eine Standard-JavaScript-Funktion, welche ein JavaScript-Objekt in einen JSON umwandelt. Da <code>then()</code> selbst ein <code>Promise</code>-Objekt zur\u00fcckgibt. wollen wir darauf <code>then()</code> erneut anwenden, um das Prinzip verketteter <code>then()</code>-Funktionen (verketteter asynchroner Verarbeitungen) zu zeigen:</p> <pre><code>fetch('https://httpbin.org/ip')\n.then(\nresponse =&gt; {\nreturn response.json();\n}\n)\n.then(\ndata =&gt; {\nconsole.log(data);\n}\n);\n</code></pre> <p>In der ersten <code>then()</code>-Funktion (Zeilen <code>2-6</code>) wird also die Response der asynchronen <code>GET https://httpbin.org/ip</code>-Anfrage behandelt und darin wird diese Response in eine JSON umgewandelt (Zeile <code>4</code>). Die R\u00fcckgabe dieser <code>then()</code>-Funktion ist erneut ein <code>Promise</code>. F\u00fcr dieses <code>Promise</code> ist die zweite <code>then()</code>-Funktion (Zeilen <code>7-11</code>). Diese Funktion behandelt das asynchrone Streamen des Response-Body und dessen Umwandlung in ein JSON. Das durch dieses <code>Promise</code> zur\u00fcckgegebene <code>resolve</code> bezeichnen wir in unserem Beispiel als <code>data</code> und geben es auf die Konsole aus. Auf der Konsole erscheint die <code>IP</code>, von der die Anfrage erfolgte, z.B. </p> <pre><code>{origin: \"130.193.115.48\"}\n</code></pre> <p>Noch zwei kleine Verbesserungen am Code: wenn in der Arrow-Notation Ihre Funktion nur aus einer einzigen <code>return</code>-Anweisung besteht, dann k\u00f6nnen Sie die geschweiften Klammern Ihres Funktionsk\u00f6rpers weglassen und auch das <code>return</code>. D.h. aus</p> <p><pre><code>    response =&gt; {\nreturn response.json();\n}\n</code></pre> wird </p> <p><pre><code>    response =&gt; response.json()\n</code></pre> Auch das Semikolon entf\u00e4llt. Das gilt aber nur f\u00fcr <code>return</code>-Anweisungen, nicht z.B. wenn die Funktion nur aus einer einzigen Konsolenausgabe besteht. Au\u00dferdem sollten wir auch noch ein <code>catch()</code>-Block einf\u00fcgen, f\u00fcr den Fall, dass ein Fehler auftritt:</p> <pre><code>fetch('https://httpbin.org/ip')\n.then(\nresponse =&gt; response.json()\n)\n.then(\ndata =&gt; {\nconsole.log(data);\n}\n)\n.catch(\nerr =&gt; {\nconsole.log(err);\n}\n);\n</code></pre> <p>Den Fehlerfall k\u00f6nnen Sie ausprobieren, indem Sie einfach einen Fehler in die URL einbauen.</p>"},{"location":"promises/#post-anfragen-mit-fetch","title":"POST-Anfragen mit fetch()","text":"<p><code>POST</code>-Anfragen werden verwendet, um Daten an den Webserver zu senden. Typischerweise sind das Formulardaten, die z.B. in eine Datenbank eingef\u00fcgt werden sollen. Wenn wir also mithilfe von <code>fetch()</code> eine <code>POST</code>-Anfrage stellen wollen, dann m\u00fcssen wir zwei Dinge beachten:</p> <ul> <li>wir m\u00fcssen <code>fetch()</code> explizit mitteilen, dass die verwendete HTTP-Anfrage-Methode <code>POST</code> ist und</li> <li>wir m\u00fcssen die Daten mitschicken.</li> </ul> <p>F\u00fcr ein einfaches Beispiel verwenden wir erneut https://httpbin.org, dieses Mal aber den Endpunkt /post, der uns einfach die gesendeten Daten wieder als Response unserer Abfrage zur\u00fcckschickt, also einfach als \"Spiegel\" fungiert. Eine entsprechende <code>fetch()</code>-Anweisung k\u00f6nnte so aussehen:</p> <pre><code>fetch('https://httpbin.org/post', {\nmethod: 'POST',\nheaders: {\n'Content-Type': 'application/json',\n'Accept': 'application/json'\n},\nbody: JSON.stringify({\nmessage: 'just a POST mirror'\n})\n})\n.then(\nresponse =&gt; response.json()\n)\n.then(\ndata =&gt; {\nconsole.log(data);\n}\n)\n.catch(\nerr =&gt; {\nconsole.log(err);\n}\n);\n</code></pre> <p>Die Zeilen <code>11-23</code> sind dabei zun\u00e4chst unver\u00e4ndert geblieben und sehen genauso aus wie die Zeilen <code>2-14</code> aus dem obigen <code>GET</code>-Beispiel. Nur die Parameter in der <code>fetch()</code>-Funktion haben sich ge\u00e4ndert. Der erste Parmeter lautet nun <code>'https://httpbin.org/post'</code>, da wir die Anfrage an diese URL (diesen Endpunkt) stellen. Hinzugekommen ist ein zweiter Parameter, ein JSON:</p> <pre><code>{\nmethod: 'POST',\nheaders: {\n'Content-Type': 'application/json',\n'Accept': 'application/json'\n},\nbody: JSON.stringify({\nmessage: 'just a POST mirror'\n})\n}\n</code></pre> <p>darin legen wir zun\u00e4chst mithilfe von <code>method</code> die HTTP-Anfrage-Methode fest. Standard ist <code>GET</code>, deshalb brauchten wir das in unserem ersten Beispiel nicht zu tun. Nun geben wir <code>POST</code> an. </p> <p>Au\u00dferdem definieren wir noch Eigenschaften f\u00fcr den <code>header</code>. Wir legen mithilfe von <code>Content-Type</code> fest, welches Format unsere Daten haben, die wir \u00fcbermitteln, n\u00e4mlich <code>application/json</code>. Au\u00dferdem legen wir mithilfe von <code>Accept</code> fest, in welchem Format wir die Daten empfangen wollen, n\u00e4mlich ebenfalls im JSON-Format. Diese <code>Accept</code>-Angabe ist nicht immer notwendig. Die meisten REST-Endpunkte liefern so oder so ein JSON zur\u00fcck. Das h\u00e4ngt von der Definition der REST-API ab. </p> <p>In der <code>body</code>-Eigenschaft definieren wir die Daten, die wir \u00fcbertragen wollen. In diesem Fall im JSON-Format. <code>{ message: 'just a POST mirror' }</code> ist ein JavaScript-Objekt, das eine einzige Eigenschaft enth\u00e4lt, n\u00e4mlich <code>message</code>. Mithilfe der JavaScript-Standardfunktion <code>JSON.stringify()</code> wandeln wir dieses JavaScript-Objekt in ein JSON um. Somit wird ein JSON versendet, genau wie wir es im <code>header</code> unter <code>Content-Type</code> angegeben haben. </p> <p>F\u00fchren wir diesen Code aus, erhalten wir auf der Konsole folgende Ausgabe: </p> <p></p> <p>Man k\u00f6nnte jetzt meinen, dass der Zugriff auf das Response-JSON (<code>{message: \"just a POST mirror\"}</code>) einfach \u00fcber <code>response.data</code> oder \u00fcber <code>response.json</code> erfolgen kann. Dem ist aber nicht so, da es sich bei dem <code>body</code> der <code>response</code> um ein Objekt vom Typ ReadableStream handelt. Das ist einerseits gut, denn die Daten vom Server werden asynchron als Stream empfangen, andererseits ist der Zugriff auf die Daten recht aufwendig. Wir werden darauf nochmal intensiver eingehen, wenn wir Bilder vom Backend laden. Ansonsten k\u00f6nnen Sie sich auch schonmal hier informieren oder sich hier und hier. Aber, wie gesagt, wir kommen eh nochmal darauf zur\u00fcck. Wenn Sie sich das zur\u00fcckgelieferte JSON schonmal anschauen wollen, dann ginge das z.B. so:</p> <pre><code>fetch('https://httpbin.org/post', {\nmethod: 'POST',\nheaders: {\n'Content-Type': 'application/json',\n'Accept': 'application/json'\n},\nbody: JSON.stringify({\nmessage: 'just a POST mirror'\n})\n})\n.then(\nresponse =&gt; {\nconsole.log(response);\nreturn response;\n}\n)\n.then(\nresponse =&gt; {\nconsole.log(response.body);     // show the body, ReadableStream\nreturn response.body;\n}\n)\n.then(\nbody =&gt; {\nconst reader = body.getReader();\nreturn new ReadableStream({\nstart(controller) {\nreturn pump();\nfunction pump() {\nreturn reader.read().then(({ done, value }) =&gt; {\n// When no more data needs to be consumed, close the stream\nif (done) {\ncontroller.close();\nreturn;\n}\n// Enqueue the next data chunk into our target stream\ncontroller.enqueue(value);  // Uint8Array\nreturn pump();\n});\n}\n}\n})\n})\n.then(stream =&gt; new Response(stream))\n.then(response =&gt; response.json())  // also possible: text(), blob(), ...\n.then(response =&gt; { console.log(response.json); })\n.catch(\nerr =&gt; {\nconsole.log(err);\n}\n);\n</code></pre>"},{"location":"promises/#fetch-vs-xmlhttprequest","title":"Fetch vs. XMLHttpRequest","text":"<p>Wir haben eingangs erw\u00e4hnt, dass die Fetch API einen bequemeren und leistungsf\u00e4higeren Ersatz f\u00fcr XMLHttpRequest darstellt. Das sieht man einerseits bereits an der Code-L\u00e4nge. Das ist die Implementierung mit <code>fetch()</code>:</p> <pre><code>fetch('https://httpbin.org/ip')\n.then(\nresponse =&gt; response.json()\n)\n.then(\ndata =&gt; {\nconsole.log(data);\n}\n)\n.catch(\nerr =&gt; {\nconsole.log(err);\n}\n);\n</code></pre> <p>und das hier macht genau das Gleiche mithilfe von <code>XMLHttpRequest()</code>:</p> <pre><code>let xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://httpbin.org/ip');\nxhr.responseType = 'json';\n\nxhr.onload = function() {\nconsole.log(xhr.response);\n}\n\nxhr.onerror = function() {\nconsole.log('error');\n}\n\nxhr.send();\n</code></pre> <p>Ein ganz wesentlicher Unterschied liegt aber darin, dass bei Verwendung von <code>XMLHttpRequest()</code> deutlich mehr Sachen im Hintergrund synchron ablaufen, als bei der Fetch API. Das ist der Grund, dass wir bei der Implementierung von service workern die Fetch API verwenden m\u00fcssen und nicht auf das (alte) <code>XMLHttpRequest()</code> zugreifen k\u00f6nnen.  </p>"},{"location":"promises/#fetch-und-unser-service-worker","title":"fetch() und unser service worker","text":"<p>Alle Code-Beispiele von oben (also die Promises und die <code>fetch()</code>-Beispiele) habe ich einfach in die <code>app.js</code> unseres HTW Insta-Beispiels eingetragen und ausprobiert. Das hei\u00dft, die <code>app.js</code> sieht jetzt gerade so aus:</p> app.js <pre><code>if ('serviceWorker' in navigator) {\nnavigator.serviceWorker\n.register('/sw.js')\n.then(() =&gt; {\nconsole.log('service worker registriert')\n})\n.catch(\nerr =&gt; { console.log(err); }\n);\n}\n\nlet promise = new Promise((resolve, reject) =&gt; {\nsetTimeout( () =&gt; {\n// resolve('resolve -- Ausgabe A');\nreject({code: 500, message: 'An error occurred'});\n}, 3000);\n});\n\npromise\n.then(\nvalue =&gt; {\nconsole.log(value);\n}\n)\n.catch(\nerr =&gt; {\nconsole.log(err.code, err.message);\n}\n);\n\nconsole.log('Ausgabe B');\n\nfetch('https://httpbin.org/ip')\n.then(\nresponse =&gt; response.json()\n)\n.then(\ndata =&gt; {\nconsole.log(data);\n}\n)\n.catch(\nerr =&gt; {\nconsole.log(err);\n}\n);\n\nlet xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://httpbin.org/ip');\nxhr.responseType = 'json';\n\nxhr.onload = function() {\nconsole.log(xhr.response);\n}\n\nxhr.onerror = function() {\nconsole.log('error');\n}\n\nxhr.send();\n\nfetch('https://httpbin.org/post', {\nmethod: 'POST',\nheaders: {\n'Content-Type': 'application/json',\n'Accept': 'application/json'\n},\nbody: JSON.stringify({\nmessage: 'just a POST mirror'\n})\n})\n.then(\nresponse =&gt; {\nconsole.log(response);\nreturn response;\n}\n)\n.then(\nresponse =&gt; {\nconsole.log(response.body);\nreturn response.body;\n}\n)\n.then(\nbody =&gt; {\nconst reader = body.getReader();\nreturn new ReadableStream({\nstart(controller) {\nreturn pump();\nfunction pump() {\nreturn reader.read().then(({ done, value }) =&gt; {\n// When no more data needs to be consumed, close the stream\nif (done) {\ncontroller.close();\nreturn;\n}\n// Enqueue the next data chunk into our target stream\ncontroller.enqueue(value);\nreturn pump();\n});\n}\n}\n})\n})\n.then(stream =&gt; new Response(stream))\n.then(response =&gt; response.json())\n.then(response =&gt; { console.log(response.json); })\n.catch(\nerr =&gt; {\nconsole.log(err);\n}\n);\n</code></pre> <p>Au\u00dferdem haben wir ja in unserer Anwendung bereits einen service worker registriert und auch in schon in Ans\u00e4tzen implementiert: </p> sw.js <pre><code>self.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\n})\n\nself.addEventListener('activate', event =&gt; {\nconsole.log('service worker --&gt; activating ...', event);\nreturn self.clients.claim();\n})\n\nself.addEventListener('fetch', event =&gt; {\nconsole.log('service worker --&gt; fetching ...', event);\n})\n</code></pre> <p>Ich erw\u00e4hne das nur deshalb, weil unsere Konsole bei Ausf\u00fchrung der Anwendung jetzt ungef\u00e4hr so aussieht:</p> <p></p> <p>Es erscheint also ganz oft die Ausgabe des <code>fetch</code>-Events, genau wie in der <code>sw.js</code> in den Zeilen <code>10-12</code> implementiert. Das <code>fetch</code>-Event wird immer dann ausgel\u00f6st, wenn die Anwendung etwas vom Webserver l\u00e4dt. Das sind einerseits alle Ressourcen, die wir in der <code>index.html</code>-datei definiert haben (alle <code>*.js</code> und alle <code>*.css</code> und alle <code>*.png</code>-Dateien), aber auch die <code>fetch()</code>-Anweisungen, die wir in der <code>app.js</code> implementiert haben! Wir werden auf der Konsole auch die <code>fetch</code>-Ereignisse finden, die den Zugriff auf <code>https://httpbin.org/ip</code> bzw. <code>https://httpbin.org/post</code> ausf\u00fchren. Wir merken uns also</p> <ul> <li><code>fetch</code>-Ereignisse werden automatisch ausgel\u00f6st durch das Laden von ressourcen, so wie in den <code>*.html</code>-Dateien der Anwendung definiert, </li> <li>aber auch durch manuell ausgel\u00f6ste (implementierte) <code>fetch()</code>-Anfragen. </li> </ul> <p>Das ist wichtig, wenn wir in unserem service worker die <code>fetch</code>-Ereignisse behandeln werden. </p> <p>Success</p> <p>Wir kennen nun Promises und die Fetch API und k\u00f6nnen beides anwenden. Wir werden Promises von nun an permanent verwenden. Insbesondere den consuming code f\u00fcr Promises, als <code>.then().catch()</code>. Mithilfe der Fetch API werden wir alle HTTP-Anfragen an den Server stellen k\u00f6nnen, also <code>GET</code>, <code>POST</code>, <code>PUT</code> und <code>DELETE</code> und dabei das asynchrone Prinzip dieser API bestm\u00f6glich ausnutzen.  </p>"},{"location":"pushnotes/","title":"Push Notifications","text":"<p>Hint</p> <p>Aktueller Stand vor Push Notifications:</p> <ul> <li>Frontend</li> <li>Backend</li> <li>Collection post</li> <li>Collection post.files</li> <li>Collection post.chunks</li> </ul> <p>Push Notifications sind sinnvoll, um die Nutzerin einer App \u00fcber Neuigkeiten zu informieren, sogar dann, wenn die Anwendung (und der Browser!) geschlossen ist (sind). Mit Push Notifications k\u00f6nnen Nutzerinnen wieder \"zur\u00fcck an die App geholt\" werden, d.h. mithilfe von Push Notifications kann man daf\u00fcr sorgen, dass Nutzerinnen die App wieder \u00f6ffnen, um sich die Neuigkeiten genauer anzuschauen. Die Neuigkeiten k\u00f6nnen neue Tweets, E-Mails, Nachrichten, Anrufe usw. sein. </p> <p>Das Prinzip, das f\u00fcr die Push-Benachrichtungen umgesetzt wird, sieht auf den ersten Blick etwas kompliziert aus:</p> <p></p> <p>Im Zentrum stehen zun\u00e4chst die Webanwendung und der Service Worker. Die Webanwendung meldet sich bei den Push-Benachrichtigungen an und der Service Worker verwaltet diese. Jeder Browser hat eine eigenen \"eingebauten\" Push Server. Eine Push-Anmeldung (Push Subscription) erlaubt den Zugriff auf einen Push-API-Endpunkt auf den Push-Server. Die eigentliche Push-Benachrichtigung kommt jedoch vom eigenen Server. Er sendet die Push-Nachricht an den In-Browser Push Server, dieser l\u00f6st damit ein <code>push</code>-Ereignis beim Service Worker aus und der Service Worker schickt die Push-Benachrichtigung an die Webanwendung. Wir schauen uns im Folgenden alle diese Schritte im Detail an. </p>"},{"location":"pushnotes/#anzeigen-von-benachrichtigungen","title":"Anzeigen von Benachrichtigungen","text":"<p>Wir beginnen mit dem Anzeigen (der Darstellung) von Push-Benachrichtigungen in einer Webanwendung. Dieser Abschnitt hat noch nichts mit dem <code>push</code>-Ereignis zu tun! Wir ben\u00f6tigen zum Anzeigen nicht mal einen Service Worker. Es geht aber auch \u00fcber den Service Worker - und das wird sp\u00e4ter auch bei der Verwendung der Push-API notwendig. Die hier verwendete Notification-API wird von fast allen Browsern unterst\u00fctzt. Hier ist auch eine gute \u00dcbersicht dar\u00fcber, wie diese Notification-API verwendet wird. </p>"},{"location":"pushnotes/#benachrichtigungen-einschalten","title":"Benachrichtigungen einschalten","text":"<p>Bevor wir das Anzeigen von (Push-)Benachrichtigungen betrachten, m\u00fcssen wir diese zuerst erlauben. In unserer Anwendung gibt es dazu den Button <code>BENACHRICHTIGUNGEN EIN</code>. </p> <p></p> <p>In der <code>index.html</code> ist dieser Button zwei Mal definiert, einmal f\u00fcr einen schmalen Viewport und einmal f\u00fcr einen breiten. F\u00fcr beide Varianten sieht die Implementierung so aus: </p> <pre><code>&lt;div class=\"drawer-option\"&gt;\n        &lt;button class=\"enable-notifications mdl-button mdl-js-button mdl-button--raised mdl-button--colored mdl-color--accent\"&gt;\n            Benachrichtigungen Ein\n        &lt;/button&gt;\n&lt;/div&gt;\n</code></pre> <p>F\u00fcr einen schmalen Viewport ist der Button dann unter dem Hamburger Men\u00fc in der linken oberen Ecke erreichbar. Beiden Buttons ist die CSS-Klasse <code>enable-notifications</code> zugewiesen. Wir sorgen zuerst daf\u00fcr, dass dieser Button nur angezeigt wird, wenn der Browser die Notification-API unterst\u00fctzt. Wenn nicht, dann w\u00e4re der Button funktionslos und wir br\u00e4uchten ihn nicht. Wir schalten ihn deshalb in der <code>app.css</code> zun\u00e4chst im Standartwert aus:</p> /src/css/app.css <pre><code>.text-center {\ntext-align: center;\n}\n\n.drawer-option {\npadding: 16px;\n}\n\n.enable-notifications {\ndisplay: none;\n}\n</code></pre> <p>In der <code>app.js</code> pr\u00fcfen wir, ob der Browser die Notification-API unterst\u00fctzt und schalten f\u00fcr diesen Fall die Buttons wieder ein. </p> /src/js/app.js <pre><code>let enableNotificationsButtons = document.querySelectorAll('.enable-notifications');\nif ('serviceWorker' in navigator) {\nnavigator.serviceWorker\n.register('/sw.js')\n.then(() =&gt; {\nconsole.log('service worker registriert')\n})\n.catch(\nerr =&gt; { console.log(err); }\n);\n}\n\nfunction askForNotificationPermission() {\nNotification.requestPermission( result =&gt; {\nconsole.log('User choice', result);\nif(result !== 'granted') {\nconsole.log('No notification permission granted');\n} else {\n// notifications granted\n}\n});\n}\nif('Notification' in window) {\nfor(let button of enableNotificationsButtons) {\nbutton.style.display = 'inline-block';\nbutton.addEventListener('click', askForNotificationPermission);\n}\n}\n</code></pre> <ul> <li>In Zeile <code>1</code> erstellen wir uns eine Variable <code>enableNotificationsButtons</code>, die auf ein Array aller Buttons mit der CSS-Klasse <code>enable-notifications</code> zeigt. </li> <li>In Zeile <code>25</code> pr\u00fcfen wir nun, ob der Browser die <code>Notification</code>-API unterst\u00fctzt. Wenn ja, dann schalten wir alle Buttons aus dem <code>enableNotificationsButtons</code>-Array wieder auf sichtbar (von <code>display: none</code> auf <code>display: inline-block</code>) und wir melden jeden dieser Buttons an die Ereignisbehandlung des <code>click</code>-Ereignisses an (Zeile <code>28</code>). </li> <li>Die Behandlung des <code>click</code>-Ereignisses erfolgt in der Methode <code>askForNotificationPermission()</code>, die in den Zeilen <code>14-23</code> definiert ist. Da diese Methode nur dann aufgerufen wird, wenn der Browser die <code>Notification</code>-API unterst\u00fctzt, kann diese API darin verwendet werden. </li> <li>Mit der Funktion requestPermission() wird die Nutzerin gefragt, ob sie Benachrichtigungen zulassen m\u00f6chte. Diese Methode gibt ein Promise zur\u00fcck, dessen <code>result</code> die Werte <code>granted</code>, <code>denied</code> oder <code>default</code> haben kann. Werden Benachrichtigungen nicht erlaubt (Zeile <code>17</code>), k\u00f6nnen wir nichts weiter tun. Die Nutzerin wird dann auch nicht erneut gefragt. Die Benachrichtigungen bleiben f\u00fcr die Webanwendung ausgeschaltet (Zeile <code>18</code>). </li> </ul> <p>Wenn wir die Anwendung nun ausf\u00fchren (Reload nach <code>Application --&gt; Storage --&gt; Clear Storage</code> oder die Versionsnummern der Caches im Service Worker \u00e4ndern), dann erhalten wir nach dem Klicken auf den <code>BENACHRICHTIGUNGEN EIN</code>-Button folgende Abfrage:</p> <p></p> <p>Wenn wir auf <code>Zulassen</code> klicken, dann erscheint in der Konsole <code>User Chaice granted</code> (Zeile <code>16</code>). Beachten Sie, dass Sie nicht erneut gefragt werden, ob Benachrichtungen zugelassen werden sollen oder nicht. Erneutes Klicken auf den Button bewirkt (selbst nach einem Reload der Anwendung) keine erneute Abfrage. Deshalb w\u00e4re es eigentlich auch sinnvoll, den Button wieder zu verstecken, d.h. auf <code>display: none</code> zu setzen. </p> <p>Um die Benachrichtigungen zu verwalten, k\u00f6nnen Sie in Chrome <code>chrome://settings/content/notifications</code> eingeben. Dort sehen Sie eine Auflistung aller Webanwendungen, die Sie besucht haben und die von Ihnen eine Erlaubnis zur Benachrichtung gewollt haben. Sie k\u00f6nnen dort die jeweiligen Einstellungen wieder \u00e4nder, z.B. auch f\u00fcr die hier entwickelte Anwendung.</p> <p></p>"},{"location":"pushnotes/#benachrichtigungen-anzeigen","title":"Benachrichtigungen anzeigen","text":"<p>Jetzt erstellen wir unsere erste Benachrichtigung mithilfe der <code>Notification</code>-API. Die einfachste Form der <code>Notification</code> wird durch die Verwendung des parametrisierten Konstruktors von <code>Notification</code> (<code>new Notification('Nachricht')</code>) erstellt. Wir f\u00fcgen die <code>app.js</code> eine solche einfache Benachrichtigung f\u00fcr den Fall, dass Benachrichtigungen erlaubt werden, ein:</p> /src/js/app.js <pre><code>let enableNotificationsButtons = document.querySelectorAll('.enable-notifications');\n\nif ('serviceWorker' in navigator) {\nnavigator.serviceWorker\n.register('/sw.js')\n.then(() =&gt; {\nconsole.log('service worker registriert')\n})\n.catch(\nerr =&gt; { console.log(err); }\n);\n}\n\nfunction displayConfirmNotification() {\nnew Notification('Successfully subscribed!');\n}\nfunction askForNotificationPermission() {\nNotification.requestPermission( result =&gt; {\nconsole.log('User choice', result);\nif(result !== 'granted') {\nconsole.log('No notification permission granted');\n} else {\ndisplayConfirmNotification();\n}\n});\n}\n\nif('Notification' in window) {\nfor(let button of enableNotificationsButtons) {\nbutton.style.display = 'inline-block';\nbutton.addEventListener('click', askForNotificationPermission);\n}\n}\n</code></pre> <p>Wenn wir die Anwendung nun erneut ausf\u00fchren und auf den Button klicken, dann werden wir zwar nicht erneut gefragt, ob wir Benachrichtigungen zulassen oder blockieren wollen, aber da wir Benachrichtungen bereits zugelassen haben, erscheint nun die folgende Benachrichtigung:</p> <p></p> <p>Der einfache Aufruf des <code>Notification</code>-Konstruktors mit einer einfachen Nachricht (Zeile <code>15</code>) erzeugt auch die einfachste Form der Benachrichtigung. Dem Konstruktor lassen sich aber als zweiten Parameter noch JavaScript-Objekt f\u00fcr <code>options</code> \u00fcbergeben. Darin kann ein weiterer Text (<code>body</code>) definiert werden und z.B. auch ein eigenes <code>icon</code>. Wir betrachten das sp\u00e4ter noch etwas genauer, erstmal nur eine weitere Nachricht: </p> /src/js/app.js <pre><code>function displayConfirmNotification() {\nlet options = { body: 'You successfully subscribed to our Notification service!'};\nnew Notification('Successfully subscribed!', options);\n}\n</code></pre> <p>ergibt dann die Benachrichtigung:</p> <p></p>"},{"location":"pushnotes/#benachrichtigungen-im-service-worker-erstellen","title":"Benachrichtigungen im Service Worker erstellen","text":"<p>Im jetzigen Stand werden die Benachrichtungen aus der Webanwendung heraus erstellt. Das ist auch v\u00f6llig ok. Die <code>Notification</code>-API l\u00e4sst sich sowohl in der Webanwendung verwenden, als auch im Service Worker. Da sp\u00e4ter aber die Push-Benachrichtigungen vom Service Worker verwaltet werden, wechseln wir jetzt auch f\u00fcr die einfachen Benachrichtigungen zum Service Worker, d.h. wir lassen die Benachrichtigungen nun nicht mehr durch die Webanwendung erstellen, sondern durch den Service Worker. Dazu passen wir unsere <code>app.js</code> wie folgt an:</p> /src/js/app.js <pre><code>function displayConfirmNotification() {\nif('serviceWorker' in navigator) {\nlet options = { body: 'You successfully subscribed to our Notification service!'};\nnavigator.serviceWorker.ready\n.then( sw =&gt; {\nsw.showNotification('Successfully subscribed (from SW)!', options);\n});\n}\n}\n</code></pre> <p>Der Service Worker besitzt eine eigene Funktion <code>showNotification()</code>, die intern ein <code>Notification</code>-Objekt erzeugt und der die gleiche Parameterliste \u00fcbergeben werden kann, wie dem <code>Notification</code>-Konstruktor. Nach Reload und Klicken des Buttons sehen wir nun folgende Benachrichtigung:</p> <p></p> <p>Die Nachricht wurde extra um <code>(from SW)</code> erg\u00e4nzt, um kenntlich zu machen, dass die Benachrichtigung nun vom Service Worker angesto\u00dfen wird. </p>"},{"location":"pushnotes/#weitere-optionen-fur-die-benachrichtigungen","title":"Weitere Optionen f\u00fcr die Benachrichtigungen","text":"<p>Benachrichtigungen sind ein System-Feature, d.h. ihre Gestaltung hat etwas mit dem Ger\u00e4t zu tun, in dem diese Benachrichtigungen erscheinen. Es ist kein Browser-Feature. Benachrichtigungen sehen auf dem Mac anders aus, als unter Windows oder unter Linux und auf dem iPhone anders, als auf einem Android-Ger\u00e4t. Es gibt ziemlich viele m\u00f6gliche Optionen f\u00fcr eine solche Benachrichtigung, aber die unterschiedlichen Systeme beachten diese Optionen mal mehr und mal weniger. </p> <p>Wir werden hier der Vollst\u00e4ndigkeit halber einige Optionen benennen, aber am meisten sieht man von diesen Optionen auf einem Android-Ger\u00e4t. </p> /src/js/app.js <pre><code>function displayConfirmNotification() {\nif('serviceWorker' in navigator) {\nlet options = {\nbody: 'You successfully subscribed to our Notification service!',\nicon: '/src/images/icons/fiw96x96.png',\nimage: '/src/images/htw-sm.jpg',\nlang: 'de-DE',\nvibrate: [100, 50, 200],\nbadge: '/src/images/icons/fiw96x96.png',\ntag: 'confirm-notification',\nrenotify: true,\nactions: [\n{ action: 'confirm', title: 'Ok', icon: '/src/images/icons/fiw96x96.png' },\n{ action: 'cancel', title: 'Cancel', icon: '/src/images/icons/fiw96x96.png' },\n]\n};\n\nnavigator.serviceWorker.ready\n.then( sw =&gt; {\nsw.showNotification('Successfully subscribed (from SW)!', options);\n});\n}\n}\n</code></pre> <p>Auf dem Mac hat neben der <code>icon</code>-Option nur noch die <code>actions</code>-Option eine Auswirkung. Die Benachrichtigung sieht nun so aus (auf dem Mac):</p> <p></p> <p>Man sieht das icon und unter dem Icon wird durch das Hovern mit der Maus ein Men\u00fc sichtbar, das die definierten <code>actions</code> enth\u00e4lt. </p> <ul> <li>mit <code>image</code> kann die gesamte Benachrichtigung mit einem Bild unterlegt werden (sieht man bei Android),</li> <li>mit <code>vibrate</code> kann die Benachrichtigung durch das Vibrieren des Ger\u00e4tes signalisiert werden. In unserem Beispiel vibriert das Ger\u00e4t 100 Millisekunden, dann ist 50 Millisekunden Pause und dann vibriert es nochmal f\u00fcr 200 Millisekunden. </li> <li>mit <code>tag</code> k\u00f6nnen Benachrichtigungen mit einer Art <code>id</code> versehen werden. Wenn meherere Benachrichtigungen mit demselben <code>tag</code> vorliegen, dann wird nur die zuletzt eingegangene Benachrichtigung angezeigt. Ansonsten erscheinen alle Benachrichtigungen untereinander. </li> <li><code>renotify</code> geh\u00f6rt zu <code>tag</code>. Wenn der Wert true ist, dann wird die Nutzerin auch dann informiert, wenn eine neue Nachricht zum selben <code>tag</code> angekommen ist. Sonst nicht.</li> </ul> <p>Eine \u00dcbersicht \u00fcber alle Optionen findet sich hier.</p> <p>Wenn Sie ein Android-Ger\u00e4t besitzen, dann k\u00f6nnen Sie es an den Rechner andocken (USB-Anschluss - dazu m\u00fcssen Sie den USB-Zugriff erlauben) und in den Devloper Tools rechts oben unter den drei senkrechten Punkten den Men\u00fcpunkt <code>More tools</code> und dort <code>Remote devices</code> ausw\u00e4hlen und k\u00f6nnen dann ausprobieren, wie die Benachrichtigungen unter einem Android-Ger\u00e4t aussehen. Anleitung f\u00fcr Edge, Anleitung f\u00fcr Chrome, Anleitung f\u00fcr Firefox.</p> <p>Auf die unter <code>actions</code> definierten Aktionen kann innerhalb des Service Workers sogar reagiert werden:</p> /sw.js <pre><code>self.addEventListener('notificationclick', event =&gt; {\nlet notification = event.notification;\nlet action = event.action;\n\nconsole.log(notification);\n\nif(action === 'confirm') {\nconsole.log('confirm was chosen');\nnotification.close();\n} else {\nconsole.log(action);\n}\n});\n</code></pre> <p>Der Service Worker kann das <code>notificationclick</code>-Ereignis behandeln. Ebenso kann der Service Worker das Ereignis behandeln, das ausgel\u00f6st wird, wenn eine Benachrichtigung geschlossen wird: </p> /sw.js <pre><code>self.addEventListener('notificationclose', event =&gt; {\nconsole.log('notification was closed', event);\n});\n</code></pre> <p>Wir wollen uns aber mit den Benachrichtigungen gar nicht weiter im Detail besch\u00e4ftigen, sondern lieber mit Push-Notationen. Kenntnisse \u00fcber Benachrichtigungen sind aber eine gute Voraussetzung, um zu den Push-Notifikationen \u00fcberzugehen. </p>"},{"location":"pushnotes/#push-benachrichtigungen","title":"Push-Benachrichtigungen","text":"<p>Das Konzept der Benachrichtigung wird auch bei den Push-Nachrichten verwendet. Um Push-Nachrichten zu empfangen, muss man sich jedoch zun\u00e4chst f\u00fcr den Empfang registrieren (siehe in der Abbildung oben neue Push Subscription erstellen).  </p>"},{"location":"pushnotes/#anmelden-an-push-nachrichten-subscription","title":"Anmelden an Push-Nachrichten (Subscription)","text":"<p>Die Anmeldung an die Push-Nachrichten geschieht in der Webanwendung. Wir passen dazu unsere <code>app.js</code> an und f\u00fcgen eine Funktion <code>configurePushSubscription()</code> ein. </p> /src/js/app.js <pre><code>let enableNotificationsButtons = document.querySelectorAll('.enable-notifications');\n\nif ('serviceWorker' in navigator) {\nnavigator.serviceWorker\n.register('/sw.js')\n.then(() =&gt; {\nconsole.log('service worker registriert')\n})\n.catch(\nerr =&gt; { console.log(err); }\n);\n}\n\nfunction displayConfirmNotification() {\nif('serviceWorker' in navigator) {\nlet options = {\nbody: 'You successfully subscribed to our Notification service!',\nicon: '/src/images/icons/fiw96x96.png',\nimage: '/src/images/htw-sm.jpg',\nlang: 'de-DE',\nvibrate: [100, 50, 200],\nbadge: '/src/images/icons/fiw96x96.png',\ntag: 'confirm-notification',\nrenotify: true,\nactions: [\n{ action: 'confirm', title: 'Ok', icon: '/src/images/icons/fiw96x96.png' },\n{ action: 'cancel', title: 'Cancel', icon: '/src/images/icons/fiw96x96.png' },\n]\n};\n\nnavigator.serviceWorker.ready\n.then( sw =&gt; {\nsw.showNotification('Successfully subscribed (from SW)!', options);\n});\n}\n}\n\nfunction configurePushSubscription() {\nif(!('serviceWorker' in navigator)) {\nreturn\n}\nnavigator.serviceWorker.ready\n.then( sw =&gt; {\nreturn sw.pushManager.getSubscription();\n})\n.then( sub =&gt; {\nif(sub === null) {\n// create a new subscription\n} else {\n// already subscribed\n}\n});\n}\nfunction askForNotificationPermission() {\nNotification.requestPermission( result =&gt; {\nconsole.log('User choice', result);\nif(result !== 'granted') {\nconsole.log('No notification permission granted');\n} else {\n// displayConfirmNotification();\nconfigurePushSubscription();\n}\n});\n}\n\nif('Notification' in window &amp;&amp; 'serviceWorker' in navigator) {\nfor(let button of enableNotificationsButtons) {\nbutton.style.display = 'inline-block';\nbutton.addEventListener('click', askForNotificationPermission);\n}\n}\n</code></pre> <p>Die Methode <code>configurePushSubscription()</code> wird nun anstelle von <code>displayConfirmNotifivcation()</code> in der <code>askForNotificationPermission()</code> aufgerufen (Zeilen <code>62-63</code>). Das liegt daran, dass die <code>Notification.requestPermission()</code>-Funktion auch f\u00fcr die Erlaubnis von Push-Nachrichten verwendet wird. Mit der Erlaubnis von Benachrichtigungen wird also auch gleichzeitig die Erlaubnis von Push-Nachrichten erteilt. </p> <p>Da die Push-Benachrichtigungen \u00fcber den Service Worker verwaltet werden, wird in <code>configurePushSubscription()</code> zun\u00e4chst gepr\u00fcft, ob der Browser \u00fcberhaupt Service Worker unterst\u00fctzt (Zeile <code>39</code>). Wenn nicht, wird die Methode sofort verlassen (Zeile <code>40</code>). Da wir aber auch in die Abfrage nach der <code>Notification-API</code> (Zeile <code>68</code>) noch die Abfrage nach dem <code>serviceWorker</code> hinzugef\u00fcgt haben, w\u00e4re der Button <code>BENACHRICHTUNGEN EIN</code> gar nicht sichtbar, wenn der Service Worker nicht im Browser unterst\u00fctzt w\u00fcrde. Dann w\u00fcrde auch nie die Funktion <code>configurePushSubscription()</code> aufgerufen. Wir lassen Zeilen <code>39-41</code> trotzdem sicherheitshalber drin.</p> <p>In Zeile <code>45</code> verwendet der Service Worker die PushManager-API. Eine der drei Methoden, die diese API zur Verf\u00fcgung stellt, ist die <code>getSubscription()</code>-Methode. Diese Methode gibt eine Promise mit einer existierenden Subscription zur\u00fcck. Wenn keine Subscription existiert, ist der R\u00fcckgabewert <code>null</code>. Ist der R\u00fcckgabewert <code>null</code>, dann erzeugen wir eine neue Subscription (Zeile <code>49</code>). </p>"},{"location":"pushnotes/#erzeugen-einer-neuen-subscription","title":"Erzeugen einer neuen Subscription","text":"<p>Das Erezugen einer Subscription ist zun\u00e4chst einfach. Daf\u00fcr gibt es in der PushManager-API die Methode <code>subscribe()</code>. </p> /src/js/app.js <pre><code>function configurePushSubscription() {\nif(!('serviceWorker' in navigator)) {\nreturn\n}\n\nlet swReg;\nnavigator.serviceWorker.ready\n.then( sw =&gt; {\nswReg = sw;\nreturn sw.pushManager.getSubscription();\n})\n.then( sub =&gt; {\nif(sub === null) {\n// create a new subscription\nswReg.pushManager.subscribe();\n} else {\n// already subscribed\n}\n});\n}\n</code></pre> <p>Da wir in dem zweiten <code>then()</code>-Block keinen Zugriff mehr auf die Variable <code>sw</code> haben (wir geben die Promise von <code>getSubscription()</code> zur\u00fcck, nicht aber <code>sw</code>), ben\u00f6tigen wir eine Variable, in der wir die Referenz auf den Service Worker speichern und auf die wir in der gesamten Funktion Zugriff haben. Die Promise <code>navigator.serviceWorker.ready</code> gibt etwas mehr als den Service Worker zur\u00fcck, eine sogenannte Service Worker Registration (siehe ready und Srvice Worker Registration). Wir nennen unsere Variable deshalb <code>swReg</code> (Zeile <code>43</code>). Die <code>subscribe()</code>-Funktion wird in Zeile <code>52</code> aufgerufen. </p> <p>Wir haben nun eine neue Subscription erstellt. Eine solche Subscription enth\u00e4lt den Endpunkt (Push-API Endpunkt in der Abbildung ganz oben) des In-Browser Push Servers, an den die Push-Nachrichten gesendet werden und der f\u00fcr eine neue Push-Nachricht das <code>push</code>-Ereignis beim Service Worker ausl\u00f6st. Mit der Kenntnis des Endpunktes kann nun aber jede beliebige Anwendung eine Push-Nachricht an den In-Browser Push Server senden. Damit kann es passieren, dass Push-Nachrichten erstellt werden, die gar nicht von dem eigenen Backend kommen. Deshalb m\u00fcssen wir diese Informationen \u00fcber den Endpunkt sch\u00fctzen. </p>"},{"location":"pushnotes/#schutz-der-subscription","title":"Schutz der Subscription","text":"<p>Der <code>subscribe()</code>-Methode k\u00f6nnen Optionen (als JavaScript-Objekt) \u00fcbergeben werden, welche zwei Eigenschaften enthalten k\u00f6nnen:</p> <ul> <li><code>userVisibleOnly</code>; kann <code>true</code> oder <code>false</code> sein. Wenn <code>true</code>, dann k\u00f6nnen nur Nachrichten gesendet werden, die \"sichtbar\" f\u00fcr den User sind, d.h. es k\u00f6nnen keine Aktionen (Java-Skripte o.\u00e4.) als Nachrichten gesendet werden und</li> <li><code>applicationServerKey</code>: das ist ein Base64-ArrayBuffer, der einen Schl\u00fcssel enth\u00e4lt. Das Vorgehen daf\u00fcr ist z.B. hier, aber auch hier gut beschrieben.  </li> </ul> <p>Die Grundidee dabei ist, dass wir sicherstellen wollen, dass nur Nachrichten, die von unserem Backend kommen, von dem In-Browser Push Server an unsere Webanwendung weitergeleitet werden. Dazu m\u00fcssen wir unser Backend erweitern.</p>"},{"location":"pushnotes/#backend-erweitern","title":"Backend erweitern","text":"<p>Um unser Backend f\u00fcr das Senden von Push-Nachrichten einzurichten, ben\u00f6tigen wir das Modul web-push. Wir wechesln im Terminal in unseren Backend-Ordner und f\u00fchren dort</p> <pre><code>npm install --save web-push\n</code></pre> <p>aus. Die <code>--save</code>-Option wird seit <code>npm 5.0.0</code> nicht mehr ben\u00f6tigt. Die Abh\u00e4ngigkeiten werden auch so in der <code>package.json</code> gespeichert. In diese <code>package.json</code> des Backends f\u00fcgen wir ein weiteres <code>script</code> hinzu: </p> package.json <pre><code>{\n\"name\": \"backend\",\n\"version\": \"1.0.0\",\n\"description\": \"Backend REST-API\",\n\"main\": \"server.js\",\n\"scripts\": {\n\"watch\": \"nodemon ./server.js\",\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\",\n\"web-push\": \"web-push\"\n},\n\"keywords\": [\n\"rest\",\n\"api\",\n\"backend\",\n\"mongodb\"\n],\n\"repository\": {\n\"type\": \"git\",\n\"url\": \"https://github.com/jfreiheit/IKT-PWA-Backend.git\"\n},\n\"author\": \"J. Freiheit\",\n\"license\": \"ISC\",\n\"dependencies\": {\n\"cors\": \"^2.8.5\",\n\"dotenv\": \"^16.0.0\",\n\"express\": \"^4.18.0\",\n\"gridfs-stream\": \"^1.1.1\",\n\"mongoose\": \"^6.3.1\",\n\"multer\": \"^1.4.4\",\n\"multer-gridfs-storage\": \"^5.0.2\",\n\"web-push\": \"^3.5.0\"\n},\n\"devDependencies\": {\n\"nodemon\": \"^2.0.16\"\n}\n}\n</code></pre> <p>Das erm\u00f6glicht uns, </p> <pre><code>npm run web-push\n</code></pre> <p>auszuf\u00fchren. Das f\u00fchrt allerdings zu einem Fehler, zeigt uns aber an, welche Optionen wir nutzen k\u00f6nnten: </p> <pre><code>Usage: web-push send-notification --endpoint=&lt;url&gt; [--key=&lt;browser key&gt;] [--auth=&lt;auth secret&gt;] [--payload=&lt;message&gt;] [--ttl=&lt;seconds&gt;] [--encoding=&lt;encoding type&gt;] [--vapid-subject=&lt;vapid subject&gt;] [--vapid-pubkey=&lt;public key url base64&gt;] [--vapid-pvtkey=&lt;private key url base64&gt;] [--gcm-api-key=&lt;api key&gt;]\n\nweb-push generate-vapid-keys [--json]\n</code></pre> <p>Die <code>send-notification</code>-Option in Verbindung mit dem <code>endpoint</code> werden wir sp\u00e4ter verwenden, um Push-Nachrichten zu senden. Zun\u00e4chst ben\u00f6tigen wir den \u00f6ffentlichen und den privaten Schl\u00fcssel zur Verschl\u00fcsselung der Kommunikation mit dem In-Browser Push Server. Dazu verwenden wir die Option <code>generate-vapid-keys</code> und geben in das Terminal </p> <pre><code>npm run web-push generate-vapid-keys\n</code></pre> <p>ein. Wir erhalten eine Ausgabe in der Form</p> <pre><code>=======================================\n\nPublic Key:\nBCGnTHY7-DB07ySIj5hAYQBd5J3lXskcLMuAkqTTkneKB21tXyUP7uCaWJUjIPRpfecn73lMHpwANFw-0LsXEtY\n\nPrivate Key:\nTNVDKlHHGBZ66aKyCTxru630t6RL_xictOKA3n0lgM4\n\n=======================================\n</code></pre>"},{"location":"pushnotes/#public-key-in-der-appjs","title":"Public Key in der app.js","text":"<p>Wir kopieren zun\u00e4chst den \u00f6ffentlichen (<code>public</code>) Schl\u00fcssel und speichern in in unsere <code>app.js</code> der Webanwendung:</p> /src/js/app.js <pre><code>function configurePushSubscription() {\nif(!('serviceWorker' in navigator)) {\nreturn\n}\n\nlet swReg;\nnavigator.serviceWorker.ready\n.then( sw =&gt; {\nswReg = sw;\nreturn sw.pushManager.getSubscription();\n})\n.then( sub =&gt; {\nif(sub === null) {\n// create a new subscription\nlet vapidPublicKey = 'BCGnTHY7-DB07ySIj5hAYQBd5J3lXskcLMuAkqTTkneKB21tXyUP7uCaWJUjIPRpfecn73lMHpwANFw-0LsXEtY';\nswReg.pushManager.subscribe({\nuserVisibleOnly: true,\n});\n} else {\n// already subscribed\n}\n});\n}\n</code></pre> <p>Hier k\u00f6nnen wir auch schonmal die Option <code>userVisibleOnly: true</code> definieren (Zeile <code>54</code> - geschweifte Klammern nicht vergessen). Wie oben bereits erw\u00e4hnt, stellen wir den \u00f6ffentlichen Schl\u00fcssel als ein Base64- ArrayBuffer zur Verf\u00fcgung. Dazu ben\u00f6tigen wir eine Funktion <code>urlBase64ToUint8Array(base64String)</code>, die wir z.B. hier oder auch hier finden (es gibt daf\u00fcr auch node-Paket, z.B. hier oder hier) und die wir z.B. ebenfalls in die <code>app.js</code> einf\u00fcgen k\u00f6nnen (wenn Ihnen die <code>app.js</code>zu voll wird, k\u00f6nnen Sie sie auch in die <code>db.js</code> einf\u00fcgen): </p> /src/js/app.js <pre><code>function urlBase64ToUint8Array(base64String) {\nvar padding = '='.repeat((4 - base64String.length % 4) % 4);\nvar base64 = (base64String + padding)\n.replace(/\\-/g, '+')\n.replace(/_/g, '/');\n\nvar rawData = window.atob(base64);\nvar outputArray = new Uint8Array(rawData.length);\n\nfor (var i = 0; i &lt; rawData.length; ++i) {\noutputArray[i] = rawData.charCodeAt(i);\n}\nreturn outputArray;\n}\n\nfunction configurePushSubscription() {\nif(!('serviceWorker' in navigator)) {\nreturn\n}\n\nlet swReg;\nnavigator.serviceWorker.ready\n.then( sw =&gt; {\nswReg = sw;\nreturn sw.pushManager.getSubscription();\n})\n.then( sub =&gt; {\nif(sub === null) {\n// create a new subscription\nlet vapidPublicKey = 'BCGnTHY7-DB07ySIj5hAYQBd5J3lXskcLMuAkqTTkneKB21tXyUP7uCaWJUjIPRpfecn73lMHpwANFw-0LsXEtY';\nlet convertedVapidPublicKey = urlBase64ToUint8Array(vapidPublicKey);\nswReg.pushManager.subscribe({\nuserVisibleOnly: true,\napplicationServerKey: convertedVapidPublicKey,\n});\n} else {\n// already subscribed\n}\n});\n}\n</code></pre> <p>In Zeile <code>68</code> verwenden die neue Funktion, um den \u00f6ffentlichen Schl\u00fcssel in ein Base64-ArrayBuffer zu konvertieren und weisen diesen <code>convertedVapidPublicKey</code> der Eigenschaft <code>applicationServerKey</code> in den Optionen der <code>subscribe()</code>-methode zu (Zeile <code>71</code>). </p> <p>Damit ist die Konfiguration der Subscription im Prinzip abgeschlossen. Allerdings m\u00fcssen wir diese Subscription nun auch noch unserem Backend mitteilen. Dazu sorgen wir zun\u00e4chst daf\u00fcr, dass die Subscription an den n\u00e4chsten <code>then()</code>-Block weitergegeben wird (<code>return swReg</code>) und senden diese im <code>then()</code>-Block an das Backend:</p> /src/js/app.js <pre><code>function configurePushSubscription() {\nif(!('serviceWorker' in navigator)) {\nreturn\n}\n\nlet swReg;\nnavigator.serviceWorker.ready\n.then( sw =&gt; {\nswReg = sw;\nreturn sw.pushManager.getSubscription();\n})\n.then( sub =&gt; {\nif (sub === null) {\n// create a new subscription\nlet vapidPublicKey = 'BCGnTHY7-DB07ySIj5hAYQBd5J3lXskcLMuAkqTTkneKB21tXyUP7uCaWJUjIPRpfecn73lMHpwANFw-0LsXEtY';\nlet convertedVapidPublicKey = urlBase64ToUint8Array(vapidPublicKey);\nreturn swReg.pushManager.subscribe({\nuserVisibleOnly: true,\napplicationServerKey: convertedVapidPublicKey,\n})\n} else {\n// already subscribed\n}\n})\n.then( newSub =&gt; {\nreturn fetch('http://localhost:3000/subscription', {\nmethod: 'POST',\nheaders: {\n'Content-Type': 'application/json',\n'Accept': 'application/json'\n},\nbody: JSON.stringify(newSub)\n})\n.then( response =&gt; {\nif(response.ok) {\ndisplayConfirmNotification();\n}\n})\n});\n}\n</code></pre> <p>Den Aufbau einer solchen <code>POST-fetch()</code>-Anfrage kennen wir schon. Wenn das Backend ein <code>ok</code> zur\u00fccksendet, dann rufen wir die <code>displayConfirmNotatification()</code> auf, die wir f\u00fcr Benachrichtigungen erstellt hatten. </p> <p>Aber diesen Endpunkt, den wir beim Backend verwenden, n\u00e4mlich <code>POST http://localhost:3000/subscription</code>, den m\u00fcssen wir erst noch im Backend einrichten. </p>"},{"location":"pushnotes/#neuer-endpunkt-im-backend","title":"Neuer Endpunkt im Backend","text":"<p>Wir wechseln wieder zu unserem Backend und \u00f6ffnen dort die <code>server.js</code>, um einen neuen Endpunkt zu definieren:</p> server.js <pre><code>const express = require('express');\nconst cors = require('cors');\nconst postsRoutes = require('./routes/posts.routes');\nconst uploadRoutes = require('./routes/upload.routes');\nconst downloadRoute = require('./routes/download.routes');\nconst deleteRoute = require('./routes/delete.routes');\nconst subscriptionRoute = require('./routes/subscription.routes');\nconst mongoose = require('mongoose');\nrequire('dotenv').config();\n\nconst app = express();\napp.use(express.json());\napp.use(cors());\n\napp.use('/posts', postsRoutes);\napp.use('/image', uploadRoutes);\napp.use('/download', downloadRoute);\napp.use('/delete', deleteRoute);\napp.use('/subscription', subscriptionRoute);\napp.listen(process.env.PORT, (error) =&gt; {\nif (error) {\nconsole.log(error);\n} else {\nconsole.log(`server running on http://localhost:${process.env.PORT}`);\n}\n});\n\n// connect to mongoDB\nmongoose.connect(process.env.DB_CONNECTION, { useNewUrlParser: true, useUnifiedTopology: true });\nconst db = mongoose.connection;\ndb.on('error', console.error.bind(console, 'connection error:'));\ndb.once('open', () =&gt; {\nconsole.log('connected to DB');\n});\n</code></pre> <p>Die Subscriptions wollen wir unter dem Endpunkt <code>/subscription</code> verwalten lassen. Wir erstellen uns eine neue Datei <code>routes/subscription.routes.js</code> mit </p> routes/subscription.routes.js <pre><code>const express = require('express');\nconst webpush = require('web-push');\nconst router = express.Router();\n\nconst publicVapidKey = 'BLp3BGxSyYIv3rfy07KC-saKtiCVI073LWw5Eh24gHoRGV7hhT1kVwo6gnhjrUszZguRy8b9lGroKNRy9iCUcCI';\nconst privateVapidKey = '9HPDFyx8Xd3lu2ctDHGdf3TNSjDUU2nsAuwwLe2d_6A';\n\nrouter.post('/', async(req, res) =&gt; {\nconst subscription = req.body;\nconsole.log('subscription', subscription);\nres.status(201).json({ message: 'subscription received'});\n\nwebpush.setVapidDetails('mailto:freiheit@htw-berlin.de', publicVapidKey, privateVapidKey);\n});\n\nmodule.exports = router;\n</code></pre> <p>Diese <code>subscriptionRoute</code> ist auch bereits in der <code>server.js</code> importiert worden (siehe dort Zeile <code>7</code>). Bei der Implementierung sind wir vorgegangen, wie z.B. hier oder hier beschrieben.</p> <p>Bei den Schl\u00fcsseln m\u00fcssen Sie nat\u00fcrlich Ihre einsetzen (die mit <code>web-push generate-vapid-keys</code> erzeugten).</p> <p>Wenn wir nun das Backend ausf\u00fchren und auch die Webanwendung und auf den Button <code>BENACHRICHTIGEN EIN</code> klicken, dann erhalten wir eine Nachricht, die durch die <code>displayConfirmNotification()</code>-Methode ausgel\u00f6st wurde. Wir haben uns erfolgreich an die Push-Benachrichtigung angemeldet. </p> <p>Bitte beachten Sie die Ausgabe auf die Konsole im Backend, die wir durch die Zeile <code>10</code> <code>console.log('subscription', subscription);</code> erzeugt haben. Sie zeigt etwas in der Art: </p> <pre><code>subscription {\nendpoint: 'https://fcm.googleapis.com/fcm/send/cMdUtRW4H9o:APA91bG8p3o-Ta31e1yMrqdvonJCyf3xbPfIFtpS2UbX9PcJwkeNKoQjZhEAWo5nad7eR3NgRQR8__3wk591j7DKWJLGzwWgJYm_GgipU0gTvMRpWA6TpmCtrD9OCo1mB0jZQrTj5a_5',\n  expirationTime: null,\n  keys: {\np256dh: 'BDhH_TBG4l-PU3wJnT6wHqsPeYusbPqOiw7VvJvupXDC3JZOIIOiz2Ml8ZaZD9wJuGnXs9BFqINEzrFStsjkk6c',\n    auth: 'fJRvyO_fnPXsYeDkMy_jAA'\n}\n}\n</code></pre> <p>Das Wort <code>subscription</code> haben wir davor gesetzt, aber das <code>subscription</code>-Objekt besitzt drei Eigenschaften:</p> <ul> <li><code>endpoint</code>: das ist genau der Endpunkt des In-Browser Push Servers (hier wegen Chrome nat\u00fcrlich irgendetwas bei Google). An diesen Endpunkt werden die Push-Notifikationen gesendet. </li> <li><code>expirationTime</code>: spielt hier keine Rolle, ist ja auch <code>null</code>. Kann man nutzen, wenn man JSON Web Tokens verwendet und diesen eine Haltbarkeitsdauer zuweist. </li> <li><code>keys</code>: das sind unsere Authentifikationsdaten beim In-Browser Push Server. Diese Daten zusammen mit dem privaten Schl\u00fcssel werden ben\u00f6tigt, um sich an dem Endpunkt zu authentifizieren.  </li> </ul> <p>Achtung! Sie m\u00fcssen ab jetzt vermeiden, Ihren Service Worker auf <code>unregister</code> zu setzen. Eine Subscription existiert f\u00fcr einen Browser und auch f\u00fcr einen Service Worker! Update von Service Worker ist kein Problem, aber <code>unregister</code> f\u00fchrt zu Problemen - also lieber jetzt erstmal nicht mehr!</p> <p>Falls Sie bereits eine <code>subscription</code> erzeugt haben, diese aber nicht mehr verwenden wollen, dann k\u00f6nnen Sie in der <code>app.js</code> einmal folgenden Code ausf\u00fchren:</p> /src/js/app.js <pre><code>    .then( sub =&gt; {\nif(sub === null) {\nconsole.log('sub==null')\n// create a new subscription\nlet vapidPublicKey = 'BLp3BGxSyYIv3rfy07KC-saKtiCVI073LWw5Eh24gHoRGV7hhT1kVwo6gnhjrUszZguRy8b9lGroKNRy9iCUcCI';\nlet convertedVapidPublicKey = urlBase64ToUint8Array(vapidPublicKey);\n\nreturn swReg.pushManager.subscribe({\nuserVisibleOnly: true,\napplicationServerKey: convertedVapidPublicKey,\n});\n} else {\n/* zum Testen, falls subscription bereits existierte, \n             * aber neue erstellt werden soll\n             */\n\nsub.unsubscribe()\n.then( () =&gt; {\nconsole.log('unsubscribed()', sub)\n})\n}\n</code></pre> <p>Das bewirkt, dass die existierende <code>subscription</code> gel\u00f6scht wird. Haben Sie diesen Code einmal ausgef\u00fchrt, dann kommentieren Sie die Zeilen <code>80-83</code> wieder aus. beim n\u00e4chsten Mal wir die neue <code>subscription</code> registriert (<code>subscribe()</code>) und danach wird der (dann wieder leere) <code>else</code>-Zwei ausgef\u00fchrt. </p>"},{"location":"pushnotes/#push-nachrichten-senden","title":"Push-Nachrichten senden","text":"<p>Wir haben uns nun erfolgreich f\u00fcr den Empfang von Push-Nachrichten \"registriert\". Wir haben in <code>app.js</code> allerdings noch nicht implementiert, was passieren soll, wenn wir bereits registriert sind (siehe oben Listing von <code>app.js</code> Zeile <code>// already subscribed</code>). Wir wollen aber trotzdem schonmal Push-Nachrichten senden. Dazu passen wir im Backend die <code>posts.routes.js</code> wie folgt an:</p> posts.routes.js (Auszug) <pre><code>const webpush = require('web-push');\nconst publicVapidKey = 'BCGnTHY7-DB07ySIj5hAYQBd5J3lXskcLMuAkqTTkneKB21tXyUP7uCaWJUjIPRpfecn73lMHpwANFw-0LsXEtY';\nconst privateVapidKey = 'TNVDKlHHGBZ66aKyCTxru630t6RL_xictOKA3n0lgM4';\nconst pushSubscription = {\nendpoint: 'https://fcm.googleapis.com/fcm/send/cMdUtRW4H9o:APA91bG8p3o-Ta31e1yMrqdvonJCyf3xbPfIFtpS2UbX9PcJwkeNKoQjZhEAWo5nad7eR3NgRQR8__3wk591j7DKWJLGzwWgJYm_GgipU0gTvMRpWA6TpmCtrD9OCo1mB0jZQrTj5a_5',\nkeys: {\nauth: 'fJRvyO_fnPXsYeDkMy_jAA',\np256dh: 'BDhH_TBG4l-PU3wJnT6wHqsPeYusbPqOiw7VvJvupXDC3JZOIIOiz2Ml8ZaZD9wJuGnXs9BFqINEzrFStsjkk6c',\n}\n};\nfunction sendNotification() {\nwebpush.setVapidDetails('mailto:freiheit@htw-berlin.de', publicVapidKey, privateVapidKey);\nconst payload = JSON.stringify({\ntitle: 'New Push Notification',\ncontent: 'New data in database!'\n});\nwebpush.sendNotification(pushSubscription,payload)\n.catch(err =&gt; console.error(err));\nconsole.log('push notification sent');\n// res.status(201).json({ message: 'push notification sent'});\n}\n// POST one post\nrouter.post('/', upload.single('file'), async(req, res) =&gt; {\n// req.file is the `file` file\nif (req.file === undefined) {\nreturn res.send({\n\"message\": \"no file selected\"\n});\n} else {\nconsole.log('req.body', req.body);\nconsole.log('req.file', req.file);\nconst newPost = new Post({\ntitle: req.body.title,\nlocation: req.body.location,\nimage_id: req.file.filename\n})\nawait newPost.save();\nsendNotification();\nreturn res.send(newPost);\n}\n})\n</code></pre> <p>Wir definieren eine Variable <code>pushSubscription</code>, die genau alle Werte der Subscription oben enth\u00e4lt (<code>expirationTime</code> lassen wir weg). Diese Informationen holen wir uns sp\u00e4ter noch automatisch. Au\u00dferdem definieren wir eine neue Funktion <code>sendNotification()</code>. Darin verwenden wir aus dem web-push-Package die Funktion <code>setVapidDetail()</code>. Diese Funktion bekommt als ersten Parameter eine <code>id</code> \u00fcbergeben, typischerweise (so wie hier beschrieben) einen String beginnend mit <code>mailto:</code> und der E-Mail-Adresse. Als zweiten Parameter wird der \u00f6ffentliche Vapid-Schl\u00fcssel als einfacher String \u00fcbergeben und als dritter Parameter der private Vapid-Schl\u00fcssel als einfacher String. </p> <p>Dann kann man f\u00fcr die Nachricht einen sogenannten <code>payload</code> festlegen, der ein beliebiges JSON ist (kann auch ein einfacher String sein). Dieser <code>payload</code> ist der Inhalt der Push-Nachricht. Wir haben in diesem Fall einen <code>title</code> und einen <code>content</code> festgelegt. </p> <p>Das Senden der eigentlichen Nachricht an den In-Browser Push Server erfolgt mithilfe der Funktion <code>sendNotification()</code> aus dem web-push-Package. Dieser wird das gesamte JavaScript-Objekt <code>pushSubscription</code> sowie der <code>payload</code> \u00fcbergeben. </p> <p>Die Funktion <code>sendNotification()</code> wird also immer dann aufgerufen, wenn in der Datenbank ein neuer Post gespeichert wird. </p> <p>Wir k\u00f6nnen die Funktion insofern testen, als dass wir neue Daten eingeben, entweder \u00fcber Postman oder \u00fcber unsere Webanwendung \u00fcber das Formular (diese Daten landen ja auch beim Backend). Allerdings k\u00f6nnen wir uns dabei nur von der Fehlerfreiheit der Ausf\u00fchrungen \u00fcberzeugen (und im Backend erscheint im Terminal <code>push notification sent</code>). Die Push-Nachricht ist nun beim In-Browser Push Server. Wir m\u00fcssen jetzt aber im Service Worker zun\u00e4chst das <code>push</code>-Event behandeln, um die Benachrichtigung tats\u00e4chlich im Ger\u00e4t zu erhalten. </p>"},{"location":"pushnotes/#das-push-ereignis-behandeln","title":"Das <code>push</code>-Ereignis behandeln","text":"<p>Das <code>push</code>-Ereignis wird vom In-Browser Push Server ausgel\u00f6st, wann immer eine neue Push-Benachrichtigung dort eintrifft. Das kann ant\u00fcrlich auch dann passieren, wenn die Webanwendung geschlossen ist. Das Behandeln des <code>push</code>-Ereignisses ist deshalb Aufgabe des Service Workers. Wir erweitern also die <code>sw.js</code> um die Behandlung des <code>push</code>-Events:</p> sw.js <pre><code>self.addEventListener('push', event =&gt; {\nconsole.log('push notification received', event);\nlet data = { title: 'Test', content: 'Fallback message'};\nif(event.data) {\ndata = JSON.parse(event.data.text());\n}\n\nlet options = {\nbody: data.content,\nicon: '/src/images/icons/fiw96x96.png',\n};\n\nevent.waitUntil(\nself.registration.showNotification(data.title, options)\n);\n});\n</code></pre> <p>Die Ereignisbehandlung im Service Worker haben wir nun schon ein paar Mal gemacht. Wir geben zuerst das <code>event</code> selbst einmal auf der Konsole aus. Es handelt sich um ein PushEvent. Dann erstellen wir uns Dummy-<code>data</code>, falls der Empfang der Push-Nachricht vom Server nicht klappen sollte. Wenn aber doch, dann schreiben wir die Variable <code>data</code> mit den Daten aus dem <code>PushEvent</code> (siehe oben im Backend <code>payload</code> - die Daten sollten also <code>title</code> und <code>content</code> enthalten). Wir lesen die <code>data</code> aus dem <code>event</code>-Objekt aus und wandeln diese mithilfe von <code>JSON.parse()</code> in ein JSON um. Dann erzeugen wir, so wie in Abschnitt Weitere Optionen f\u00fcr die Benachrichtigungen beschrieben, die Benachrichtigung. </p> <p>Beachten Sie noch, dass <code>self</code> auf den Service Worker zeigt und <code>self.registration</code> verwendet wird, um auf das ServiceWorkerRegistration zuzugreifen, welches \u00fcber die Methode <code>showNotification()</code> verf\u00fcgt. </p> <p>Wenn wir nun neue Daten \u00fcber das Formular eingeben, erscheint</p> <p></p>"},{"location":"pushnotes/#eine-webseite-offnen","title":"Eine Webseite \u00f6ffnen","text":"<p>Jetzt fehlt eigentlich nur noch, dass wir in der Push-Benachrichtung eine Aktion vorsehen, die das \u00d6ffnen unserer Webanwendung erm\u00f6glicht. Das typische Szenario ist ja, dass die Webanwendung geschlossen ist und dass im Backend eine Daten\u00e4nderung stattfindet und wir daraufhin eine Push-Nachricht erhalten. Nun wollen wir gerne auf diese Push-Nachricht klicken und damit soll die Anwendung ge\u00f6ffnet werden, die uns das neue Datum anzeigt. Daf\u00fcr haben wir auch schon alles vorbereitet - Service Worker reagieren wir bereits auf das Ereignis, dass auf die Benachrichtigung geklickt wird:</p> sw.js <pre><code>self.addEventListener('notificationclick', event =&gt; {\nlet notification = event.notification;\nlet action = event.action;\n\nconsole.log(notification);\n\nif(action === 'confirm') {\nconsole.log('confirm was chosen');\nnotification.close();\n} else {\nconsole.log(action);\n}\n});\n</code></pre> <p>Die <code>confirm</code>-Antwort erfolgt nur, wenn nach der Zulassung der Berechtigung gefragt wird. Wir behandeln die anderen F\u00e4lle. </p> sw.js <pre><code>self.addEventListener('notificationclick', event =&gt; {\nlet notification = event.notification;\nlet action = event.action;\n\nconsole.log(notification);\n\nif(action === 'confirm') {\nconsole.log('confirm was chosen');\nnotification.close();\n} else {\nconsole.log(action);\nevent.waitUntil(\nclients.matchAll()      // clients sind alle Windows (Browser), fuer die der Service Worker verantwortlich ist\n.then( clientsArray =&gt; {\nlet client = clientsArray.find( c =&gt; {\nreturn c.visibilityState === 'visible';\n});\n\nif(client !== undefined) {\nclient.navigate('http://localhost:8080');\nclient.focus();\n} else {\nclients.openWindow('http://localhost:8080');\n}\nnotification.close();\n})\n);\n}\n});\n</code></pre> <p>Mit <code>clients</code> greift der Service Worker auf alle Fenster (Anwendungen, Browser) zu, \u00fcber die er Kontrolle hat (siehe Clients). Die Funktion <code>matcAll()</code> gibt ihm alle diese Clients als ein Array zur\u00fcck. Mit der JavaScript-Funktion <code>find()</code> laufen wir durch das Array und geben alle die Clients (genauer vom Typ WindowClient zur\u00fcck, f\u00fcr die gilt, dass sie sichtbar - im Sinne von erreichbar - sind. Diejenigen Clients, die nicht erreichbar sind, werden gar nicht erst zur\u00fcckgegeben. F\u00fcr alle anderen gilt, dass sie entweder bereits ge\u00f6ffnet sind oder nicht. Diejenigen (Browser), die bereits ge\u00f6ffnet sind, navigieren zur URL <code>http://localhost:8080</code> und die anderen werden mit dieser URL ge\u00f6ffnet. </p> <p>Wenn nun neue Daten eingegeben werden, dann erscheint eine Push-Notifikation und wenn wir darauf klicken, dann \u00f6ffnet sich unsere Anwendung. Eine gute M\u00f6glichkeit, das zu Testen, besteht in der Verwendung unseres Frontends, das wir f\u00fcr die Eingabe der Daten erstellt haben. Schlie\u00dfen Sie die <code>HTW-Insta</code>-Anwendung, \u00f6ffnen Sie das andere Frontend, geben Sie Daten ein und speichern diese. Es erscheint eine Push-Notifikation, auf die Sie klicken k\u00f6nnen und die <code>HTW-Insta</code>-Anwendung wird im browser mit den neuen Daten ge\u00f6ffnet. Diejenigen, die ihr Android-Ger\u00e4t anschlie\u00dfenm k\u00f6nnen, sollten es auch unbedingt dar\u00fcber probieren. </p> <p>Hier noch eine kleine Verbesserung davon, weil wir ja die URL hart in den Code geschrieben haben. Wir k\u00f6nnen im Backend beim Senden der Notification eine weitere Eigenschaft hinzuf\u00fcgen:</p> posts.routes.js <pre><code>sendNotification: () =&gt; {\nwebpush.setVapidDetails('mailto:freiheit@htw-berlin.de', publicVapidKey, privateVapidKey);\nconst payload = JSON.stringify({\ntitle: 'New Push Notification',\ncontent: 'New data in database!',\nopenUrl: '/help'\n});\nwebpush.sendNotification(pushSubscription,payload)\n.catch(err =&gt; console.error(err));\nconsole.log('push notification sent');\n}\n</code></pre> <p>und diese der Benachrichtigung mitgeben:</p> sw.js <pre><code>self.addEventListener('push', event =&gt; {\nconsole.log('push notification received', event);\nlet data = { title: 'Test', content: 'Fallback message', openUrl: '/'};\nif(event.data) {\ndata = JSON.parse(event.data.text());\n}\n\nlet options = {\nbody: data.content,\nicon: '/src/images/icons/fiw96x96.png',\ndata: {\nurl: data.openUrl\n}\n};\n\nevent.waitUntil(\nself.registration.showNotification(data.title, options)\n);\n});\n</code></pre> <p>und diese Informationen dann statt der festen URL verwenden:</p> sw.js <pre><code>self.addEventListener('notificationclick', event =&gt; {\nlet notification = event.notification;\nlet action = event.action;\n\nconsole.log(notification);\n\nif(action === 'confirm') {\nconsole.log('confirm was chosen');\nnotification.close();\n} else {\nconsole.log(action);\nevent.waitUntil(\nclients.matchAll()      // clients sind alle Windows (Browser), fuer die der Service Worker verantwortlich ist\n.then( clientsArray =&gt; {\nlet client = clientsArray.find( c =&gt; {\nreturn c.visibilityState === 'visible';\n});\n\nif(client !== undefined) {\nclient.navigate(notification.data.url);\nclient.focus();\n} else {\nclients.openWindow(notification.data.url);\n}\nnotification.close();\n})\n);\n}\n});\n</code></pre> <p>Wenn Sie jetzt auf die Push-Nachricht klicken, sollte sich die <code>help</code>-Seite der Anwendung \u00f6ffnen. </p> <p>Success</p> <p>Wir haben zun\u00e4chst gelernt, dass Benachrichtigungen und Push-benachrichtigungen zwei grunds\u00e4tzlich verschiedene Dinge sind. Benachrichtigungen ist das, was man als Nachricht \"sieht\". Push-Notifikationen werden an den In-Browser Push Server vom Backend gesendet. Dieser Server l\u00f6st daraufhin ein <code>push</code>-Ereignis beim Service Worker aus, wenn die Webanwendung sich f\u00fcr den Empfang von Push-Nachrichten. registriert hat. Die Registrierung ist etwas aufwendig, muss aber nur einmal erledigt werden. Mit den Push-Nachrichten kennen wir nun eine weitere progressive Funktionalit\u00e4t. Bis dahin waren Push-Nachrichten nur nativen Apps vorbehalten. </p>"},{"location":"serviceworker/","title":"Service Workers","text":"<p>Wir betrachten einen wichtigen Grundbaustein, der solche Funktionalit\u00e4ten, wie Push-Notifikationen, Hintergrund-Synchronisationen und die M\u00f6glichkeit, auch offline die Anwendung auszuf\u00fchren, erst erm\u00f6glicht: sogenannte Service Workers.</p> <p>Ein service worker ist zun\u00e4chst einmal ein Skript (in JavaScript), welches im Browser im Hintergrund l\u00e4uft, unabh\u00e4ngig von der Webseite. Ein service worker stellt Funktionalit\u00e4ten, wie Push-Notifikationen oder Hintergrund-Synchronisationen zur Verf\u00fcgung, \u00e4hnlich einer API. Entstanden sind service worker aus der Verwendung des Application Caches. Die service worker API w\u00e4chst kontinuierlich und bietet zunehmend weitere Funktionalit\u00e4ten. </p> <p>Service worker haben einige n\u00fctzliche Eigenschaften:</p> <ul> <li>Ein service worker kann zwar nicht direkt das DOM einer Seite manipulieren, kann aber auf Requests der Seite mit Responses reagieren und die Seite selbst kann darufhin ihr DOM \u00e4ndern. </li> <li>Ein service worker ist ein \"programmierbarer\" Proxy, der steuert, wie Requests von der Webseite behandelt werden.</li> <li>Service workers verwenden die IndexDB API, um client-seitig strukturierte Daten persistent zu speichern. </li> <li>Service workers verwenden Promises. Wir werden uns deshalb Promises detailliert anschauen. </li> </ul> <p>Die folgenden Abbildungen verdeutlichen die Arbeitsweise eines service workers. Zun\u00e4chst \u00fcberlegen wir uns nochmal, wie \"normales\" JavaScript in Webanwendungen ausgef\u00fchrt wird. Die JS-Skripte werden mit den HTML-Seiten geladen. Sie stellen Funktionen bereit, die entweder durch Nutzerinteraktionen (z.B. <code>click</code>) oder durch Lifecycle-Events (z.B. <code>onload</code>) ausgel\u00f6st und aufgerufen werden. Diese Funktionen laufen alle in einem einzigen Thread:</p> <p>. </p> <p>Service worker laufen auf einem eigenen Thread. Service worker werden an HTML-Seiten registriert, laufen aber g\u00e4nzlich unabh\u00e4ngig von ihnen. Sie laufen sogar dann, wenn die HTML-Seiten geschlossen sind. Service worker laufen im Hintergrund, es handelt sich um Hintergrundprozesse. Service worker sind zwar JavaScript, manipulieren aber nicht den DOM. Sie sind nicht an HTML-Seiten gebunden, sondern an eine Domain. Service worker reagieren ebenfalls auf Ereignisse, aber andere, als wir sie von Webanwendungen kennnen, z.B. auf Push-Notifikationen. </p> <p>. </p> <p>Service worker laufen einfach im Hintergrund und warten auf Ereignisse. Welche Ereignisse k\u00f6nnen das sein?</p>"},{"location":"serviceworker/#ereignisse-auf-die-service-worker-reagieren-konnen","title":"Ereignisse, auf die Service Worker reagieren k\u00f6nnen","text":"<p>Wir betrachten hier einige der Ereignisse, auf die service worker reagieren k\u00f6nnen, auf die sie also \"h\u00f6ren\". </p>"},{"location":"serviceworker/#fetch","title":"Fetch","text":"<p>Wann immer der Browser etwas vom Webserver l\u00e4dt, f\u00fchrt er ein <code>fetch</code>-Ereignis aus. Das kann eine HTML-Seite, aber auch ein Bild (<code>img</code>), eine CSS-Datei oder eine JavScript-Datei sein. Ein service worker kann auf ein solches Ereignis reagieren. Tats\u00e4chlich agiert der service worker als ein Proxy, der zwischen dem Browser und dem Webserver steht und die <code>fetch</code>-Anfragen (<code>requests</code>) des Browsers empf\u00e4ngt und eventuell an den Webserver weiterleitet. Eventuell leitet er die Anfrage auch nicht weiter, sondern beantwortet sie mit einer Resource aus dem eigen Cache. </p> <p>F\u00fcr die <code>fetch</code>-Ereignisse wird die <code>Fetch-API</code> verwendet, auf die wir sp\u00e4ter noch ausf\u00fchrlich zu sprechen kommen. Wichtig ist an dieser Stelle zu erw\u00e4hnen, dass ein (asynchrones) <code>XMLHttpRequest</code> kein <code>fetch</code>-Ereignis darstellt. Eine Single-Page-Application, die Ressourcen vom Browser nachl\u00e4dt, ruft dabei keine (weiteren) <code>fetch</code>-Ereignisse auf. </p>"},{"location":"serviceworker/#push-notifikationen","title":"Push-Notifikationen","text":"<p>Push-Notifikationen werden von einem (anderen) Server gesendet und k\u00f6nnen durch service worker verwaltet werden. Jeder Browser verf\u00fcgt \u00fcber eigene Push-Web-Server. Es k\u00f6nnen von jedem beliebigen Server Push-Nachrichten an diese Push-Web-Server gesendet werden. Der service worker kann auf solche Ereignisse reagieren. Wichtig ist hier zu wiederholen, dass service worker auch dann (im Hintergrund) arbeiten, wenn die Webanwendung selbst geschlossen ist. Sie k\u00f6nnen trotzdem erkennen, wenn Push-Nachrichten eingehen und darauf geeignet reagieren. Auch hier wirken service worker wieder wie ein Proxy, n\u00e4mlich f\u00fcr die Push-Web-Server. Der service worker kann z.B. eine Nachricht auf dem Startbildschirm des Smartphones erzeugen. Mit dieser Nachricht kann die Nutzerin dann etwas machen und l\u00f6st dabei das folgende Ereiegnis aus:</p>"},{"location":"serviceworker/#notification-interaction","title":"Notification interaction","text":"<p>Klickt eine Nutzerin auf die (Push-)Nachricht, die vom service worker erzeugt wurde, wird ein entsprechendes Ereignis ausgel\u00f6st, auf das wiederum der service worker reagieren kann, z.B. eine Webseite aufrufen und \u00f6ffnen oder eine Anwendung. Auch hier ist es wieder wichtig, dass das ein service worker erledigt und nicht ein JavaScript, welches zu einer Webanwendung geh\u00f6rt, da es ja sein kann, dass diese Webanwendung geschlossen ist.</p>"},{"location":"serviceworker/#hintergrund-synchronisation","title":"Hintergrund-Synchronisation","text":"<p>Es kann passieren, dass in einer Webanwendung Ereignisse ausgef\u00fchrt werden, jedoch keine Verbindung zum Internet besteht. Typischerweise werden die Ausf\u00fchrungen solcher Ereignisse, die offline ausgef\u00fchrt werden, ebenfalls durch service worker erledigt. Sobald der Browser wieder mit dem Internet verbunden ist, l\u00f6st er ein Ereignis aus. Auf dieses Ereignis kann der service worker reagieren und die Ereignisse, die er offline gespeichert und beantwortet hat, nun im Hintergrund online ausf\u00fchren, so dass eine Hintergrund-Synchronisation erfolgt. </p>"},{"location":"serviceworker/#service-worker-lifecycle-ereignisse","title":"Service-worker-Lifecycle-Ereignisse","text":"<p>Ein service worker durchl\u00e4uft selbst einen eigenen \"Lebenszyklus\". Wir kennen Liefecycle-Events bereits aus Angular, z.B. <code>ngOnInit()</code> oder auch von Webseiten (<code>load</code>). Solche Lifecycle-Events existieren auch f\u00fcr service worker. Wir werden sie uns sp\u00e4ter im Detail anschauen. Zuerst betrachten wir aber zur Einf\u00fchrung ein einfaches Beispiel f\u00fcr die Verwendung eines service workers (wie wir gleich im Anschluss dikutieren werden, handelt es sich eigentlich um einen web worker). </p>"},{"location":"serviceworker/#einfaches-beispiel-service-worker","title":"Einfaches Beispiel service worker","text":"<p>Wir betrachten ein erstes einfaches Beispiel f\u00fcr die Verwendung eines service workers. Wir erstellen folgende <code>index.html</code>. </p> index.html <pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Erstes Beispiel service worker&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;p&gt;Gr\u00f6\u00dfte Primzahl bisher: &lt;output id=\"result\"&gt;&lt;/output&gt;&lt;/p&gt;\n&lt;script&gt;\nvar worker = new Worker('worker.js');\nworker.onmessage = function (event) {\ndocument.getElementById('result').textContent = event.data;\n};\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>In Zeile <code>10</code> wird mithilfe des <code>Worker</code>-Kunstruktors ein <code>Worker</code>-Objekt erzeugt. Dem Konstruktor wird die Implementierung des workers \u00fcbergeben, genauer gesagt, die Implementierung des Event-Handlers f\u00fcr <code>onmessage</code> des <code>Worker</code>-Objektes. Die Implementierung des <code>onmessage</code>-Event-Handlers sieht typischerweise so aus, dass der service worker mit einer <code>postMessage</code> antwortet und diese an die Seite \u00fcbergibt. In unserem Beispiel ist die Implementierung wie folgt: </p> worker.js <pre><code>var n = 1;\nsearch: while (true) {\nn += 1;\nfor (var i = 2; i &lt;= Math.sqrt(n); i += 1)\nif (n % i == 0)\ncontinue search;\n// found a prime!\npostMessage(n);\n}\n</code></pre> <p>Zeile <code>8</code> enth\u00e4lt die <code>postMessage</code>. Darin wird eine Zahl <code>n</code> an die Seite geschickt, sobald sie berechnet wurde. Es handelt sich bei der Berechnung um eine Primzahlberechnung. Das hei\u00dft, der service worker arbeitet im Hintergrund und \"sucht\" neue Primzahlen. Sobald der service worker eine neue Primzahl gefunden hat, schickt er diese mithilfe der <code>postMessage()</code>-Funktion an die Webseite. Dadurch wird das <code>onmessage</code>-Ereignis (genauer gesagt, handelt es sich um das <code>message</code>-Event) behandelt. Wann immer <code>onmessage</code> auftritt, aktualisiert die Seite, genauer gesagt, der <code>textContent</code> des <code>&lt;output&gt;</code>-Elementes mit der <code>id= \"result\"</code> (siehe Zeilen <code>11-13</code> in <code>index.html</code>). </p> <p>Dieses Beispiel ist extra einfach gehalten. genauer gesagt, handelt es sich bei dem Beispiel \"nur\" um einen web worker. Das W3C unterscheidet zwischen service workers und web workers. Der Unterschied zwischen web worker und * service worker* wird z.B. hier beschrieben. </p>"},{"location":"serviceworker/#web-worker-vs-service-worker","title":"Web worker vs. service worker","text":"<p>Wir verwenden f\u00fcr die Unterscheidung zwischen web worker und service worker  haupts\u00e4chlich dieses Dokument. Darin finden wir auch folgendes Bild zur Beschreibung eines web workers:</p> <p></p> <p>Ein web worker hat kein spezifisches Einsatzszenario, au\u00dfer dass er unabh\u00e4ngig von Hauptthread der Anwendung l\u00e4uft und Nachrichten mittels <code>postMessage()</code> an die Anwendung schicken kann. </p> <p>Demgegen\u00fcber ist ein service worker ein spezieller web worker, der als Proxy zwischen Anwendung und dem Netzwerk bzw. dem Cache agiert. </p> <p></p> <p>Service workers verf\u00fcgen \u00fcber mehr Funktionalit\u00e4ten als web workers. Dazu geh\u00f6ren einerseits die Ereignisse, auf die service workers reagieren k\u00f6nnen:</p> <ul> <li><code>install</code> und <code>activate</code> (sogenannte Lifecycle events),</li> <li><code>fetch</code> und weitere Ereignisse, die durch Erweiterungen spezifiziert werden, z.B. <code>push</code>, <code>notificationclick</code>, <code>notificationclose</code>, <code>sync</code>, <code>canmakepayment</code>, <code>paymentrequest</code> usw. (sogenannte Functional events) sowie</li> <li><code>message</code> und <code>messageerror</code> vom Web worker</li> </ul> <p>und andererseits die Status, in denen sich ein service worker befinden kann:</p> <ul> <li><code>parsed</code>, <code>installing</code>, <code>installed</code>, <code>activating</code>, <code>activated</code> und <code>redundant</code> (initial: <code>parsed</code>)</li> </ul> <p>Die prinzipielle Idee der Registrierung eines service workers sieht so aus:</p> <p></p> <p>Die beiden Lifecycle-Events <code>install</code> und <code>activate</code> sind bereits eingezeichnet. Dabei ist zu betonen, dass ein service worker  erst dann aktiviert werden kann, wenn kein anderer service worker mehr (in der gleichen Dom\u00e4ne/im gleichen Scope) l\u00e4uft. Ein anderer service worker, der eventuell noch l\u00e4uft, muss erst geschlossen werden, bevor der neue service worker das <code>activate</code>-Ereignis ausl\u00f6sen kann. Damit ein solcher \"alter\" service worker geschlossen werden kann, m\u00fcssen zumindest alle Tabs im Browser, in denen die Webanwendung l\u00e4uft, geschlossen werden. Selbst dann l\u00e4uft der service worker aber immernoch weiter. Er muss explizit geschlossen werden. Das zeigen wir sp\u00e4ter. </p>"},{"location":"serviceworker/#registrierung-eines-service-workers","title":"Registrierung eines service workers","text":"<p>W\u00e4hrend wir f\u00fcr das einfache Beispiel mit dem web worker noch den <code>Worker()</code>-Konstruktor verwendet haben, erfolgt die Registrierung eines service workers mittels <code>navigator.serviceWorker.register('./sw.js')</code>, wobei in <code>sw.js</code> der service worker implementiert ist. Wir schauen uns die prinzipielle Registrierung an:</p> index.html <pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"utf-8\"&gt;\n&lt;title&gt;Erstes Beispiel service worker&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;p&gt;\u00d6ffne die developer tools&lt;/p&gt;\n&lt;script&gt;\n\nif ('serviceWorker' in navigator) {\n// Register a service worker hosted at the root of the\n// site using the default scope.\nnavigator.serviceWorker.register('./sw.js').then(function(registration) {\nconsole.log('Service worker registration succeeded:', registration);\nconsole.log('Scope ist ' + registration.scope);\n// At this point, you can optionally do something\n// with registration. See https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration\n}).catch(function(error) {\nconsole.log('Service worker registration failed:', error);\n});\n\n// Independent of the registration, let's also display\n// information about whether the current page is controlled\n// by an existing service worker, and when that\n// controller changes.\n\n// First, do a one-off check if there's currently a\n// service worker in control.\nif (navigator.serviceWorker.controller) {\nconsole.log('This page is currently controlled by:', navigator.serviceWorker.controller);\n}\n\n// Then, register a handler to detect when a new or\n// updated service worker takes control.\nnavigator.serviceWorker.oncontrollerchange = function() {\nconsole.log('This page is now controlled by:', navigator.serviceWorker.controller);\n};\n} else {\nconsole.log('Service workers are not supported.');\n}\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Wir haben hier die registrierung des service workers innerhalb des <code>&lt;script&gt;</code>-Elementes. Besser (und das werden wir sp\u00e4ter auch immer machen) ist die Erstellung einer eigenen <code>.js</code>-Datei daf\u00fcr. </p> <p>Wenn wir die <code>Developer Tools</code> \u00f6ffnen, sehen wir auf der <code>Console</code> folgende Ausgabe:</p> <p></p> <p>F\u00fcr diejenigen, f\u00fcr die das Registrierungs-Beispiel oben zu lang ist, hier die Version von W3C:</p> <pre><code>// scope defaults to the path the script sits in\n// \"/\" in this example\nnavigator.serviceWorker.register(\"/serviceworker.js\").then(registration =&gt; {\nconsole.log(\"success!\");\nif (registration.installing) {\nregistration.installing.postMessage(\"Howdy from your installing page.\");\n}\n}, err =&gt; {\nconsole.error(\"Installing the worker failed!\", err);\n});\n</code></pre>"},{"location":"serviceworker/#registrierung-eines-service-workers-in-htw-insta","title":"Registrierung eines service workers in HTW-Insta","text":"<p>Nun, da wir wissen, wie die Registrierung eines service workers prinzipiell funktioniert, f\u00fcgen wir unserem <code>HTW-Insta</code>-Beispiel einen solchen hinzu. Den aktuellen Stand der Anwendung finden Sie unter IKT-PWA-02. Das ist die Version, in der bereits das Web-App-Manifest enthalten ist. </p> <p>Zun\u00e4chst beachten wir noch einen besonderen Eintrag in der <code>package.json</code>:</p> package.json <pre><code>{\n\"name\": \"IKT-PWA-02\",\n\"version\": \"1.0.0\",\n\"description\": \"Grundger\u00fcst einer PWA mit Web-App-Manifest\",\n\"main\": \"index.js\",\n\"scripts\": {\n\"start\": \"http-server -c-1\"\n},\n\"keywords\": [\"pwa\", \"progressive\", \"web\", \"app\", \"ikt\", \"htw\", \"fiw\"],\n\"author\": \"J. freiheit\",\n\"license\": \"ISC\",\n\"devDependencies\": {\n\"http-server\": \"^14.1.0\"\n}\n}\n</code></pre> <p>In Zeile <code>7</code> wird definiert, dass wir bei Aufruf des <code>npm start</code>-Befehls den Webserver <code>http-server</code> starten. Das Argument <code>-c-1</code> besagt, dass wir f\u00fcr diesen Server nicht den Browser-Cache verwenden wollen. Jede datei, die wir somit vom Webserver anfordern, wird somit auch tats\u00e4chlich neu geladen. Stattdessen wollen wir n\u00e4mlich nur den Cache des service workers verwenden. </p> <p>F\u00fcr unseren service worker erstellen wir uns im <code>public</code>-Ordner eine Datei <code>sw.js</code>. Da der service worker im <code>public</code>-Ordner angelegt wird, ist sein Scope unsere komplette Webanwendung. Wollten wir z.B. einen service worker, der nur f\u00fcr unsere Hilfe-Seiten zust\u00e4ndig ist, so h\u00e4tten wir die Datei im <code>help</code>-Ordner erzeugt. </p> <p>Um unseren service worker zu registrieren, m\u00fcssen wir ihn in alle unsere HTML-Seiten einbinden. Wir haben die <code>/public/index.html</code>-Datei und die <code>/public/help/index.html</code>. Dort k\u00f6nnten wir innerhalb des eines <code>&lt;script&gt;</code>-Elementes die Registrierung durchf\u00fchren. Da wir aber bereits in beiden Dateien die Datei <code>public/src/js/app.js</code> einbinden, erledigen wir die Registrierung einfach dort. Dann ist sie nur an einer Stelle und wir m\u00fcssen die HTML-Dateien nicht anpassen. In die <code>/public/src/js/app.js</code> schreiben wir nun Folgendes:</p> /public/src/js/app.js <pre><code>if ('serviceWorker' in navigator) {\nnavigator.serviceWorker\n.register('/sw.js')\n.then(function() {\nconsole.log('service worker registriert')\n});\n}\n</code></pre> <p>Starten unserer Anwendung und Aufruf im Browser ergibt die Ausgabe <code>service worker registriert</code> in der Konsole der DevTools. </p> <p></p> <p>Im Zusammenhang mit service workern gibt es folgendes zu beachten:</p> <p>service worker funktionieren nur mit https oder auf localhost!</p> <p>Wundern Sie sich also nicht, wenn Ihr service worker nicht funktioniert, sobald Sie Ihre Anwendung auf einem Webserver ausf\u00fchren, der <code>https</code> nicht unterst\u00fctzt. Anleitungen, wie Sie einen Webserver f\u00fcr <code>https</code> konfigurieren, finden Sie z.B. hier. Schauen Sie ansonsten auch hier und hier.</p>"},{"location":"serviceworker/#service-worker-life-cycle-ereignisse-behandeln","title":"Service worker: Life-Cycle-Ereignisse behandeln","text":"<p>Nun implementieren wir den service worker. Wir haben ihn bereits registriert, aber die Datei <code>sw.js</code> ist noch leer. Die grundlegende Idee eines service workers ist es, Ereignisse zu behandeln. Wir werden unserem service worker also eine Reihe von <code>addEventListener()</code>-Funktionen hinzuf\u00fcgen. Diese Funktion kennen wir bereits aus \"normalem\" JavaScript-Code. Dort haben h\u00e4ufig so etwas wie <code>addEventListener('click', function() { /* ... */ })</code> geschrieben. Das <code>click</code>-Ereignis hat aber keine Relevanz f\u00fcr service worker, da ein service worker keine Auswirkungen auf das DOM hat. Vielmehr reagiert ein service worker auf Ereignisse, die wir bereits oben beschrieben haben. Wir f\u00fcgen unserem service worker Ereignisbehandlungen hinzu:</p> /public/sw.js <pre><code>self.addEventListener('install', function(event) {\nconsole.log('service worker --&gt; installing ...', event);\n})\n\nself.addEventListener('activate', function(event) {\nconsole.log('service worker --&gt; activating ...', event);\nreturn self.clients.claim();\n})\n</code></pre> <p>Wir melden uns also an zwei Ereignisse an: an das <code>install</code>-Ereignis und das <code>activate</code>-Ereignis. Beide Ereignisse sind auch gut hier beschrieben. Beide Ereignisbehandlungen sind zun\u00e4chst einfache Ausgaben auf die Konsole.</p> <p>Zwei Sachen sind noch erw\u00e4hnenswert: erstens wird <code>self</code> verwendet, um auf den service worker zu referenzieren. F\u00fcr Erl\u00e4uterungen \u00fcber den Unterschied von <code>this</code> und <code>self</code> k\u00f6nnen Sie sich z.B. hier informieren. Grunds\u00e4tzlich ist es so, dass mit <code>self</code> auf den gesamten Scope referenziert wird. In Webanwendungen ist der Scope h\u00e4ufig <code>window</code>, hier ist es aber die Domain, die den Scope des service workers beschreibt. Wir referenzieren also nicht auf den service worker selbst, sondern auf seinen Scope. </p> <p>Die zweite erw\u00e4hnenswerte Sache steht in Zeile <code>7</code>. Wenn ein service worker registriert ist, dann \"kontrolliert\" er nicht automatisch alle Webseiten in seiner Domain. Erst durch das Neuladen dieser Seiten gelangen sie unter seine Kontrolle. Mithilfe der <code>claim()</code>-Funktion aus dem Interface <code>Clients</code> \u00fcbernimmt der service worker die Kontrolle aber sofort, d.h. ohne ein Neuladen der Site. Einzige Ausnahme ist die Seite, die aktuell im Browser gezeigt wird. F\u00fcr diese muss tats\u00e4chlich ein Reload durchgef\u00fchrt werden. Weitere Informationen dazu finden Sie auch hier.</p> <p>Wenn wir die Anwendung nun starten und dann im Browser aufrufen, erhalten wir folgende Ausgabe auf der Konsole:</p> <p></p> <p>Wir sehen, dass das <code>install</code>-Ereignis ausgel\u00f6st wurde, aber offensichtlich nicht das <code>activate</code>-Ereignis. Warum wurde das <code>activate</code>-Ereignis nicht ausgel\u00f6st? Darum k\u00fcmmern wir uns im folgenden Abschnitt.</p> <p>Noch eine kurze Bemerkung zur Reihenfolge der Ausgaben auf der Konsole. Auf der Konsole haben wir folgende Ausgaben:</p> <pre><code>service worker registriert\nservice worker --&gt; installing ...\n</code></pre> <p>Das verwundert wahrscheinlich, weil das <code>install</code>-Event ausgel\u00f6st wird, bevor der service worker (existiert und) registriert werden kann. Also m\u00fcssten die Ausgaben eigentlich in der anderen Reihenfolge erscheinen. Wir erinnern uns (siehe zweite Abbildung ganz oben in diesem Kapitel): der service worker l\u00e4uft auf einem anderen Thread, als das \"normale\" JavaScript unserer Webanwendung. Also laufen <code>app.js</code> und <code>sw.js</code> auf verschiedenen Threads. In welchem dieser beiden Threads nun zuerst eine Ausgabe erfolgt, h\u00e4ngt von vielen verschiedenen Faktoren ab, l\u00e4sst sich aber auch nicht beeinflussen. Dieses Mal war es so, dass der <code>app.js</code>-Thread schneller mit der Ausgabe war, als der <code>sw.js</code>-Thread. Das kann beim n\u00e4chsten Mal schon anders sein. Wichtig ist, dass wir wissen, dass diese beiden Threads g\u00e4nzlich nebenl\u00e4ufig und unabh\u00e4ngig voneinander laufen. Sollten sich dabei Ausgaben \"\u00fcberholen\", dann ist das kein Bug, sondern ein Feature. </p>"},{"location":"serviceworker/#service-worker-aktualisieren-und-aktivieren","title":"Service worker aktualisieren und aktivieren","text":"<p>Warum wurde das <code>activate</code>-Ereignis nicht ausgel\u00f6st? Dazu werfen wir einen Blick in unsere DevTools. Wir w\u00e4hlen den Reiter <code>Application</code> und dann im linken Men\u00fc unter <code>Application</code> den Men\u00fcpunkt <code>Service Woorkers</code>:</p> <p></p> <p>Wir sehen, dass der service worker im Status des Aktivierens ist, aber noch darauf wartet, aktiviert zu sein (<code>waiting to activate</code>). Hierzu ist es wichtig zu wissen:</p> <ul> <li>solange Sie im Browser (mindestens) einen Tab mit Ihrer Webanwendung offen haben, wird ein neuer service worker zwar installiert und registriert, aber nicht aktiviert,</li> <li>das liegt daran, dass die offene Seite eventuell noch mit einem alten service worker kommuniziert (evtl. hat der alte service worker noch etwas im Cache, das mit der Webanwendung synchronisiert werden m\u00fcsste).</li> </ul> <p>Wenn wir den Tab mit unserer Anwendung schlie\u00dfen und ihn erneut \u00f6ffnen, dann sehen wir: </p> <p></p> <p>Es wurden also sowohl das <code>install</code>- als auch das <code>activate</code>-Ereignis ausgel\u00f6st. Auf der Konsole erscheint entsprechend:</p> <p></p> <p>Wenn Sie Ihren service worker aktualisiert haben, m\u00fcssen Sie alle Tabs Ihrer Webanwendung schlie\u00dfen und erneut \u00f6ffnen, um den neuen service worker zu aktivieren!</p> <p>Beherzigen Sie die obige Ausgabe. Es kann Ihnen sehr viel Implementierungskummer bereiten, wenn Sie es nicht tun. Sie ver\u00e4ndern Ihren Code im service worker, aber die \u00c4nderungen sind nicht wirksam? Dann haben Sie vielleicht nur ein Reload Ihrer Webanwendung durchgef\u00fchrt - das reicht aber f\u00fcr den aktualisierten service worker nicht!</p> <p>Aber zum Gl\u00fcck bieten die DevTools Hilfe, so dass Sie w\u00e4hrend der Entwicklung doch nicht immer den Tab schlie\u00dfen und neu \u00f6ffnen m\u00fcssen. Betrachten wir nochmals die folgende Abbildung: </p> <p></p> <p>Sie haben drei M\u00f6glichkeiten, den service zu aktivieren:</p> <ol> <li>Markieren Sie die Checkbox links neben <code>Update on reload</code>. Dann wird durch das Reload Ihrer Webanwendung der aktualisierte service worker aktiviert. </li> <li>Klicken Sie auf den Link <code>Update</code> oder</li> <li>Klicken Sie auf den Link <code>skipWaiting</code>. </li> </ol> <p>Mit einem der drei Hilfen oben vermeiden Sie das Schlie\u00dfen und Neu\u00f6ffnen des Tabs und der Webanwendung. Am einfachsten ist die erste Variante. Dann m\u00fcssen Sie nur noch Reloaden und ansonsten weiter gar nichts machen. </p>"},{"location":"serviceworker/#arrow-notation-verwenden","title":"Arrow-Notation verwenden","text":"<p>Wenn wir uns die Implementierung des service workers anschauen, dann sehen wir, dass wir etwas \"old school\" unterwegs sind, also so ca. 2017 ;-). Wir sollten anstelle der <code>function()</code>-Notation lieber die <code>Arrow</code>-Notation verwenden, um ein bisschen mehr up-to-date zu sein ;-). Zu Arrow-Notation siehe auch Hilfen\u2192Arrow-Notation. Unsere service worker Implementierung sieht dann so aus:</p> /public/src/sw.js <pre><code>self.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\n})\n\nself.addEventListener('activate', event =&gt; {\nconsole.log('service worker --&gt; activating ...', event);\nreturn self.clients.claim();\n})\n</code></pre> <p>Die neuere Notation \u00e4ndert an der Funktionalit\u00e4t nat\u00fcrlich nichts. </p>"},{"location":"serviceworker/#service-worker-andere-ereignisse-behandeln","title":"Service worker: andere Ereignisse behandeln","text":"<p>Bis jetzt haben wir nur Life-Cycle-Events behandelt. Jetzt schauen wir uns einmal das <code>fetch</code>-Ereignis an. Wir wissen bereits, dass das <code>fetch</code>-Ereignis immer dann ausgel\u00f6st wird, wenn etwas vom Webserver geladen wird, wenn also CSS-Dateien oder ein Bild oder JavaScript-Dateien geladen werden. Wir behandeln ein solches Ereignis wiederum mit einer einfachen Konsolen-Ausgabe:</p> /public/src/sw.js <pre><code>self.addEventListener('install', event =&gt; {\nconsole.log('service worker --&gt; installing ...', event);\n})\n\nself.addEventListener('activate', event =&gt; {\nconsole.log('service worker --&gt; activating ...', event);\nreturn self.clients.claim();\n})\n\nself.addEventListener('fetch', event =&gt; {\nconsole.log('service worker --&gt; fetching ...', event);\n})\n</code></pre> <p>Falls wir in den DevTools unter <code>Application</code>\u2192<code>Application</code>\u2192<code>Service Workers</code> das H\u00e4kchen bei <code>Update on Reload</code> gesetzt hatten, m\u00fcssen wir tats\u00e4chlich nur ein Reload der Webanwendung durchf\u00fchren und wir sehen auf der Konsole, dass das <code>fetch</code>-Event selbst f\u00fcr unsere bis jetzt sehr kleine Anwendung recht h\u00e4ufig aufgerufen wird:</p> <p></p> <p>Wenn Sie in die jeweiligen <code>FetchEvent</code>-Objekte hineinklicken, welche Ressourcen jeweils per <code>GET</code> vom Webserver geladen werden. </p>"},{"location":"serviceworker/#anwendung-mit-einem-android-gerat-verbinden","title":"Anwendung mit einem Android-Ger\u00e4t verbinden","text":"<p>Ich kann es leider (bis jetzt noch) nicht ausprobieren, aber hier ist beschrieben, wie Sie die Anwendung auf einem Android-Ger\u00e4t aufrufen k\u00f6nnen. Nun, da wir service worker verwenden, sollte es funktionieren. Das hier mag auch hilfreich sein.</p>"},{"location":"serviceworker/#anwendung-auf-ihrem-iphone-aufrufen","title":"Anwendung auf Ihrem iPhone aufrufen","text":"<p>Um die Anwendung auf Ihrem iPhone aufzurufen, m\u00fcssen Sie sich zun\u00e4chst nur anschauen, was im Terminal ausgegeben wird, nachdem Sie <code>npm start</code> aufgerufen haben:</p> <pre><code>Starting up http-server, serving ./public\nAvailable on:\n    http://127.0.0.1:8080\n    htpp://192.168.1.24:8080\nHit CTRL-C to stop the server\n</code></pre> <p>Rufen Sie in Ihrem iPhone einen Browser auf (z.B. Safari oder Chrome) und geben dort di ezweite der beiden URLs ein (also <code>htpp://192.168.1.24:8080</code>). Die Anwendung wird ausgef\u00fchrt. iOS unterst\u00fctzt aber leider (noch) nicht, dass Sie ein Start-Icon daf\u00fcr auf den Startbildschirm ablegen. </p>"},{"location":"tools/","title":"Werkzeuge","text":""},{"location":"tools/#chrome","title":"Chrome","text":"<p>Es wird empfohlen, Chrome als Browser zu verwenden, da dieser Browser die besten Entwicklertools f\u00fcr Progressive Web Apps zur Verf\u00fcgung stellt. Insbesondere ist es empfehlenswert, das Plugin Lighthouse f\u00fcr die Developertools von Chrome zu installieren. </p>"},{"location":"tools/#lighthouse","title":"Lighthouse","text":"<p>Lighthouse ist ein Plugin f\u00fcr die Chrome-Developertools, mit dessen Hilfe gemessen werden kann, wie progressive eine App ist. Installieren Sie sich dieses Plugin, um auch die Performance Ihrer PWA zu messen.</p>"},{"location":"tools/#integrated-development-environment-ide","title":"Integrated Development Environment (IDE)","text":"<p>F\u00fcr die Webentwicklung stehen Ihnen viele gute Entwicklungswerkzeuge zur Verf\u00fcgung. F\u00fcr welches Sie sich entscheiden, bleibt Ihnen \u00fcberlassen. Hier eine Auswahl der aus meiner Sicht besten Entwicklungswerkzeuge:</p> <ul> <li>IntelliJ IDEA</li> <li>PhpStorm</li> <li>WebStorm</li> <li>Sublime Text</li> <li>Atom</li> <li>Visual Studio Code</li> </ul> <p>F\u00fcr die Tools von Jetbrains ben\u00f6tigen Sie einen Account. Mit Ihrer HTW-E-Mail-Adresse bekommen Sie aber eine kostenlose Hochschullizenz und k\u00f6nnen so die Enterprise-Versionen kostenlos nutzen. Sublime Text ist Shareware und fragt regelm\u00e4\u00dfig, ob Sie spenden m\u00f6chten.  </p>"},{"location":"tools/#nodejs","title":"Node.js","text":"<p>Node.js ist eine JavaScript-Laufzeitumgebung. Node.js reagiert auf Ereignisse und antwortet asynchron. Das bedeutet, dass die Ausf\u00fchrung einer Ereignisbearbeitung nicht zum Blockieren der Laufzeitumgebung f\u00fchrt, sondern nebenl\u00e4ufig weitere Ereignisse eintreffen k\u00f6nnen, die ebenfalls asynchron behandelt werden. Dies geschieht mithilfe des Callback-Patterns. Laden Sie sich hier die aktuellste Version von Node.js herunter und installieren Sie diese auf Ihrem Rechner.</p>"},{"location":"tools/#android-studio","title":"Android Studio","text":"<p>Um unsere PWAs als mobile Webanwendungen zu emulieren, benutzen wir Android Studio. Es ist f\u00fcr Mac, Linux und Windows verf\u00fcgbar. Laden Sie es sich herunter und installieren Sie es. Sie k\u00f6nnen es herunterladen und installieren, ohne einen Google-Account anzulegen (es gibt auch keinen Grund, das zu tun ;-)).</p>"},{"location":"tools/#https-fur-localhost","title":"https f\u00fcr localhost","text":"<ul> <li>f\u00fcr Mac siehe hier</li> </ul>"},{"location":"tools/#https-fur-webserver","title":"https f\u00fcr Webserver","text":"<ul> <li>siehe hier</li> <li>siehe hier</li> </ul>"},{"location":"tools/#ngrok","title":"Ngrok","text":"<p>Ngrok stellt einen sicheren Tunnel zu einem Webserver her. Ngrok wirkt wie ein Proxy, der einer Anwendung suggeriert, mit einem Webserver \u00fcber eine sichere Verbindung zu kommunizieren, d.h. die Verbindung wirkt wie eine <code>https</code>-Verbindung. Die Installation ist einfach, ben\u00f6tigt aber Registrierungsdaten (zur Erzeugung des Authentifizierungstokens). Nach dem Download wird das Paket entpackt und mit dem Authentifizierungstoken aufgerufen. Nach dem Starten der Webanwendung stellt man mit <code>ngrok http &lt;Port&gt;</code> den sicheren Tunnel her, wobei <code>&lt;Port&gt;</code> f\u00fcr den Port steht, unter dem die Anwednung auf dem Webserver l\u00e4uft.  </p>"},{"location":"tools/#icons-erzeugen-und-in-die-manifestjson-eintragen","title":"Icons erzeugen und in die manifest.json eintragen","text":"<p>Es ist ziemlich m\u00fchsam, alle ben\u00f6tigten Icons f\u00fcr die unterschiedlichen Plattformen zu erzeugen und dann noch die entsprechenden Eintr\u00e4ge in der <code>manifest.json</code> vorzunehmen. Zum Gl\u00fcck gibt es aber ein Werkzeug, das das f\u00fcr uns \u00fcbernimmt: pwa-asset-generator. Sie ben\u00f6tigen nur das Ausgangsicon in Originalgr\u00f6\u00dfe und alles andere wird f\u00fcr Sie erledgt. Alles weitere dazu steht hier.</p>"},{"location":"tools/#webapp-manifest-generator","title":"WebApp-Manifest-Generator","text":"<p>Bei der Erstellung Ihrer <code>manifest.json</code> k\u00f6nnen Sie sich auch unterst\u00fctzen lassen, n\u00e4mlich hier oder hier.</p>"},{"location":"tools/#workbox","title":"Workbox","text":"<p>Workbox ist eine JavaScript-Bibliothek, die alle wesentlichen Funktionalit\u00e4ten von Service Workern bereitstellt. </p>"},{"location":"tools/#mongodb","title":"MongoDB","text":"<p>Es gibt zwei M\u00f6glichkeiten, MongoDB zu verwenden: entweder Sie nutzen das Cloud-Angebot, also eine Remote-MongoDB. Diese nennt sich MongoDB Atlas. Oder Sie installieren sich die MongoDB \"on-premise\", also lokal auf Ihrem Rechner. Dazu w\u00e4hlen Sie unter <code>mongodb.com</code> den Reiter <code>Products</code> on dort unter <code>Community Edition</code> den Link <code>Community Server</code>. Dann landen Sie auf https://www.mongodb.com/try/download/community. Dort k\u00f6nnen Sie sich die MongoDB herunterladen und installieren. Installationsanleitungen finden Sie unter https://www.mongodb.com/docs/manual/installation/. Wichtig ist, dass die MongoDB einmalig mit <code>mongod</code> starten.</p>"},{"location":"tools/#mongodb-compass","title":"MongoDB Compass","text":"<p>Um sich Ihre MongoDB-Datenbanken anzuschauen (und auch, um Operationen darauf auszuf\u00fchren), empfehle ich Ihnen das Tool MongoDB Compass. Download und Installation sind normalerweise einfach. </p>"},{"location":"tools/#insomnia-rest","title":"Insomnia REST","text":"<p>Eine gute Alternative zu Postman ist Insomnia. Sehr empfehlenswert! Aber Postman auch.</p>"},{"location":"tools/#interssante-links-zu-pwa","title":"Interssante Links zu PWA","text":"<ul> <li>PWA Checklist</li> <li>PWA API</li> <li>11 Examples of Progressive Web Apps</li> <li>How-to: Progressive Web Apps praktisch erkl\u00e4rt</li> <li>Chrome Developer Summit 2020</li> <li>12 Best Examples of Progressive Web Apps (PWAs) in 2020</li> <li>Lighthouse Performance Scoring</li> <li>Service worker Spezifikation</li> </ul>"},{"location":"uebungen/","title":"\u00dcbungen","text":""},{"location":"uebungen/#ubung-1-grundgerust","title":"\u00dcbung 1 (Grundger\u00fcst)","text":"\u00dcbung 1 <ol> <li>In der ersten \u00dcbung geht es \"nur\" darum, das Grundger\u00fcst zu verstehen. Arbeiten Sie dazu diesen Abschnitt durch. Sie werden feststellen, dass sich die meisten Anweisungen (insb. im <code>HTML</code>-Code) auf Material Design Lite beziehen. </li> <li>Um zu erkennen, was einen Material Design Lite-Bezug hat (und somit nicht wirklich wichtig ist),  \u00e4ndern Sie das Grundger\u00fcst so, dass Sie nicht Material Design Lite, sondern Bootstrap verwenden. Werfen Sie also Material Design Lite komplett raus und ersetzen es vollst\u00e4ndig durch Bootstrap. L\u00f6schen Sie die <code>material.min.js</code> aus dem <code>public/js</code>-Ordner.</li> <li>Starten Sie am besten damit, diese drei Zeilen aus den beiden <code>index.html</code>-Dateien zu l\u00f6schen:     <pre><code>&lt;link href=\"https://fonts.googleapis.com/css?family=Roboto:400,700\" rel=\"stylesheet\"&gt;\n&lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"&gt;\n&lt;link rel=\"stylesheet\" href=\"https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css\"&gt;\n</code></pre></li> <li>F\u00fcgen Sie stattdessen den CSS-Link und das JS-Bundle aus https://getbootstrap.com/docs/5.0/getting-started/introduction/ ein. </li> <li>Sie k\u00f6nnen ja versuchen, dass es m\u00f6glichst \u00e4hnlich aussieht:     </li> </ol>"},{"location":"uebungen/#ubung-2-web-app-manifest","title":"\u00dcbung 2 (Web App Manifest)","text":"\u00dcbung 2 <ol> <li>Erweitern Sie Ihre Anwendung (oder das Grundger\u00fcst) um ein Web App Manifest. Verwenden Sie dazu am besten den pwa-asset-generator.  </li> <li>Die Anwendung soll in dem Moment installiert werden, wenn die Nutzerin das erste Mal auf den <code>+</code>-Button klickt. Das hei\u00dft, es wird das <code>beforeinstallprompt</code>-Ereignis ausgel\u00f6st und die Behandlung dieses Ereignisses sorgt daf\u00fcr, dass Sie die Anwendung genau dann installieren, wenn Sie das erste Mal den <code>+</code>-Button klicken: </li> <li>Hinweise und Hilfestellungen finden Sie z.B. hier oder im Skript (enth\u00e4lt weitere Links).</li> </ol>"},{"location":"uebungen/#ubung-3-promises-und-fetch-api","title":"\u00dcbung 3 (Promises und Fetch API)","text":"\u00dcbung 3 <ol> <li>Clonen Sie sich hier die Anwendung f\u00fcr \u00dcbung 3. Wechseln Sie in den Ordner und \u00f6ffnen Sie die \u00dcbung in Ihrer IDE. Lesen Sie die README.MD. </li> <li> <p>In der \u00dcbung \u00fcben wir Promises und die Fetch API. \u00d6ffnen Sie die Datei <code>public/src/js/app.js</code>. Die \u00dcbung besteht aus 3 Teilen:</p> <ol> <li>Teil 1: f\u00fchren Sie ein <code>fetch()</code> als GET nach <code>https://jsonplaceholder.typicode.com/posts/1</code> aus (siehe https://jsonplaceholder.typicode.com). Lassen Sie sich die <code>Response</code> auf die Konsole ausgeben. Wenden Sie dann noch <code>json()</code> an und schauen sich das erzeugte Objekt an (lassen es ebenfalls auf der Konsole ausgeben). \u00dcbergeben Sie den <code>title</code> an das <code>output</code>-Element (<code>&lt;p id=\"output\"&gt;&lt;/p&gt;</code>) aus der <code>public/index.html</code>.</li> <li>Teil 2: f\u00fchren Sie ein <code>fetch()</code> als POST nach <code>https://jsonplaceholder.typicode.com/posts</code> aus. Beachten Sie das Format des zu sendenden JSON-Objektes (Eigenschaften <code>title</code>, <code>body</code> und <code>userId</code>). Das JSON-Objekt wird zur\u00fcckgesendet. Geben Sie einen oder mehrere Werte aus diesem JSON in das <code>output</code>-Element aus.</li> <li>Teil 3: bauen Sie einen Fehler in die Anfrage (z.B. falsche Url) und behandeln Sie diesen Fehler mit einer Ausgabe auf die Konsole. Lesen Sie dazu die Kommentare in der <code>app.js</code>.</li> </ol> </li> <li> <p>Hinweise und Hilfestellungen finden Sie im Skript unter Promises und die Fetch-API.</p> </li> </ol>"},{"location":"uebungen/#ubung-4-mongodb-cloud-atlas-und-compass-einrichten","title":"\u00dcbung 4 (MongoDB Cloud Atlas und Compass einrichten)","text":"\u00dcbung 4 <p>Wir richten unsere Entwicklungs-Infrastruktur, insbesondere die MongoDB ein, die wir ben\u00f6tigen, um eine Frontend-Backend-Datenbank-App zu erstellen.</p> <ol> <li> <p><code>MongoDB Atlas</code> einrichten:</p> <ul> <li> <p>Es ist nicht notwendig, die MongoDB lokal zu installieren. Wenn Sie es doch tun wollen, dann w\u00e4hlen Sie den MongoDB Community Server. Es ist aber, insbesondere f\u00fcr ein sp\u00e4teres Deployment ratsam, die Cloud-L\u00f6sung MongoDB Atlas zu verwenden. Registrieren bzw. loggen Sie sich ein und erstellen Sie sich einen M0-Cluster, z.B. <code>IKT-PWA</code>, wie im folgenden Bild:</p> <p> </p> </li> <li> <p>Erstellen Sie eine Nutzerin und w\u00e4hlen Sie die Authentisierungsmethode. Sie k\u00f6nnen die Account-Passwort-L\u00f6sung oder das X.509-Zertifikat w\u00e4hlen. In der Vorlesung zeige ich die Verwendung mithilfe des X509-Zertikats. </p> </li> <li> <p>Schauen Sie sich unter <code>Connect</code> \u2192 <code>Drivers</code> an, wie Sie in Node.js eine Verbindung zur Datenbank herstellen k\u00f6nnen.</p> </li> </ul> </li> <li> <p><code>MongoDB Compass</code> einrichten</p> <ul> <li> <p>Laden Sie MongoDB Compass herunter und installieren es. </p> </li> <li> <p>Stellen Sie eine Verbindung zu Ihrer <code>MongoDB Atlas</code> her. </p> </li> <li> <p>Erstellen Sie eine Datenbank (z.B. <code>htwinsta</code>) und eine Collection (z.B. <code>posts</code>). </p> </li> <li> <p>Sie k\u00f6nnen auch schon einen Datensatz hinzuf\u00fcgen, wenn Sie m\u00f6chten. Dann sollte es Bei Ihnen wie im folgenden Bild aussehen:</p> <p> </p> </li> </ul> </li> <li> <p><code>Postman</code> installieren:</p> <ul> <li> <p>Postman ist eine Anwendung, um Schnittstellen (Application Programming Interface - API), die das Backend bereitstellt, zu entwickeln und zu testen. Sie finden Postman unter postman.com. Wir beschr\u00e4nken uns auf den Postman API Client.</p> </li> <li> <p>Laden Sie das Tool herunter und installieren es. Rufen Sie Postman auf und geben in das Eingabefeld <code>https://postman-echo.com/get</code> ein. Lassen Sie die Auswahl links daneben auf <code>GET</code> und klicken auf den <code>Send</code>-Button. Es erscheint folgendes Bild:</p> <p></p> </li> <li> <p>Neben der <code>GET</code>-Anfrage sind folgende weitere Anfragen HTTP-Anfragen m\u00f6glich:</p> <ul> <li><code>POST</code> - sendet Daten zur Verarbeitung an den Webserver</li> <li><code>PUT</code> - l\u00e4dt existierende Daten (eine Datei) auf den Server</li> <li><code>PATCH</code> - \u00e4ndert Daten (eine Datei), ohne - wie bei <code>PUT</code> - diese vollst\u00e4ndig zu ersetzen</li> <li><code>DELETE</code> - l\u00f6scht die angegebenen Daten auf dem Server</li> </ul> </li> </ul> </li> <li> <p><code>Node.js</code> installieren:</p> <ul> <li>Node.js ist eine JavaScript-Laufzeitumgebung f\u00fcr einen Server. Node.js reagiert auf Ereignisse und antwortet asynchron. Das bedeutet, dass die Ausf\u00fchrung einer Ereignisbearbeitung nicht zum Blockieren der Laufzeitumgebung f\u00fchrt, sondern nebenl\u00e4ufig weitere Ereignisse eintreffen k\u00f6nnen, die ebenfalls asynchron behandelt werden. </li> <li>Laden Sie sich hier Node.js herunter und installieren es. </li> </ul> </li> <li> <p>Paketmanager <code>npm</code>:</p> <ul> <li>Mit der Installation von <code>node.js</code>, installieren Sie auch den Paketmanager <code>npm</code> (siehe npmjs). </li> <li> <p>Sie k\u00f6nnen testen, ob die Installation von <code>node</code> und <code>npm</code> erfolgreich war, indem Sie im Terminal (Windows-Nutzerinnen bitte als Terminal die GitBash verwenden) eingeben:</p> <pre><code>node --version\n</code></pre> <p>Sollte etwas, wie <code>v14.20.0</code> ausgeben und</p> <pre><code>npm --version\n</code></pre> <p>sollte etwas, wie <code>9.1.2</code> ausgeben. Achten Sie darauf, dass Sie eine gerade Versionsnummer von <code>node.js</code> installieren (also 14 oder 16, nicht 15)!</p> </li> </ul> </li> </ol>"},{"location":"uebungen/#ubung-5-backend","title":"\u00dcbung 5 (Backend)","text":"\u00dcbung 5 <ol> <li> <p>Erg\u00e4nzen Sie das in Backend erstellte Backend um folgende Endpunkte: </p> <ul> <li><code>POST /registration</code> und</li> <li><code>POST /login</code></li> </ul> <p>Beiden Endpunkten soll ein JSON in der Form</p> <pre><code>{\n\"email\": \"test@test.de\",\n\"password\": \"testpassword\"\n}\n</code></pre> <p>im <code>body</code> des Requests \u00fcbergeben werden. Der erste Punkt registriert die Nutzerin und mit dem zweiten Endpunkt soll \u00fcberpr\u00fcft werden, ob die Nutzerin bereits existiert und das Passwort stimmt. Verwenden Sie zum Verschl\u00fcsseln des Passwortes in der MongoDB das bcrypt-Paket. Um ein Passwort zu verschl\u00fcsseln, nutzen Sie die <code>hash()</code>-Funktion (oder <code>hashSync()</code>):</p> <pre><code>bcrypt.hash(myPlaintextPassword, saltRounds, function(err, hash) {\n// Store hash in your password DB.\n});\n</code></pre> <p>Um ein Passwort zu \u00fcberpr\u00fcfen, nutzen Sie die <code>compare()</code>-Funktion (oder <code>compareSync()</code>):</p> <pre><code>// Load hash from your password DB.\nbcrypt.compare(myPlaintextPassword, hash, function(err, result) {\n// result == true (myPlaintextPassword == hash) or \n// result == false (myPlaintextPassword != hash)\n});\n</code></pre> <p>Achten Sie darauf, dass eine E-Mail nur einmal verwendet wird, d.h. bei der Registrierung m\u00fcssen Sie zun\u00e4chst pr\u00fcfen, ob es noch keinen Datensatz mit der angefragten <code>email</code> gibt. </p> </li> <li> <p>Erstellen Sie sich dazu eine neue Collection <code>users</code> (Schema <code>User</code>).</p> <p> </p> </li> </ol>"},{"location":"uebungen/#ubung-6-frontend","title":"\u00dcbung 6 (Frontend)","text":"\u00dcbung 6 <ol> <li>Clonen Sie sich hier die Anwendung f\u00fcr \u00dcbung 6. </li> <li>Lesen Sie die README.MD](https://github.com/jfreiheit/IKT-Uebung6)</li> <li>\u00d6ffnen Sie das Projekt in Ihrer IDE und implementieren Sie die <code>app.js</code>. Die Aufgabe ist dort in den Kommentaren beschrieben.  </li> </ol>"},{"location":"uebungen/#ubung-7-kamera-und-geolocation-map","title":"\u00dcbung 7 (Kamera und Geolocation + Map)","text":"\u00dcbung 7 <ol> <li>Verwenden Sie Kamera und Geolocation in Ihrem Projekt.</li> <li>Lassen Sie Ihre Geolocation mithilfe von OpenLayers anzeigen. </li> </ol>"},{"location":"uebungen/#ubung-8-indexeddb","title":"\u00dcbung 8 (IndexedDB)","text":"\u00dcbung 8 <ol> <li>Im Abschnitt IndexedDB haben wir uns mit der Verwendung der In-Browser-Datenbank IndexedDB vertraut gemacht. </li> <li>In dem dortigen letzten Abschnitt L\u00f6schen einzelner Eintr\u00e4ge haben wir in der <code>db.js</code> eine Funktion <code>deleteOneData(st, id)</code> geschrieben, die einen einzelnen Datensatz aus der IndexedDB mit der \u00fcbergebenen <code>id</code> l\u00f6scht. </li> <li>Implementieren Sie in der <code>db.js</code> eine Funktion <code>deleteByTitle(st, title)</code>, die den Datensatz (oder die Datens\u00e4tze) l\u00f6scht, der (oder die) in dem <code>title</code>-Attribut den der Methode als <code>title</code> \u00fcbergebenen String enth\u00e4lt. Z.B. soll aus dem Datensatz      <pre><code>{id: 1, title: \"first post\", location: \"Berlin\", image: \"/9j/4AA...UgP/9k=\"}\n{id: 2, title: \"second post\", location: \"Wilhelminenhof\", image: \"/9j/4AA...VY/9k=\"}\n{id: 5, title: \"fourth post\", location: \"Gebaeude C\", image: \"/9j/4AA...KOX/9k=\"}\n{id: 10, title: \"HTW aus der Luft\", location: \"Campus WH von oben\", image: \"/9j/4AA...9z//2Q==\"}\n{id: 11, title: \"Wilhelminenhofstra\u00dfe\", location: \"Campus WH Eingang\", image: \"/9j/4AA...U9D/9k=\"}\n</code></pre><ul> <li>bei Aufruf von <code>deleteByTitle('posts', 'second')</code> der zweite Datensatz mit der <code>id: 2</code> gel\u00f6scht werden, </li> <li>bei Aufruf von <code>deleteByTitle('posts', 'post')</code> sollen die ersten drei Datens\u00e4tze (mit <code>id:1</code>, <code>id:2</code> und <code>id:5</code>) gel\u00f6scht werden.</li> </ul> </li> </ol> <p>Tipps: Mit der Methode getAllKeys() ermitteln Sie z.B. alle Schl\u00fcssel (<code>id</code>) der Datens\u00e4tze und mit der Methode get(key) erhalten Sie den zum Schl\u00fcssel zugeh\u00f6rigen Wert.</p>"}]}